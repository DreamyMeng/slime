window.Laya = (function (exports) {
    'use strict';

    class ILaya {
    }
    ILaya.Loader = null;
    ILaya.Context = null;
    ILaya.Browser = null;
    ILaya.Laya = null;
    ILaya.loader = null;
    ILaya.timer = null;
    ILaya.systemTimer = null;
    ILaya.physicsTimer = null;
    ILaya.stage = null;

    class Pool {
        static getPoolBySign(sign) {
            return Pool._poolDic[sign] || (Pool._poolDic[sign] = []);
        }
        static clearBySign(sign) {
            if (Pool._poolDic[sign])
                Pool._poolDic[sign].length = 0;
        }
        static recover(sign, item) {
            if (item[Pool.POOLSIGN])
                return;
            item[Pool.POOLSIGN] = true;
            Pool.getPoolBySign(sign).push(item);
        }
        static recoverByClass(instance) {
            if (instance) {
                var className = instance["__className"] || instance.constructor._$gid;
                if (className)
                    Pool.recover(className, instance);
            }
        }
        static _getClassSign(cla) {
            var className = cla["__className"] || cla["_$gid"];
            if (!className) {
                cla["_$gid"] = className = Pool._CLSID + "";
                Pool._CLSID++;
            }
            return className;
        }
        static createByClass(cls) {
            return Pool.getItemByClass(Pool._getClassSign(cls), cls);
        }
        static getItemByClass(sign, cls) {
            let rst;
            let pool = Pool.getPoolBySign(sign);
            if (pool.length)
                rst = pool.pop();
            else
                rst = new cls();
            rst[Pool.POOLSIGN] = false;
            return rst;
        }
        static getItemByCreateFun(sign, createFun, caller = null) {
            var pool = Pool.getPoolBySign(sign);
            var rst = pool.length ? pool.pop() : createFun.call(caller);
            rst[Pool.POOLSIGN] = false;
            return rst;
        }
        static getItem(sign) {
            var pool = Pool.getPoolBySign(sign);
            var rst = pool.length ? pool.pop() : null;
            if (rst) {
                rst[Pool.POOLSIGN] = false;
            }
            return rst;
        }
    }
    Pool._CLSID = 0;
    Pool.POOLSIGN = "__InPool";
    Pool._poolDic = {};

    class Point {
        constructor(x = 0, y = 0) {
            this.x = x;
            this.y = y;
        }
        static create() {
            return Pool.getItemByClass("Point", Point);
        }
        setTo(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }
        reset() {
            this.x = this.y = 0;
            return this;
        }
        recover() {
            Pool.recover("Point", this.reset());
        }
        distance(x, y) {
            return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y) * (this.y - y));
        }
        toString() {
            return this.x + "," + this.y;
        }
        normalize() {
            var d = Math.sqrt(this.x * this.x + this.y * this.y);
            if (d > 0) {
                var id = 1.0 / d;
                this.x *= id;
                this.y *= id;
            }
        }
        copy(point) {
            return this.setTo(point.x, point.y);
        }
    }
    Point.TEMP = new Point();
    Point.EMPTY = new Point();

    class Event {
        static isMouseEvent(type) {
            return MOUSE_EVENTS.has(type);
        }
        constructor() {
            this.touchId = 0;
            this.delta = 0;
            this.button = 0;
            this.touchPos = new Point();
        }
        setTo(type, currentTarget, target) {
            this.type = type;
            this.currentTarget = currentTarget;
            this.target = target;
            return this;
        }
        stopPropagation() {
            this._stopped = true;
        }
        get touches() {
            return this._touches;
        }
        get altKey() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.altKey;
        }
        get ctrlKey() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.ctrlKey;
        }
        get shiftKey() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.shiftKey;
        }
        get metaKey() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.metaKey;
        }
        get key() {
            return this.nativeEvent.key;
        }
        get keyCode() {
            return this.nativeEvent.keyCode;
        }
        get charCode() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.code;
        }
        get keyLocation() {
            if (this.nativeEvent)
                return this.nativeEvent.location || this.nativeEvent.keyLocation;
            else
                return 0;
        }
        get stageX() {
            return this.touchPos.x;
        }
        get stageY() {
            return this.touchPos.y;
        }
    }
    Event.EMPTY = new Event();
    Event.MOUSE_DOWN = "mousedown";
    Event.MOUSE_UP = "mouseup";
    Event.RIGHT_MOUSE_DOWN = "rightmousedown";
    Event.RIGHT_MOUSE_UP = "rightmouseup";
    Event.CLICK = "click";
    Event.RIGHT_CLICK = "rightclick";
    Event.MOUSE_MOVE = "mousemove";
    Event.MOUSE_OVER = "mouseover";
    Event.MOUSE_OUT = "mouseout";
    Event.MOUSE_WHEEL = "mousewheel";
    Event.ROLL_OVER = "mouseover";
    Event.ROLL_OUT = "mouseout";
    Event.DOUBLE_CLICK = "doubleclick";
    Event.MOUSE_DRAG = "mousedrag";
    Event.MOUSE_DRAG_END = "mousedragend";
    Event.DRAG_START = "dragstart";
    Event.DRAG_MOVE = "dragmove";
    Event.DRAG_END = "dragend";
    Event.KEY_DOWN = "keydown";
    Event.KEY_PRESS = "keypress";
    Event.KEY_UP = "keyup";
    Event.CHANGE = "change";
    Event.CHANGED = "changed";
    Event.WILL_RESIZE = "willResize";
    Event.RESIZE = "resize";
    Event.ADDED = "added";
    Event.REMOVED = "removed";
    Event.DISPLAY = "display";
    Event.UNDISPLAY = "undisplay";
    Event.ERROR = "error";
    Event.COMPLETE = "complete";
    Event.LOADED = "loaded";
    Event.READY = "ready";
    Event.PROGRESS = "progress";
    Event.INPUT = "input";
    Event.RENDER = "render";
    Event.OPEN = "open";
    Event.MESSAGE = "message";
    Event.CLOSE = "close";
    Event.FRAME = "enterframe";
    Event.ENTER = "enter";
    Event.SELECT = "select";
    Event.BLUR = "blur";
    Event.FOCUS = "focus";
    Event.VISIBILITY_CHANGE = "visibilitychange";
    Event.FOCUS_CHANGE = "focuschange";
    Event.PLAYED = "played";
    Event.PAUSED = "paused";
    Event.STOPPED = "stopped";
    Event.START = "start";
    Event.END = "end";
    Event.LINK = "link";
    Event.LABEL = "label";
    Event.FULL_SCREEN_CHANGE = "fullscreenchange";
    Event.DEVICE_LOST = "devicelost";
    Event.TRANSFORM_CHANGED = "transformchanged";
    Event.LAYERCHANGE = "layerChange";
    Event.staticMask = "staticMask";
    Event.TRIGGER_ENTER = "triggerenter";
    Event.TRIGGER_STAY = "triggerstay";
    Event.TRIGGER_EXIT = "triggerexit";
    Event.COLLISION_ENTER = "collisionenter";
    Event.COLLISION_STAY = "collisionstay";
    Event.COLLISION_EXIT = "collisionexit";
    Event.JOINT_BREAK = "jointbreak";
    Event._Add_Script = "addscript";
    const MOUSE_EVENTS = new Set([
        Event.MOUSE_DOWN, Event.MOUSE_UP, Event.MOUSE_MOVE, Event.CLICK, Event.DOUBLE_CLICK,
        Event.RIGHT_CLICK, Event.RIGHT_MOUSE_DOWN, Event.RIGHT_MOUSE_UP,
        Event.MOUSE_OVER, Event.MOUSE_OUT, Event.MOUSE_WHEEL, Event.MOUSE_DRAG, Event.MOUSE_DRAG_END
    ]);

    class LayaEnv {
    }
    LayaEnv.version = "3.2.5";
    LayaEnv.isPlaying = true;
    LayaEnv.isPreview = false;
    LayaEnv.isConch = window ? (window.conch != null) : false;
    LayaEnv.isEditor = false;

    class LayaGL {
    }

    exports.RenderTargetFormat = void 0;
    (function (RenderTargetFormat) {
        RenderTargetFormat[RenderTargetFormat["None"] = -1] = "None";
        RenderTargetFormat[RenderTargetFormat["R8G8B8"] = 0] = "R8G8B8";
        RenderTargetFormat[RenderTargetFormat["R8G8B8A8"] = 1] = "R8G8B8A8";
        RenderTargetFormat[RenderTargetFormat["R16G16B16A16"] = 17] = "R16G16B16A16";
        RenderTargetFormat[RenderTargetFormat["R32G32B32"] = 30] = "R32G32B32";
        RenderTargetFormat[RenderTargetFormat["R32G32B32A32"] = 15] = "R32G32B32A32";
        RenderTargetFormat[RenderTargetFormat["R16G16B16"] = 31] = "R16G16B16";
        RenderTargetFormat[RenderTargetFormat["DEPTH_16"] = 35] = "DEPTH_16";
        RenderTargetFormat[RenderTargetFormat["STENCIL_8"] = 36] = "STENCIL_8";
        RenderTargetFormat[RenderTargetFormat["DEPTHSTENCIL_24_8"] = 37] = "DEPTHSTENCIL_24_8";
        RenderTargetFormat[RenderTargetFormat["DEPTH_32"] = 38] = "DEPTH_32";
        RenderTargetFormat[RenderTargetFormat["DEPTHSTENCIL_24_Plus"] = 39] = "DEPTHSTENCIL_24_Plus";
    })(exports.RenderTargetFormat || (exports.RenderTargetFormat = {}));

    class MathUtils3D {
        constructor() {
        }
        static isZero(v) {
            return Math.abs(v) < MathUtils3D.zeroTolerance;
        }
        static nearEqual(n1, n2) {
            if (MathUtils3D.isZero(n1 - n2))
                return true;
            return false;
        }
        static fastInvSqrt(value) {
            if (MathUtils3D.isZero(value))
                return value;
            return 1.0 / Math.sqrt(value);
        }
    }
    MathUtils3D.zeroTolerance = 1e-6;
    MathUtils3D.MaxValue = 3.40282347e+38;
    MathUtils3D.MinValue = -3.40282347e+38;
    MathUtils3D.Deg2Rad = Math.PI / 180;

    class Vector4 {
        constructor(x = 0, y = 0, z = 0, w = 0) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        setValue(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        fromArray(arr, offset = 0) {
            this.x = arr[offset + 0];
            this.y = arr[offset + 1];
            this.z = arr[offset + 2];
            this.w = arr[offset + 3];
        }
        toArray() {
            return [this.x, this.y, this.z, this.w];
        }
        writeTo(arr, offset = 0) {
            arr[offset + 0] = this.x;
            arr[offset + 1] = this.y;
            arr[offset + 2] = this.z;
            arr[offset + 3] = this.w;
        }
        cloneTo(destObject) {
            destObject.x = this.x;
            destObject.y = this.y;
            destObject.z = this.z;
            destObject.w = this.w;
        }
        clone() {
            var destVector4 = new Vector4();
            this.cloneTo(destVector4);
            return destVector4;
        }
        static lerp(a, b, t, out) {
            var ax = a.x, ay = a.y, az = a.z, aw = a.w;
            out.x = ax + t * (b.x - ax);
            out.y = ay + t * (b.y - ay);
            out.z = az + t * (b.z - az);
            out.w = aw + t * (b.w - aw);
        }
        static transformByM4x4(vector4, m4x4, out) {
            var vx = vector4.x;
            var vy = vector4.y;
            var vz = vector4.z;
            var vw = vector4.w;
            var me = m4x4.elements;
            out.x = vx * me[0] + vy * me[4] + vz * me[8] + vw * me[12];
            out.y = vx * me[1] + vy * me[5] + vz * me[9] + vw * me[13];
            out.z = vx * me[2] + vy * me[6] + vz * me[10] + vw * me[14];
            out.w = vx * me[3] + vy * me[7] + vz * me[11] + vw * me[15];
        }
        static equals(a, b) {
            return MathUtils3D.nearEqual(Math.abs(a.x), Math.abs(b.x)) && MathUtils3D.nearEqual(Math.abs(a.y), Math.abs(b.y)) && MathUtils3D.nearEqual(Math.abs(a.z), Math.abs(b.z)) && MathUtils3D.nearEqual(Math.abs(a.w), Math.abs(b.w));
        }
        equal(value) {
            return Vector4.equals(this, value);
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        lengthSquared() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        static normalize(s, out) {
            var len = s.length();
            if (len > 0) {
                var inverse = 1.0 / len;
                out.x = s.x * inverse;
                out.y = s.y * inverse;
                out.z = s.z * inverse;
                out.w = s.w * inverse;
            }
        }
        static add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
            out.z = a.z + b.z;
            out.w = a.w + b.w;
        }
        static subtract(a, b, out) {
            out.x = a.x - b.x;
            out.y = a.y - b.y;
            out.z = a.z - b.z;
            out.w = a.w - b.w;
        }
        static multiply(a, b, out) {
            out.x = a.x * b.x;
            out.y = a.y * b.y;
            out.z = a.z * b.z;
            out.w = a.w * b.w;
        }
        static scale(a, b, out) {
            out.x = a.x * b;
            out.y = a.y * b;
            out.z = a.z * b;
            out.w = a.w * b;
        }
        static Clamp(value, min, max, out) {
            var x = value.x;
            var y = value.y;
            var z = value.z;
            var w = value.w;
            var mineX = min.x;
            var mineY = min.y;
            var mineZ = min.z;
            var mineW = min.w;
            var maxeX = max.x;
            var maxeY = max.y;
            var maxeZ = max.z;
            var maxeW = max.w;
            x = (x > maxeX) ? maxeX : x;
            x = (x < mineX) ? mineX : x;
            y = (y > maxeY) ? maxeY : y;
            y = (y < mineY) ? mineY : y;
            z = (z > maxeZ) ? maxeZ : z;
            z = (z < mineZ) ? mineZ : z;
            w = (w > maxeW) ? maxeW : w;
            w = (w < mineW) ? mineW : w;
            out.x = x;
            out.y = y;
            out.z = z;
            out.w = w;
        }
        static distanceSquared(value1, value2) {
            var x = value1.x - value2.x;
            var y = value1.y - value2.y;
            var z = value1.z - value2.z;
            var w = value1.w - value2.w;
            return (x * x) + (y * y) + (z * z) + (w * w);
        }
        static distance(value1, value2) {
            var x = value1.x - value2.x;
            var y = value1.y - value2.y;
            var z = value1.z - value2.z;
            var w = value1.w - value2.w;
            return Math.sqrt((x * x) + (y * y) + (z * z) + (w * w));
        }
        static dot(a, b) {
            return (a.x * b.x) + (a.y * b.y) + (a.z * b.z) + (a.w * b.w);
        }
        static min(a, b, out) {
            out.x = Math.min(a.x, b.x);
            out.y = Math.min(a.y, b.y);
            out.z = Math.min(a.z, b.z);
            out.w = Math.min(a.w, b.w);
        }
        static max(a, b, out) {
            out.x = Math.max(a.x, b.x);
            out.y = Math.max(a.y, b.y);
            out.z = Math.max(a.z, b.z);
            out.w = Math.max(a.w, b.w);
        }
    }
    Vector4.ZERO = new Vector4();
    Vector4.ONE = new Vector4(1.0, 1.0, 1.0, 1.0);
    Vector4.UnitX = new Vector4(1.0, 0.0, 0.0, 0.0);
    Vector4.UnitY = new Vector4(0.0, 1.0, 0.0, 0.0);
    Vector4.UnitZ = new Vector4(0.0, 0.0, 1.0, 0.0);
    Vector4.UnitW = new Vector4(0.0, 0.0, 0.0, 1.0);
    Vector4.tempVec4 = new Vector4(0.0, 0.0, 0.0, 0.0);

    class Vector3 {
        static distanceSquared(value1, value2) {
            var x = value1.x - value2.x;
            var y = value1.y - value2.y;
            var z = value1.z - value2.z;
            return (x * x) + (y * y) + (z * z);
        }
        static distance(value1, value2) {
            var x = value1.x - value2.x;
            var y = value1.y - value2.y;
            var z = value1.z - value2.z;
            return Math.sqrt((x * x) + (y * y) + (z * z));
        }
        static min(a, b, out) {
            out.x = Math.min(a.x, b.x);
            out.y = Math.min(a.y, b.y);
            out.z = Math.min(a.z, b.z);
        }
        static max(a, b, out) {
            out.x = Math.max(a.x, b.x);
            out.y = Math.max(a.y, b.y);
            out.z = Math.max(a.z, b.z);
        }
        static transformQuat(source, rotation, out) {
            var x = source.x, y = source.y, z = source.z, qx = rotation.x, qy = rotation.y, qz = rotation.z, qw = rotation.w, ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
            out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        }
        static scalarLength(a) {
            var x = a.x, y = a.y, z = a.z;
            return Math.sqrt(x * x + y * y + z * z);
        }
        static scalarLengthSquared(a) {
            var x = a.x, y = a.y, z = a.z;
            return x * x + y * y + z * z;
        }
        static normalize(s, out) {
            var x = s.x, y = s.y, z = s.z;
            var len = x * x + y * y + z * z;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out.x = x * len;
                out.y = y * len;
                out.z = z * len;
            }
        }
        static multiply(a, b, out) {
            out.x = a.x * b.x;
            out.y = a.y * b.y;
            out.z = a.z * b.z;
        }
        static scale(a, b, out) {
            out.x = a.x * b;
            out.y = a.y * b;
            out.z = a.z * b;
        }
        static lerp(a, b, t, out) {
            var ax = a.x, ay = a.y, az = a.z;
            out.x = ax + t * (b.x - ax);
            out.y = ay + t * (b.y - ay);
            out.z = az + t * (b.z - az);
        }
        static transformV3ToV3(vector, transform, result) {
            Vector3.transformV3ToV4(vector, transform, _tempVector4);
            result.x = _tempVector4.x;
            result.y = _tempVector4.y;
            result.z = _tempVector4.z;
        }
        static transformV3ToV4(vector, transform, result) {
            var vectorX = vector.x;
            var vectorY = vector.y;
            var vectorZ = vector.z;
            var transformElem = transform.elements;
            result.x = (vectorX * transformElem[0]) + (vectorY * transformElem[4]) + (vectorZ * transformElem[8]) + transformElem[12];
            result.y = (vectorX * transformElem[1]) + (vectorY * transformElem[5]) + (vectorZ * transformElem[9]) + transformElem[13];
            result.z = (vectorX * transformElem[2]) + (vectorY * transformElem[6]) + (vectorZ * transformElem[10]) + transformElem[14];
            result.w = (vectorX * transformElem[3]) + (vectorY * transformElem[7]) + (vectorZ * transformElem[11]) + transformElem[15];
        }
        static TransformNormal(normal, transform, result) {
            var normalX = normal.x;
            var normalY = normal.y;
            var normalZ = normal.z;
            var transformElem = transform.elements;
            result.x = (normalX * transformElem[0]) + (normalY * transformElem[4]) + (normalZ * transformElem[8]);
            result.y = (normalX * transformElem[1]) + (normalY * transformElem[5]) + (normalZ * transformElem[9]);
            result.z = (normalX * transformElem[2]) + (normalY * transformElem[6]) + (normalZ * transformElem[10]);
        }
        static transformCoordinate(coordinate, transform, result) {
            var coordinateX = coordinate.x;
            var coordinateY = coordinate.y;
            var coordinateZ = coordinate.z;
            var transformElem = transform.elements;
            var w = coordinateX * transformElem[3] + coordinateY * transformElem[7] + coordinateZ * transformElem[11] + transformElem[15];
            result.x = (coordinateX * transformElem[0] + coordinateY * transformElem[4] + coordinateZ * transformElem[8] + transformElem[12]) / w;
            result.y = (coordinateX * transformElem[1] + coordinateY * transformElem[5] + coordinateZ * transformElem[9] + transformElem[13]) / w;
            result.z = (coordinateX * transformElem[2] + coordinateY * transformElem[6] + coordinateZ * transformElem[10] + transformElem[14]) / w;
        }
        static Clamp(value, min, max, out) {
            var x = value.x;
            var y = value.y;
            var z = value.z;
            var mineX = min.x;
            var mineY = min.y;
            var mineZ = min.z;
            var maxeX = max.x;
            var maxeY = max.y;
            var maxeZ = max.z;
            x = (x > maxeX) ? maxeX : x;
            x = (x < mineX) ? mineX : x;
            y = (y > maxeY) ? maxeY : y;
            y = (y < mineY) ? mineY : y;
            z = (z > maxeZ) ? maxeZ : z;
            z = (z < mineZ) ? mineZ : z;
            out.x = x;
            out.y = y;
            out.z = z;
        }
        static add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
            out.z = a.z + b.z;
        }
        static subtract(a, b, o) {
            o.x = a.x - b.x;
            o.y = a.y - b.y;
            o.z = a.z - b.z;
        }
        static cross(a, b, o) {
            var ax = a.x, ay = a.y, az = a.z, bx = b.x, by = b.y, bz = b.z;
            o.x = ay * bz - az * by;
            o.y = az * bx - ax * bz;
            o.z = ax * by - ay * bx;
        }
        static dot(a, b) {
            return (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
        }
        static equals(a, b) {
            return MathUtils3D.nearEqual(a.x, b.x) && MathUtils3D.nearEqual(a.y, b.y) && MathUtils3D.nearEqual(a.z, b.z);
        }
        constructor(x = 0, y = 0, z = 0) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
        equal(value) {
            return Vector3.equals(this, value);
        }
        setValue(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        }
        set(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        }
        fromArray(arr, offset = 0) {
            this.x = arr[offset + 0];
            this.y = arr[offset + 1];
            this.z = arr[offset + 2];
        }
        toArray() {
            return [this.x, this.y, this.z];
        }
        writeTo(arr, offset = 0) {
            arr[offset + 0] = this.x;
            arr[offset + 1] = this.y;
            arr[offset + 2] = this.z;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        lengthSquared() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        vsub(b, out) {
            out.x = this.x - b.x;
            out.y = this.y - b.y;
            out.z = this.z - b.z;
            return out;
        }
        vadd(b, out) {
            out.x = this.x + b.x;
            out.y = this.y + b.y;
            out.z = this.z + b.z;
            return out;
        }
        scale(s, out) {
            out.x = this.x * s;
            out.y = this.y * s;
            out.z = this.z * s;
            return out;
        }
        normalize() {
            let x = this.x, y = this.y, z = this.z;
            var len = x * x + y * y + z * z;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                this.x = x * len;
                this.y = y * len;
                this.z = z * len;
            }
            return this;
        }
        dot(b) {
            return (this.x * b.x) + (this.y * b.y) + (this.z * b.z);
        }
        cross(b, o) {
            var ax = this.x, ay = this.y, az = this.z, bx = b.x, by = b.y, bz = b.z;
            o.x = ay * bz - az * by;
            o.y = az * bx - ax * bz;
            o.z = ax * by - ay * bx;
            return o;
        }
        cloneTo(destObject) {
            destObject.x = this.x;
            destObject.y = this.y;
            destObject.z = this.z;
        }
        clone() {
            var destVector3 = new Vector3();
            this.cloneTo(destVector3);
            return destVector3;
        }
        toDefault() {
            this.x = 0;
            this.y = 0;
            this.z = 0;
        }
    }
    Vector3._tempVector3 = new Vector3();
    Vector3.ZERO = new Vector3(0.0, 0.0, 0.0);
    Vector3.ONE = new Vector3(1.0, 1.0, 1.0);
    Vector3.NegativeUnitX = new Vector3(-1, 0, 0);
    Vector3.UnitX = new Vector3(1, 0, 0);
    Vector3.UnitY = new Vector3(0, 1, 0);
    Vector3.UnitZ = new Vector3(0, 0, 1);
    Vector3.ForwardRH = new Vector3(0, 0, -1);
    Vector3.ForwardLH = new Vector3(0, 0, 1);
    Vector3.Up = new Vector3(0, 1, 0);
    const _tempVector4 = new Vector4();

    class Config3D {
        static setResolution(width, height) {
            Config3D.customResolution = true;
            Config3D._resoluWidth = width;
            Config3D._resoluHeight = height;
        }
    }
    Config3D.enableDynamicBatch = true;
    Config3D.enableStaticBatch = true;
    Config3D.enableUniformBufferObject = true;
    Config3D.pixelRatio = 1;
    Config3D.customResolution = false;
    Config3D.defaultCacheRTMemory = 256;
    Config3D.defaultPhysicsMemory = 16;
    Config3D.enableMultiLight = true;
    Config3D.maxLightCount = 32;
    Config3D.lightClusterCount = new Vector3(12, 12, 12);
    Config3D.maxMorphTargetCount = 32;
    Config3D.useBVHCull = false;
    Config3D.BVH_max_SpatialCount = 7;
    Config3D.BVH_limit_size = 32;
    Config3D.BVH_Min_Build_nums = 10;
    Config3D._resoluWidth = -1;
    Config3D._resoluHeight = -1;
    Config3D.debugFrustumCulling = false;

    exports.TextureDimension = void 0;
    (function (TextureDimension) {
        TextureDimension[TextureDimension["Tex2D"] = 0] = "Tex2D";
        TextureDimension[TextureDimension["Cube"] = 1] = "Cube";
        TextureDimension[TextureDimension["Tex3D"] = 2] = "Tex3D";
        TextureDimension[TextureDimension["Texture2DArray"] = 3] = "Texture2DArray";
        TextureDimension[TextureDimension["CubeArray"] = 4] = "CubeArray";
        TextureDimension[TextureDimension["Unkonw"] = 5] = "Unkonw";
        TextureDimension[TextureDimension["None"] = 6] = "None";
    })(exports.TextureDimension || (exports.TextureDimension = {}));

    class Config {
    }
    Config.isAntialias = true;
    Config.useWebGL2 = true;
    Config.FPS = 60;
    Config.useRetinalCanvas = false;
    Config.animationInterval = 50;
    Config.webGL2D_MeshAllocMaxMem = true;
    Config.defaultFontSize = 12;
    Config.defaultFont = "Arial";
    Config.isAlpha = false;
    Config.isDepth = false;
    Config.isfailIfMajorPerformanceCaveat = false;
    Config.powerPreference = "default";
    Config.premultipliedAlpha = true;
    Config.isStencil = true;
    Config.preserveDrawingBuffer = false;
    Config.printWebglOrder = false;
    Config.fontFamilyMap = { "报隶": "报隶-简", "黑体": "黑体-简", "楷体": "楷体-简", "兰亭黑": "兰亭黑-简", "隶变": "隶变-简", "凌慧体": "凌慧体-简", "翩翩体": "翩翩体-简", "苹方": "苹方-简", "手札体": "手札体-简", "宋体": "宋体-简", "娃娃体": "娃娃体-简", "魏碑": "魏碑-简", "行楷": "行楷-简", "雅痞": "雅痞-简", "圆体": "圆体-简" };
    Config.fixedFrames = true;
    Config.destroyResourceImmediatelyDefault = true;
    Config._enableWindowRAFFunction = true;
    const PlayerConfig = {};

    exports.HDREncodeFormat = void 0;
    (function (HDREncodeFormat) {
        HDREncodeFormat[HDREncodeFormat["NONE"] = 0] = "NONE";
        HDREncodeFormat[HDREncodeFormat["RGBM"] = 1] = "RGBM";
        HDREncodeFormat[HDREncodeFormat["RGBD"] = 2] = "RGBD";
    })(exports.HDREncodeFormat || (exports.HDREncodeFormat = {}));

    exports.TextureFormat = void 0;
    (function (TextureFormat) {
        TextureFormat[TextureFormat["R8G8B8"] = 0] = "R8G8B8";
        TextureFormat[TextureFormat["R8G8B8A8"] = 1] = "R8G8B8A8";
        TextureFormat[TextureFormat["R5G6B5"] = 16] = "R5G6B5";
        TextureFormat[TextureFormat["Alpha8"] = 2] = "Alpha8";
        TextureFormat[TextureFormat["DXT1"] = 3] = "DXT1";
        TextureFormat[TextureFormat["DXT3"] = 29] = "DXT3";
        TextureFormat[TextureFormat["DXT5"] = 4] = "DXT5";
        TextureFormat[TextureFormat["ETC1RGB"] = 5] = "ETC1RGB";
        TextureFormat[TextureFormat["ETC2RGB"] = 6] = "ETC2RGB";
        TextureFormat[TextureFormat["ETC2RGBA"] = 7] = "ETC2RGBA";
        TextureFormat[TextureFormat["ETC2SRGB_Alpha8"] = 8] = "ETC2SRGB_Alpha8";
        TextureFormat[TextureFormat["ETC2SRGB"] = 28] = "ETC2SRGB";
        TextureFormat[TextureFormat["ETC2RGB_Alpha1"] = 32] = "ETC2RGB_Alpha1";
        TextureFormat[TextureFormat["ETC2SRGB_Alpha1"] = 33] = "ETC2SRGB_Alpha1";
        TextureFormat[TextureFormat["PVRTCRGB_2BPPV"] = 9] = "PVRTCRGB_2BPPV";
        TextureFormat[TextureFormat["PVRTCRGBA_2BPPV"] = 10] = "PVRTCRGBA_2BPPV";
        TextureFormat[TextureFormat["PVRTCRGB_4BPPV"] = 11] = "PVRTCRGB_4BPPV";
        TextureFormat[TextureFormat["PVRTCRGBA_4BPPV"] = 12] = "PVRTCRGBA_4BPPV";
        TextureFormat[TextureFormat["R32G32B32A32"] = 15] = "R32G32B32A32";
        TextureFormat[TextureFormat["R32G32B32"] = 30] = "R32G32B32";
        TextureFormat[TextureFormat["R16G16B16A16"] = 17] = "R16G16B16A16";
        TextureFormat[TextureFormat["R16G16B16"] = 31] = "R16G16B16";
        TextureFormat[TextureFormat["ASTC4x4"] = 18] = "ASTC4x4";
        TextureFormat[TextureFormat["ASTC4x4SRGB"] = 23] = "ASTC4x4SRGB";
        TextureFormat[TextureFormat["ASTC6x6"] = 19] = "ASTC6x6";
        TextureFormat[TextureFormat["ASTC6x6SRGB"] = 24] = "ASTC6x6SRGB";
        TextureFormat[TextureFormat["ASTC8x8"] = 20] = "ASTC8x8";
        TextureFormat[TextureFormat["ASTC8x8SRGB"] = 25] = "ASTC8x8SRGB";
        TextureFormat[TextureFormat["ASTC10x10"] = 21] = "ASTC10x10";
        TextureFormat[TextureFormat["ASTC10x10SRGB"] = 26] = "ASTC10x10SRGB";
        TextureFormat[TextureFormat["ASTC12x12"] = 22] = "ASTC12x12";
        TextureFormat[TextureFormat["ASTC12x12SRGB"] = 27] = "ASTC12x12SRGB";
        TextureFormat[TextureFormat["KTXTEXTURE"] = -1] = "KTXTEXTURE";
        TextureFormat[TextureFormat["PVRTEXTURE"] = -2] = "PVRTEXTURE";
    })(exports.TextureFormat || (exports.TextureFormat = {}));

    const ITEM_LAYOUT = 4;
    class Delegate {
        constructor() {
            this._flag = 0;
            this._items = [];
        }
        add(callback, target, args) {
            target = target || null;
            let arr = this._items;
            let index = arr.findIndex((value, index, arr) => value === callback && arr[index + 1] === target);
            if (index != -1) {
                arr[index + 2] = args;
                arr[index + 3] = 1;
            }
            else
                arr.push(callback, target, args, 1);
        }
        once(callback, target, args) {
            target = target || null;
            let arr = this._items;
            let index = arr.findIndex((value, index, arr) => value === callback && arr[index + 1] === target);
            if (index != -1) {
                arr[index + 2] = args;
                arr[index + 3] = 2;
            }
            else
                arr.push(callback, target, args, 2);
        }
        remove(callback, target) {
            target = target || null;
            let arr = this._items;
            let index = arr.findIndex((value, index, arr) => value === callback && arr[index + 1] === target);
            if (index != -1) {
                if (this._flag != 0) {
                    arr[index + 3] = 0;
                    this._flag = 2;
                }
                else
                    arr.splice(index, ITEM_LAYOUT);
            }
        }
        clear() {
            let arr = this._items;
            if (this._flag != 0) {
                arr.forEach((value, index, arr) => { if (index % ITEM_LAYOUT === 3)
                    arr[index] = 0; });
                this._flag = 2;
            }
            else {
                arr.length = 0;
            }
        }
        clearForTarget(target) {
            if (!target)
                return;
            let arr = this._items;
            if (this._flag != 0) {
                arr.forEach((value, index, arr) => { if ((index % ITEM_LAYOUT === 1) && arr[index] === target)
                    arr[index + 2] = 0; });
                this._flag = 2;
            }
            else {
                let i = arr.length - ITEM_LAYOUT;
                while (i >= 0) {
                    if (arr[i + 1] === target)
                        arr.splice(i, ITEM_LAYOUT);
                    i -= ITEM_LAYOUT;
                }
            }
        }
        get count() {
            return this._items.length / ITEM_LAYOUT;
        }
        invoke(...args) {
            if (this._flag != 0)
                return;
            this._flag = 1;
            let arr = this._items;
            let cnt = arr.length;
            for (let i = 0; i < cnt; i += ITEM_LAYOUT) {
                if (arr[i + 3] === 0)
                    continue;
                let fixedArgs = arr[i + 2];
                try {
                    if (fixedArgs != null)
                        arr[i].call(arr[i + 1], ...fixedArgs, ...args);
                    else
                        arr[i].call(arr[i + 1], ...args);
                }
                catch (err) {
                    console.error(err);
                }
                if (arr[i + 3] === 2) {
                    arr[i + 3] = 0;
                    this._flag = 2;
                }
            }
            if (this._flag === 2) {
                let cnt = arr.length;
                let i = 0;
                while (i < cnt) {
                    if (arr[i + 3] === 0) {
                        arr.splice(i, ITEM_LAYOUT);
                        cnt -= ITEM_LAYOUT;
                        continue;
                    }
                    else
                        i += ITEM_LAYOUT;
                }
            }
            this._flag = 0;
        }
    }

    const eventPool = [];
    class EventDispatcher {
        onStartListeningToType(type) {
        }
        hasListener(type) {
            let listeners = this._events && this._events[type];
            return !!listeners && listeners.count > 0;
        }
        event(type, data) {
            let listeners = this._events && this._events[type];
            if (!listeners)
                return false;
            let ret = listeners.count > 0;
            if (Array.isArray(data))
                listeners.invoke(...data);
            else if (data !== undefined)
                listeners.invoke(data);
            else if (data === Event.EMPTY) {
                let ev = eventPool.length > 0 ? eventPool.pop() : new Event();
                listeners.invoke(ev.setTo(type, this, this));
                ev.target = ev.currentTarget = null;
                eventPool.push(ev);
            }
            else
                listeners.invoke();
            return ret;
        }
        on(type, caller, listener, args) {
            if (arguments.length == 2) {
                listener = caller;
                caller = null;
            }
            if (!this._events)
                this._events = {};
            let listeners = this._events[type];
            if (!listeners) {
                this.onStartListeningToType(type);
                this._events[type] = listeners = new Delegate();
            }
            listeners.add(listener, caller, args);
            return this;
        }
        once(type, caller, listener, args) {
            if (arguments.length == 2) {
                listener = caller;
                caller = null;
            }
            if (!this._events)
                this._events = {};
            let listeners = this._events[type];
            if (!listeners) {
                this.onStartListeningToType(type);
                this._events[type] = listeners = new Delegate();
            }
            listeners.once(listener, caller, args);
            return this;
        }
        off(type, caller, listener) {
            if (arguments.length == 2) {
                listener = caller;
                caller = null;
            }
            let listeners = this._events && this._events[type];
            if (listeners)
                listeners.remove(listener, caller);
            return this;
        }
        offAll(type) {
            if (type == null)
                this._events = null;
            else {
                let listeners = this._events && this._events[type];
                if (listeners)
                    listeners.clear();
            }
            return this;
        }
        offAllCaller(caller) {
            if (caller && this._events) {
                for (let type in this._events)
                    this._events[type].clearForTarget(caller);
            }
            return this;
        }
    }

    var _idCounter = 0;
    var _disposingCounter = 0;
    var _clearRetry = 0;
    class Resource extends EventDispatcher {
        static get cpuMemory() {
            return Resource._cpuMemory;
        }
        static get gpuMemory() {
            return Resource._gpuMemory;
        }
        static _addCPUMemory(size) {
            Resource._cpuMemory += size;
        }
        static _addGPUMemory(size) {
            Resource._gpuMemory += size;
        }
        static _addMemory(cpuSize, gpuSize) {
            Resource._cpuMemory += cpuSize;
            Resource._gpuMemory += gpuSize;
        }
        static destroyUnusedResources() {
            _disposingCounter = 0;
            _clearRetry = 0;
            if (!ILaya.loader.loading)
                Resource._destroyUnusedResources(true);
            else
                ILaya.timer.frameLoop(1, Resource, Resource._destroyUnusedResources);
        }
        static _destroyUnusedResources(force) {
            if (!force && ILaya.loader.loading)
                return;
            ILaya.timer.clear(Resource, Resource._destroyUnusedResources);
            let destroyCnt = 0;
            for (let k in Resource._idResourcesMap) {
                let res = Resource._idResourcesMap[k];
                if (!res.lock && res._referenceCount === 0) {
                    res.destroy();
                    destroyCnt++;
                }
            }
            if (Resource.DEBUG && destroyCnt > 0)
                console.debug(`destroyUnusedResources(${destroyCnt})`);
            if (destroyCnt > 0 && _clearRetry < 5) {
                _clearRetry++;
                ILaya.timer.frameLoop(1, Resource, Resource._destroyUnusedResources);
            }
        }
        get id() {
            return this._id;
        }
        get cpuMemory() {
            return this._cpuMemory;
        }
        get gpuMemory() {
            return this._gpuMemory;
        }
        get destroyed() {
            return this._destroyed;
        }
        get obsolute() {
            return this._obsolute;
        }
        set obsolute(value) {
            if (this._obsolute != value) {
                this._obsolute = value;
                if (value && !LayaEnv.isPlaying)
                    this.event("obsolute");
            }
        }
        get deps() {
            return this._deps;
        }
        get referenceCount() {
            return this._referenceCount;
        }
        constructor(managed) {
            super();
            this._cpuMemory = 0;
            this._gpuMemory = 0;
            this._id = 0;
            this._referenceCount = 0;
            this._id = ++_idCounter;
            this._destroyed = false;
            this._referenceCount = 0;
            if (managed == null || managed)
                Resource._idResourcesMap[this._id] = this;
            this.lock = false;
            this.destroyedImmediately = true;
            this._deps = [];
            this._traceDeps = false;
        }
        _setCPUMemory(value) {
            var offsetValue = value - this._cpuMemory;
            this._cpuMemory = value;
            Resource._addCPUMemory(offsetValue);
        }
        _setGPUMemory(value) {
            var offsetValue = value - this._gpuMemory;
            this._gpuMemory = value;
            Resource._addGPUMemory(offsetValue);
        }
        _setCreateURL(url, uuid) {
            this.url = url;
            this.uuid = uuid;
        }
        isCreateFromURL(url) {
            return this.uuid && url.length === this.uuid.length + 6 && url.endsWith(this.uuid)
                || this.url === url;
        }
        _addReference(count = 1) {
            this._referenceCount += count;
        }
        _removeReference(count = 1) {
            this._referenceCount -= count;
            if (_disposingCounter > 0 && this._referenceCount <= 0 && !this.lock && this.destroyedImmediately) {
                this.destroy();
            }
        }
        _clearReference() {
            this._referenceCount = 0;
        }
        addDep(res) {
            if (res instanceof Resource) {
                res._addReference();
                this._deps.push(res);
                if (!LayaEnv.isPlaying && res._traceDeps)
                    res.on("obsolute", this, this.onDepObsolute);
            }
        }
        addDeps(resArr) {
            for (let res of resArr) {
                if (res instanceof Resource) {
                    res._addReference();
                    this._deps.push(res);
                    if (!LayaEnv.isPlaying && res._traceDeps)
                        res.on("obsolute", this, this.onDepObsolute);
                }
            }
        }
        onDepObsolute() {
            this.obsolute = true;
        }
        _disposeResource() {
        }
        destroy() {
            if (this._destroyed)
                return;
            this._destroyed = true;
            this.lock = false;
            _disposingCounter++;
            this._disposeResource();
            for (let res of this._deps) {
                res._removeReference();
                if (!LayaEnv.isPlaying && res._traceDeps)
                    res.off("obsolute", this, this.onDepObsolute);
            }
            _disposingCounter--;
            this.offAll();
            delete Resource._idResourcesMap[this.id];
            if (this.url) {
                if (Resource.DEBUG)
                    console.debug(`destroy ${Object.getPrototypeOf(this).constructor.name} ${this.url}`);
                ILaya.loader.clearRes(this.url, this);
            }
        }
    }
    Resource._idResourcesMap = {};
    Resource._cpuMemory = 0;
    Resource._gpuMemory = 0;
    Resource.DEBUG = false;

    class BaseTexture extends Resource {
        get width() {
            return this._width;
        }
        set width(width) {
            this._width = width;
        }
        get height() {
            return this._height;
        }
        set height(height) {
            this._height = height;
        }
        get dimension() {
            return this._dimension;
        }
        get format() {
            return this._format;
        }
        get mipmap() {
            return this._texture.mipmap;
        }
        get mipmapCount() {
            return this._texture.mipmapCount;
        }
        get anisoLevel() {
            return this._texture.anisoLevel;
        }
        set anisoLevel(value) {
            this._texture.anisoLevel = value;
        }
        get filterMode() {
            return this._texture.filterMode;
        }
        set filterMode(value) {
            this._texture.filterMode = value;
        }
        get wrapModeU() {
            return this._texture.wrapU;
        }
        set wrapModeU(value) {
            this._texture.wrapU = value;
        }
        get wrapModeV() {
            return this._texture.wrapV;
        }
        set wrapModeV(value) {
            this._texture.wrapV = value;
        }
        get wrapModeW() {
            return this._texture.wrapW;
        }
        set wrapModeW(value) {
            this._texture.wrapW = value;
        }
        get compareMode() {
            return this._texture.compareMode;
        }
        set compareMode(value) {
            this._texture.compareMode = LayaGL.textureContext.setTextureCompareMode(this._texture, value);
        }
        get gammaCorrection() {
            return this._texture.gammaCorrection;
        }
        get baseMipmapLevel() {
            return this._texture.baseMipmapLevel;
        }
        set baseMipmapLevel(value) {
            this._texture.baseMipmapLevel = value;
        }
        get maxMipmapLevel() {
            return this._texture.maxMipmapLevel;
        }
        set maxMipmapLevel(value) {
            this._texture.maxMipmapLevel = value;
        }
        get gammaSpace() {
            return this._texture.useSRGBLoad || this._texture.gammaCorrection > 1;
        }
        constructor(width, height, format) {
            super();
            this._gammaSpace = false;
            this._width = width;
            this._height = height;
            this._format = format;
            this.destroyedImmediately = Config.destroyResourceImmediatelyDefault;
            this.hdrEncodeFormat = exports.HDREncodeFormat.NONE;
        }
        gpuCompressFormat() {
            let format = this._format;
            switch (format) {
                case exports.TextureFormat.R8G8B8:
                case exports.TextureFormat.R8G8B8A8:
                case exports.TextureFormat.R16G16B16:
                case exports.TextureFormat.R16G16B16A16:
                case exports.TextureFormat.R32G32B32:
                case exports.TextureFormat.R32G32B32A32:
                case exports.TextureFormat.R5G6B5:
                case exports.TextureFormat.Alpha8:
                    return false;
                case exports.TextureFormat.DXT1:
                case exports.TextureFormat.DXT3:
                case exports.TextureFormat.DXT5:
                case exports.TextureFormat.ETC1RGB:
                case exports.TextureFormat.ETC2RGB:
                case exports.TextureFormat.ETC2RGBA:
                case exports.TextureFormat.ETC2SRGB_Alpha8:
                case exports.TextureFormat.ETC2SRGB:
                case exports.TextureFormat.ETC2RGB_Alpha1:
                case exports.TextureFormat.ETC2SRGB_Alpha1:
                case exports.TextureFormat.PVRTCRGB_2BPPV:
                case exports.TextureFormat.PVRTCRGBA_2BPPV:
                case exports.TextureFormat.PVRTCRGB_4BPPV:
                case exports.TextureFormat.PVRTCRGBA_4BPPV:
                case exports.TextureFormat.ASTC4x4:
                case exports.TextureFormat.ASTC4x4SRGB:
                case exports.TextureFormat.ASTC6x6:
                case exports.TextureFormat.ASTC6x6SRGB:
                case exports.TextureFormat.ASTC8x8:
                case exports.TextureFormat.ASTC8x8SRGB:
                case exports.TextureFormat.ASTC10x10:
                case exports.TextureFormat.ASTC10x10SRGB:
                case exports.TextureFormat.ASTC12x12:
                case exports.TextureFormat.ASTC12x12SRGB:
                    return true;
                default:
                    return false;
            }
        }
        _getFormatByteCount() {
            switch (this._format) {
                case exports.TextureFormat.R8G8B8:
                    return 3;
                case exports.TextureFormat.R8G8B8A8:
                    return 4;
                case exports.TextureFormat.R5G6B5:
                    return 1;
                case exports.TextureFormat.Alpha8:
                    return 1;
                case exports.TextureFormat.R16G16B16A16:
                    return 2;
                case exports.TextureFormat.R32G32B32A32:
                    return 4;
                default:
                    throw "Texture2D: unknown format.";
            }
        }
        _getSource() {
            return this._texture.resource;
        }
        get defaultTexture() {
            throw "defaulte";
        }
        _disposeResource() {
            this._texture.dispose();
        }
    }

    exports.DepthTextureMode = void 0;
    (function (DepthTextureMode) {
        DepthTextureMode[DepthTextureMode["None"] = 0] = "None";
        DepthTextureMode[DepthTextureMode["Depth"] = 1] = "Depth";
        DepthTextureMode[DepthTextureMode["DepthNormals"] = 2] = "DepthNormals";
        DepthTextureMode[DepthTextureMode["DepthAndDepthNormals"] = 3] = "DepthAndDepthNormals";
        DepthTextureMode[DepthTextureMode["MotionVectors"] = 4] = "MotionVectors";
    })(exports.DepthTextureMode || (exports.DepthTextureMode = {}));
    class RenderTexture extends BaseTexture {
        static createFromPool(width, height, colorFormat, depthFormat, mipmap = false, multiSamples = 1, depthTexture = false, sRGB = false) {
            mipmap = mipmap && (width & (width - 1)) === 0 && (height & (height - 1)) === 0;
            let n = RenderTexture._pool.length;
            for (let index = 0; index < n; index++) {
                let rt = RenderTexture._pool[index];
                if (rt.width == width && rt.height == height && rt.colorFormat == colorFormat && rt.depthStencilFormat == depthFormat && rt._generateMipmap == mipmap && rt.multiSamples == multiSamples && rt.generateDepthTexture == depthTexture && rt._gammaSpace == sRGB) {
                    rt._inPool = false;
                    let end = RenderTexture._pool[n - 1];
                    RenderTexture._pool[index] = end;
                    RenderTexture._pool.length -= 1;
                    RenderTexture._poolMemory -= (rt._renderTarget.gpuMemory / 1024 / 1024);
                    return rt;
                }
            }
            let rt = new RenderTexture(width, height, colorFormat, depthFormat, mipmap, multiSamples, depthTexture, sRGB);
            rt.lock = true;
            return rt;
        }
        static recoverToPool(rt) {
            if (rt._inPool || rt.destroyed)
                return;
            RenderTexture._pool.push(rt);
            RenderTexture._poolMemory += (rt._renderTarget.gpuMemory / 1024 / 1024);
            rt._inPool = true;
        }
        static clearPool() {
            if (RenderTexture._poolMemory < Config3D.defaultCacheRTMemory) {
                return;
            }
            for (var i in RenderTexture._pool) {
                RenderTexture._pool[i].destroy();
            }
            RenderTexture._pool = [];
            RenderTexture._poolMemory = 0;
        }
        static get bindCanvasRender() {
            return RenderTexture._bindCanvasRender;
        }
        static set bindCanvasRender(value) {
            if (value != this._bindCanvasRender)
                this._bindCanvasRender = value;
        }
        get generateDepthTexture() {
            return this._generateDepthTexture;
        }
        set generateDepthTexture(value) {
            if (this.depthStencilFormat == exports.RenderTargetFormat.None) {
                this._generateDepthTexture = false;
                return;
            }
            if (value && !this._depthStencilTexture) {
                this._depthStencilTexture = new BaseTexture(this.width, this.height, this.depthStencilFormat);
                this._depthStencilTexture._dimension = exports.TextureDimension.Tex2D;
                this._depthStencilTexture._texture = LayaGL.textureContext.createRenderTargetDepthTexture(this._renderTarget, exports.TextureDimension.Tex2D, this.width, this.height);
            }
            this._generateDepthTexture = value;
        }
        get depthStencilTexture() {
            return this._depthStencilTexture;
        }
        get colorFormat() {
            return this._renderTarget.colorFormat;
        }
        get depthStencilFormat() {
            return this._renderTarget.depthStencilFormat;
        }
        get multiSamples() {
            return this._renderTarget._samples;
        }
        get isCube() {
            return this._renderTarget._isCube;
        }
        get samples() {
            return this._renderTarget._samples;
        }
        get generateMipmap() {
            return this._renderTarget._generateMipmap;
        }
        constructor(width, height, colorFormat, depthFormat, generateMipmap = false, multiSamples = 1, generateDepthTexture = false, sRGB = false) {
            super(width, height, colorFormat);
            this._inPool = false;
            this._isCameraTarget = false;
            this._generateDepthTexture = false;
            this._gammaSpace = sRGB;
            this._depthStencilFormat = (depthFormat == null ? exports.RenderTargetFormat.None : depthFormat);
            this._generateMipmap = generateMipmap;
            this._multiSamples = multiSamples;
            this._generateDepthTexture = generateDepthTexture;
            this._createRenderTarget();
        }
        _createRenderTarget() {
            this._dimension = exports.TextureDimension.Tex2D;
            this._renderTarget = LayaGL.textureContext.createRenderTargetInternal(this.width, this.height, this._format, this._depthStencilFormat, this._generateMipmap, this._gammaSpace, this._multiSamples);
            this._generateMipmap = this._renderTarget._generateMipmap;
            if (this._renderTarget._texturesResolve)
                this._texture = this._renderTarget._texturesResolve[0];
            else
                this._texture = this._renderTarget._textures[0];
            this.generateDepthTexture = this._generateDepthTexture;
        }
        recreate(width, height, colorFormat, depthFormat, generateMipmap = false, multiSamples = 1, generateDepthTexture = false, sRGB = false) {
            this._width = width;
            this._height = height;
            this._format = colorFormat;
            this._gammaSpace = sRGB;
            this._depthStencilFormat = (depthFormat == null ? exports.RenderTargetFormat.None : depthFormat);
            this._generateMipmap = generateMipmap;
            this._multiSamples = multiSamples;
            this._generateDepthTexture = generateDepthTexture;
            this._disposeResource();
            this._createRenderTarget();
        }
        getData(xOffset, yOffset, width, height, out) {
            LayaGL.textureContext.readRenderTargetPixelData(this._renderTarget, xOffset, yOffset, width, height, out);
            return out;
        }
        getDataAsync(xOffset, yOffset, width, height, out) {
            return LayaGL.textureContext.readRenderTargetPixelDataAsync(this._renderTarget, xOffset, yOffset, width, height, out);
        }
        _disposeResource() {
            var _a;
            this._renderTarget.dispose();
            this._renderTarget = null;
            (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.destroy();
            this._depthStencilTexture = null;
        }
    }
    RenderTexture._pool = [];
    RenderTexture._poolMemory = 0;

    class Browser {
        static __init__() {
            var _a;
            let Laya = window.Laya || ILaya.Laya;
            if (Browser._window)
                return Browser._window;
            let win = Browser._window = window;
            let doc = Browser._document = win.document;
            let u = Browser.userAgent = win.navigator.userAgent;
            let maxTouchPoints = win.navigator.maxTouchPoints || 0;
            let platform = win.navigator.platform;
            let miniGame;
            if (!!window.conch && "conchUseWXAdapter" in Browser.window) {
                miniGame = ["wxMiniGame", "MiniAdpter", "wx"];
            }
            if ("my" in Browser.window) {
                if (u.indexOf('TB/') > -1 || u.indexOf('Taobao/') > -1 || u.indexOf('TM/') > -1) {
                    miniGame = ["tbMiniGame", "TBMiniAdapter", "my"];
                }
                else if (u.indexOf('AlipayMiniGame') > -1) {
                    miniGame = ["aliPayMiniGame", "ALIMiniAdapter", "my"];
                }
            }
            if (((u.indexOf('OPPO') == -1 && u.indexOf("MiniGame") > -1) || u.indexOf('runtime') != -1 || (u.indexOf('miniprogram') != -1 && window.isWXMiMi)) && "wx" in Browser.window) {
                if ("tt" in Browser.window) {
                    miniGame = ["ttMiniGame", "TTMiniAdapter", "tt"];
                }
                else if ("bl" in Browser.window) {
                    miniGame = ["biliMiniGame", "BLMiniAdapter", null];
                }
                else if ("qq" in Browser.window) {
                    miniGame = ["qqMiniGame", "QQMiniAdapter", null];
                }
                else {
                    miniGame = ["wxMiniGame", "MiniAdpter", "wx"];
                }
            }
            if ("hbs" in Browser.window) {
                miniGame = ["hwMiniGame", "HWMiniAdapter", null];
            }
            if (u.indexOf("SwanGame") > -1) {
                miniGame = ["bdMiniGame", "BMiniAdapter", null];
            }
            if (u.indexOf('QuickGame') > -1) {
                miniGame = ["miMiniGame", "KGMiniAdapter", "qg"];
            }
            if (u.indexOf('OPPO') > -1 && u.indexOf('MiniGame') > -1) {
                miniGame = ["qgMiniGame", "QGMiniAdapter", "qg"];
                Config.fixedFrames = false;
            }
            if (u.indexOf('VVGame') > -1) {
                miniGame = ["vvMiniGame", "VVMiniAdapter", "qg"];
                Config.fixedFrames = false;
            }
            if (miniGame != null) {
                Browser.window[miniGame[0]](Laya, Laya);
                Laya[miniGame[1]].enable();
                Browser.miniGameContext = Browser.window[miniGame[2]];
            }
            win.trace = console.log;
            win.requestAnimationFrame = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame || function (fun) {
                return win.setTimeout(fun, 1000 / 60);
            };
            var bodyStyle = doc.body.style;
            bodyStyle.margin = 0;
            bodyStyle.overflow = 'hidden';
            bodyStyle['-webkit-user-select'] = 'none';
            bodyStyle['-webkit-tap-highlight-color'] = 'rgba(200,200,200,0)';
            var metas = doc.getElementsByTagName('meta');
            let viewportContent = {
                "width": "device-width",
                "initial-scale": "1.0",
                "minimum-scale": "1.0",
                "maximum-scale": "1.0",
                "user-scalable": "no"
            };
            let viewport;
            for (const meta of metas) {
                if (meta.name == "viewport") {
                    viewport = meta;
                    break;
                }
            }
            if (!viewport) {
                viewport = doc.createElement('meta');
                viewport.name = 'viewport';
                (_a = doc.getElementsByTagName('head')[0]) === null || _a === void 0 ? void 0 : _a.appendChild(viewport);
            }
            else {
                let arr = (viewport.content || "").split(",");
                for (let ele of arr) {
                    let arr2 = ele.split("=");
                    if (!viewportContent[arr2[0].trim()])
                        viewportContent[arr2[0]] = arr2[1];
                }
            }
            viewport.content = Object.keys(viewportContent).map(k => k + "=" + viewportContent[k]);
            Browser.onMobile = u.indexOf("Mobile") > -1;
            Browser.onIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
            Browser.onIPhone = u.indexOf("iPhone") > -1;
            Browser.onMac = u.indexOf("Mac OS X") > -1;
            Browser.onIPad = u.indexOf("iPad") > -1 || (platform === 'MacIntel' && maxTouchPoints > 1);
            Browser.onAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1;
            Browser.onOpenHarmonyOS = u.indexOf('OpenHarmony') > -1;
            Browser.onWP = u.indexOf("Windows Phone") > -1;
            Browser.onQQBrowser = u.indexOf("QQBrowser") > -1;
            Browser.onMQQBrowser = u.indexOf("MQQBrowser") > -1 || (u.indexOf("Mobile") > -1 && u.indexOf("QQ") > -1);
            Browser.onIE = !!win.ActiveXObject || "ActiveXObject" in win;
            Browser.onWeiXin = u.indexOf('MicroMessenger') > -1;
            Browser.onSafari = u.indexOf("Safari") > -1 && u.indexOf("Chrome") === -1;
            Browser.onChrome = u.indexOf("Chrome") > -1;
            Browser.onPC = !Browser.onMobile;
            Browser.onFirefox = u.indexOf('Firefox') > -1;
            Browser.onEdge = u.indexOf('Edge') > -1 || u.indexOf('Edg') > -1;
            Browser.onMiniGame = u.indexOf('MiniGame') > -1;
            Browser.onBDMiniGame = u.indexOf('SwanGame') > -1;
            Browser.onLayaRuntime = !!window.conch;
            if (u.indexOf('OPPO') > -1 && u.indexOf('MiniGame') > -1) {
                Browser.onQGMiniGame = true;
                Browser.onMiniGame = false;
            }
            else if ("qq" in Browser.window && u.indexOf('MiniGame') > -1) {
                Browser.onQQMiniGame = true;
                Browser.onMiniGame = false;
            }
            else if ("bl" in Browser.window && u.indexOf('MiniGame') > -1) {
                Browser.onBLMiniGame = true;
                Browser.onMiniGame = false;
            }
            else if ("tt" in Browser.window && u.indexOf('MiniGame') > -1) {
                Browser.onTTMiniGame = true;
                Browser.onMiniGame = false;
            }
            Browser.onHWMiniGame = "hbs" in Browser.window;
            Browser.onVVMiniGame = u.indexOf('VVGame') > -1;
            Browser.onKGMiniGame = u.indexOf('QuickGame') > -1;
            if (u.indexOf('AlipayMiniGame') > -1) {
                Browser.onAlipayMiniGame = true;
                Browser.onMiniGame = false;
            }
            if (u.indexOf('TB/') > -1 || u.indexOf('Taobao/') > -1 || u.indexOf('TM/') > -1) {
                Browser.onTBMiniGame = true;
            }
            if (Browser.onAndroid || Browser.onIOS) {
                if (platform && (platform.indexOf("Win") != -1 || platform.indexOf("Mac") != -1))
                    Browser.platform = Browser.PLATFORM_PC;
                else if (Browser.onAndroid)
                    Browser.platform = Browser.PLATFORM_ANDROID;
                else
                    Browser.platform = Browser.PLATFORM_IOS;
            }
            else
                Browser.platform = Browser.PLATFORM_PC;
            return win;
        }
        static get _isMiniGame() {
            return Browser.onMiniGame || Browser.onBDMiniGame || Browser.onQGMiniGame || Browser.onKGMiniGame || Browser.onVVMiniGame || Browser.onAlipayMiniGame || Browser.onQQMiniGame || Browser.onBLMiniGame || Browser.onTTMiniGame || Browser.onHWMiniGame || Browser.onTBMiniGame || (Browser.window && Browser.window.isWXMiMi);
        }
        static createElement(type) {
            Browser.__init__();
            return Browser._document.createElement(type);
        }
        static getElementById(id) {
            Browser.__init__();
            return Browser._document.getElementById(id);
        }
        static removeElement(ele) {
            if (ele && ele.parentNode)
                ele.parentNode.removeChild(ele);
        }
        static now() {
            return Date.now();
        }
        static get clientWidth() {
            Browser.__init__();
            return Browser._clientWidth || Browser._window.innerWidth || Browser._document.body.clientWidth;
        }
        static set clientWidth(value) {
            Browser._clientWidth = value;
        }
        static get clientHeight() {
            Browser.__init__();
            return Browser._clientHeight || Browser._window.innerHeight || Browser._document.body.clientHeight || Browser._document.documentElement.clientHeight;
        }
        static set clientHeight(value) {
            Browser._clientHeight = value;
        }
        static get width() {
            Browser.__init__();
            return ((ILaya.stage && ILaya.stage.canvasRotation) ? Browser.clientHeight : Browser.clientWidth) * Browser.pixelRatio;
        }
        static get height() {
            Browser.__init__();
            return ((ILaya.stage && ILaya.stage.canvasRotation) ? Browser.clientWidth : Browser.clientHeight) * Browser.pixelRatio;
        }
        static get pixelRatio() {
            if (Browser._pixelRatio < 0) {
                Browser.__init__();
                if (Browser.userAgent.indexOf("Mozilla/6.0(Linux; Android 6.0; HUAWEI NXT-AL10 Build/HUAWEINXT-AL10)") > -1)
                    Browser._pixelRatio = 2;
                else {
                    Browser._pixelRatio = (Browser._window.devicePixelRatio || 1);
                    if (Browser._pixelRatio < 1)
                        Browser._pixelRatio = 1;
                }
            }
            return Browser._pixelRatio;
        }
        static get container() {
            if (!Browser._container) {
                Browser.__init__();
                Browser._container = Browser.createElement("div");
                Browser._container.id = "layaContainer";
                Browser._document.body.appendChild(Browser._container);
            }
            return Browser._container;
        }
        static set container(value) {
            Browser._container = value;
        }
        static get window() {
            return Browser._window || Browser.__init__();
        }
        static get document() {
            Browser.__init__();
            return Browser._document;
        }
        static getQueryString(name) {
            if (Browser.onMiniGame)
                return null;
            if (!window.location || !window.location.search)
                return null;
            var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
            var r = window.location.search.substring(1).match(reg);
            if (r != null)
                return unescape(r[2]);
            return null;
        }
        static getSafariToolbarOffset() {
            return (Browser.window.__innerHeight || Browser.document.body.clientHeight || Browser.document.documentElement.clientHeight) - Browser.window.innerHeight;
        }
        static loadLib(src) {
            return new Promise((resolve, reject) => {
                let script = Browser.document.createElement('script');
                script.onload = function () {
                    resolve();
                };
                script.onerror = function () {
                    reject(`load ${src} failed`);
                };
                script.src = src;
                Browser.document.body.appendChild(script);
            });
        }
    }
    Browser.PLATFORM_PC = 0;
    Browser.PLATFORM_ANDROID = 1;
    Browser.PLATFORM_IOS = 2;
    Browser.bundles = new Map();
    Browser._pixelRatio = -1;
    Browser.mainCanvas = null;
    Browser.hanzi = new RegExp("^[\u4E00-\u9FA5]$");
    Browser.fontMap = {};
    Browser.measureText = function (txt, font) {
        let isChinese = Browser.hanzi.test(txt);
        if (isChinese && Browser.fontMap[font]) {
            return Browser.fontMap[font];
        }
        let ctx = Browser.context;
        ctx.font = font;
        let r = ctx.measureText(txt);
        if (isChinese)
            Browser.fontMap[font] = r;
        return r;
    };
    let win = window;
    win.__getBundle_ = function (bundleId) {
        let bun = Browser.bundles.get(bundleId);
        if (!bun)
            Browser.bundles.set(bundleId, bun = {});
        return bun;
    };
    win.__setBundle_ = function (bundleId, bun, globalName) {
        let existing = Browser.bundles.get(bundleId);
        if (existing)
            copyProps(existing, bun, "default");
        Browser.bundles.set(bundleId, bun);
        if (globalName)
            win[globalName] = bun;
    };
    function copyProps(to, from, except) {
        var desc;
        if (from && typeof from === "object" || typeof from === "function") {
            for (let key of Object.getOwnPropertyNames(from))
                if (!to.hasOwnProperty(key) && key !== except)
                    Object.defineProperty(to, key, { get: () => from[key], enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable });
        }
        return to;
    }

    var _gid = 1;
    const _pi = 180 / Math.PI;
    const _pi2 = Math.PI / 180;
    class Utils {
        static toRadian(angle) {
            return angle * _pi2;
        }
        static toAngle(radian) {
            return radian * _pi;
        }
        static toHexColor(color) {
            if (color < 0 || isNaN(color))
                return null;
            var str = color.toString(16);
            while (str.length < 6)
                str = "0" + str;
            return "#" + str;
        }
        static fromStringColor(value) {
            if (!value)
                return 0;
            if (value.indexOf("rgba(") >= 0 || value.indexOf("rgb(") >= 0) {
                let p1 = value.indexOf("(");
                let p2 = value.indexOf(")");
                if (p1 == -1 || p2 == -1)
                    return 0;
                value = value.substring(p1 + 1, p2);
                let arr = value.split(",");
                let len = arr.length;
                for (let i = 0; i < len; i++) {
                    arr[i] = parseFloat(arr[i]);
                    if (isNaN(arr[i]))
                        arr[i] = 0;
                }
                if (arr.length == 4)
                    return (arr[0] << 24) + (arr[1] << 16) + (arr[2] << 8) + Math.round(arr[3] * 255);
                else
                    return (arr[0] << 16) + (arr[1] << 8) + arr[2];
            }
            else {
                value.charAt(0) === '#' && (value = value.substring(1));
                let len = value.length;
                if (len === 3 || len === 4) {
                    let temp = "";
                    for (let i = 0; i < len; i++) {
                        temp += (value[i] + value[i]);
                    }
                    value = temp;
                }
                return parseInt(value, 16);
            }
        }
        static getGID() {
            return _gid++;
        }
        static copyArray(source, array) {
            source || (source = []);
            if (!array)
                return source;
            source.length = array.length;
            var len = array.length;
            for (let i = 0; i < len; i++) {
                source[i] = array[i];
            }
            return source;
        }
        static transPointList(points, x, y) {
            var i, len = points.length;
            for (i = 0; i < len; i += 2) {
                points[i] += x;
                points[i + 1] += y;
            }
        }
        static parseInt(str, radix = 0) {
            var result = parseInt(str, radix);
            if (isNaN(result))
                return 0;
            return result;
        }
        static getBaseName(path) {
            let i = path.lastIndexOf("/");
            if (i != -1)
                path = path.substring(i + 1);
            i = path.indexOf("?");
            if (i != -1)
                path = path.substring(0, i);
            return path;
        }
        static getFileExtension(path) {
            let i = path.lastIndexOf(".");
            if (i != -1) {
                let ext = path.substring(i + 1).toLowerCase();
                let j = ext.indexOf("?");
                if (j != -1)
                    ext = ext.substring(0, j);
                if (ext === "ls") {
                    let k = path.lastIndexOf(".", i - 1);
                    if (k != -1) {
                        let ext2 = path.substring(k + 1, i + 1) + ext;
                        if (ext2 === "lanit.ls" || ext2 === "ltcb.ls")
                            return ext2;
                    }
                }
                return ext;
            }
            else
                return "";
        }
        static replaceFileExtension(path, newExt, excludeDot) {
            if (!path)
                return path;
            let i = path.lastIndexOf(".");
            if (newExt.length > 0 && !excludeDot)
                newExt = "." + newExt;
            if (i != -1) {
                let j = path.indexOf("?", i);
                if (j != -1)
                    return path.substring(0, i) + newExt + path.substring(j);
                else
                    return path.substring(0, i) + newExt;
            }
            else
                return path + newExt;
        }
        static isUUID(str) {
            return str && str.length >= 36 && str.charCodeAt(8) === 45 && str.charCodeAt(13) === 45;
        }
        static uint8ArrayToArrayBuffer(rendertexture) {
            let pixelArray;
            const width = rendertexture.width;
            const height = rendertexture.height;
            const pixelCount = width * height * 4;
            const colorFormat = (rendertexture instanceof RenderTexture) ? rendertexture.colorFormat : rendertexture.getColorFormat();
            switch (colorFormat) {
                case exports.RenderTargetFormat.R8G8B8:
                case exports.RenderTargetFormat.R8G8B8A8:
                    pixelArray = new Uint8Array(pixelCount);
                    break;
                case exports.RenderTargetFormat.R16G16B16A16:
                    pixelArray = new Float32Array(pixelCount);
                    break;
                default:
                    throw "this function is not surpprt " + rendertexture.format.toString() + "format Material";
            }
            LayaGL.textureContext.readRenderTargetPixelData(rendertexture._renderTarget, 0, 0, rendertexture.width, rendertexture.height, pixelArray);
            if (colorFormat === exports.RenderTargetFormat.R16G16B16A16) {
                const ori = pixelArray;
                const trans = new Uint8Array(pixelCount);
                for (let i = 0, n = ori.length; i < n; i++) {
                    trans[i] = Math.min(Math.floor(ori[i] * 255), 255);
                }
                pixelArray = trans;
            }
            const pixels = pixelArray;
            const canvas = Browser.createElement("canvas");
            canvas.height = height;
            canvas.width = width;
            const ctx2d = canvas.getContext('2d');
            const imgdata = ctx2d.createImageData(width, height);
            imgdata.data.set(new Uint8ClampedArray(pixels));
            ctx2d.putImageData(imgdata, 0, 0);
            const base64String = canvas.toDataURL();
            canvas.remove();
            return base64String;
        }
        static uint8ArrayToArrayBufferAsync(rendertexture) {
            let pixelArray;
            const width = rendertexture.width;
            const height = rendertexture.height;
            const pixelCount = width * height * 4;
            const colorFormat = (rendertexture instanceof RenderTexture) ? rendertexture.colorFormat : rendertexture.getColorFormat();
            switch (colorFormat) {
                case exports.RenderTargetFormat.R8G8B8:
                case exports.RenderTargetFormat.R8G8B8A8:
                    pixelArray = new Uint8Array(pixelCount);
                    break;
                case exports.RenderTargetFormat.R16G16B16A16:
                    pixelArray = new Float32Array(pixelCount);
                    break;
                default:
                    throw "this function is not surpprt " + rendertexture.format.toString() + "format Material";
            }
            return rendertexture.getDataAsync(0, 0, width, height, pixelArray).then(() => {
                if (colorFormat === exports.RenderTargetFormat.R16G16B16A16) {
                    const ori = pixelArray;
                    const trans = new Uint8Array(pixelCount);
                    for (let i = 0, n = ori.length; i < n; i++) {
                        trans[i] = Math.min(Math.floor(ori[i] * 255), 255);
                    }
                    pixelArray = trans;
                }
                const pixels = pixelArray;
                const canvas = Browser.createElement("canvas");
                canvas.height = height;
                canvas.width = width;
                const ctx2d = canvas.getContext('2d');
                const imgdata = ctx2d.createImageData(width, height);
                imgdata.data.set(new Uint8ClampedArray(pixels));
                ctx2d.putImageData(imgdata, 0, 0);
                const base64String = canvas.toDataURL();
                canvas.remove();
                return Promise.resolve(base64String);
            });
        }
    }

    class AssetDb {
        constructor() {
            this.uuidMap = {};
            this.shaderNameMap = {};
            this.metaMap = {};
        }
        UUID_to_URL(uuid) {
            return this.uuidMap[uuid];
        }
        UUID_to_URL_async(uuid) {
            return Promise.resolve(null);
        }
        URL_to_UUID_async(url) {
            return Promise.resolve(null);
        }
        resolveURL(url, onResolve) {
            if (url.startsWith("res://")) {
                let uuid = url.substring(6);
                return AssetDb.inst.UUID_to_URL_async(uuid).then(url => {
                    if (onResolve)
                        onResolve(url);
                    return url;
                });
            }
            else {
                if (onResolve)
                    onResolve(url);
                return Promise.resolve(url);
            }
        }
        shaderName_to_URL(shaderName) {
            return this.shaderNameMap[shaderName];
        }
        shaderName_to_URL_async(shaderName) {
            return Promise.resolve(null);
        }
        getMeta(url, uuid) {
            return Promise.resolve(null);
        }
        getSubAssetURL(url, uuid, subAssetName, subAssetExt) {
            if (subAssetName)
                return `${Utils.replaceFileExtension(url, "")}@${subAssetName}.${subAssetExt}`;
            else
                return url;
        }
    }
    AssetDb.inst = new AssetDb();

    class URL {
        static __init__() {
            if (URL.basePath == null)
                URL.basePath = (location && location.protocol != undefined && location.protocol != "") ? URL.getPath(location.protocol + "//" + location.host + location.pathname) : "";
        }
        static initMiniGameExtensionOverrides() {
            if (LayaEnv.isPreview)
                return;
            Object.assign(this.overrideFileExts, this.safeFileExtConversionMap);
            this.hasExtOverrides = true;
            this.usingSafeFileExts = true;
        }
        constructor(url) {
            this._url = URL.formatURL(url);
            this._path = URL.getPath(url);
        }
        get url() {
            return this._url;
        }
        get path() {
            return this._path;
        }
        static get rootPath() {
            return URL.basePaths["~/"];
        }
        static set rootPath(value) {
            URL.basePaths["~/"] = value;
        }
        static formatURL(url, base) {
            if (!url)
                return base || URL.basePath || "";
            if (url.startsWith("res://")) {
                let uuid = url.substring(6);
                let url2 = AssetDb.inst.UUID_to_URL(uuid);
                if (!url2)
                    return url;
                url = url2;
            }
            if (url.indexOf(":") == -1 && url.charCodeAt(0) !== 47) {
                if (URL.customFormat != null)
                    url = URL.customFormat(url);
                let ver = URL.version[url];
                if (ver != null) {
                    let i = url.lastIndexOf(".");
                    url = url.substring(0, i) + "-" + ver + url.substring(i);
                }
                if (base == null) {
                    base = URL.basePath;
                    for (let k in URL.basePaths) {
                        if (url.startsWith(k)) {
                            if (k.charCodeAt(0) === 126)
                                url = url.substring(k.length);
                            base = URL.basePaths[k];
                            break;
                        }
                    }
                }
                url = URL.join(base, url);
            }
            return url;
        }
        static postFormatURL(url) {
            if (URL.hasExtOverrides) {
                let extold = Utils.getFileExtension(url);
                let ext = URL.overrideFileExts[extold];
                if (ext != null)
                    url = Utils.replaceFileExtension(url, ext);
            }
            return url;
        }
        static normalize(url) {
            if (url.indexOf("./") == -1)
                return url;
            let parts = url.split("/");
            let len = parts.length;
            let i = 0;
            while (i < len) {
                if (parts[i] == ".") {
                    parts.splice(i, 1);
                    len--;
                    continue;
                }
                else if (parts[i] == '..') {
                    let index = i - 1;
                    if (index >= 0 && parts[index] !== '..') {
                        parts.splice(index, 2);
                        len -= 2;
                        i--;
                        continue;
                    }
                }
                i++;
            }
            parts.length = len;
            return parts.join('/');
        }
        static getResURLByUUID(url) {
            if (Utils.isUUID(url))
                return "res://" + url;
            else
                return url;
        }
        static join(base, path) {
            if (!path)
                return "";
            if (path.indexOf(":") > 0)
                return path;
            if (base) {
                let char1 = path.charCodeAt(0);
                if (char1 !== 126 && char1 !== 47) {
                    if (base.charCodeAt(base.length - 1) !== 47)
                        path = base + "/" + path;
                    else
                        path = base + path;
                }
            }
            return URL.normalize(path);
        }
        static getPath(url) {
            var ofs = url.lastIndexOf('/');
            return ofs > 0 ? url.substring(0, ofs + 1) : "";
        }
        static getFileName(url) {
            var ofs = url.lastIndexOf('/');
            return ofs > 0 ? url.substring(ofs + 1) : url;
        }
        static getURLVerion(url) {
            var index = url.indexOf("?");
            return index >= 0 ? url.substring(index) : null;
        }
        static overrideExtension(originalExts, targetExt, miniGameOnly) {
            if (miniGameOnly) {
                if (!URL.usingSafeFileExts) {
                    for (let ext of originalExts)
                        URL.safeFileExtConversionMap[ext] = targetExt;
                    return;
                }
            }
            for (let ext of originalExts)
                URL.overrideFileExts[ext] = targetExt;
            URL.hasExtOverrides = true;
        }
    }
    URL.version = {};
    URL.basePaths = {};
    URL.overrideFileExts = {};
    URL.hasExtOverrides = false;
    URL.usingSafeFileExts = false;
    URL.safeFileExtConversionMap = {
        "rendertexture": "rt.json",
        "videotexture": "rt.json",
        "controller": "controller.json",
        "mc": "mc.bin",
        "mcc": "mcc.json",
        "shader": "shader.json",
        "fui": "fui.json",
        "glsl": "glsl.txt",
        "skel": "skel.bin",
        "lavm": "lavm.json",
    };
    URL.customFormat = function (url) {
        return url;
    };

    class Rectangle {
        constructor(x = 0, y = 0, width = 0, height = 0) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        get right() {
            return this.x + this.width;
        }
        get bottom() {
            return this.y + this.height;
        }
        setTo(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            return this;
        }
        reset() {
            this.x = this.y = this.width = this.height = 0;
            return this;
        }
        recover() {
            if (this == Rectangle.TEMP || this == Rectangle.EMPTY) {
                return;
            }
            Pool.recover("Rectangle", this.reset());
        }
        static create() {
            return Pool.getItemByClass("Rectangle", Rectangle);
        }
        copyFrom(source) {
            this.x = source.x;
            this.y = source.y;
            this.width = source.width;
            this.height = source.height;
            return this;
        }
        contains(x, y) {
            if (this.width <= 0 || this.height <= 0)
                return false;
            if (x >= this.x && x < this.right) {
                if (y >= this.y && y < this.bottom) {
                    return true;
                }
            }
            return false;
        }
        intersects(rect) {
            return !(rect.x > (this.x + this.width) || (rect.x + rect.width) < this.x || rect.y > (this.y + this.height) || (rect.y + rect.height) < this.y);
        }
        intersection(rect, out) {
            if (!this.intersects(rect))
                return null;
            let x = Math.max(this.x, rect.x);
            let y = Math.max(this.y, rect.y);
            let width = Math.min(this.right, rect.right) - x;
            let height = Math.min(this.bottom, rect.bottom) - y;
            out || (out = new Rectangle());
            return out.setTo(x, y, width, height);
        }
        union(source, out) {
            let x = source.x;
            let y = source.y;
            let width = source.width;
            let height = source.height;
            out || (out = new Rectangle());
            this.cloneTo(out);
            if (width <= 0 || height <= 0)
                return out;
            if (this.width <= 0 || this.height <= 0)
                return out.setTo(x, y, width, height);
            out.addPoint(x, y);
            out.addPoint(x + width, y + height);
            return out;
        }
        scale(scaleX, scaleY) {
            this.x *= scaleX;
            this.y *= scaleY;
            this.width *= scaleX;
            this.height *= scaleY;
            return this;
        }
        toString() {
            return this.x + "," + this.y + "," + this.width + "," + this.height;
        }
        equals(rect) {
            if (!rect || rect.x !== this.x || rect.y !== this.y || rect.width !== this.width || rect.height !== this.height)
                return false;
            return true;
        }
        addPoint(x, y) {
            this.x > x && (this.width += this.x - x, this.x = x);
            this.y > y && (this.height += this.y - y, this.y = y);
            if (this.width < x - this.x)
                this.width = x - this.x;
            if (this.height < y - this.y)
                this.height = y - this.y;
            return this;
        }
        _getBoundPoints() {
            _temB.length = 0;
            if (this.width == 0 || this.height == 0)
                return _temB;
            _temB.push(this.x, this.y, this.x + this.width, this.y, this.x, this.y + this.height, this.x + this.width, this.y + this.height);
            return _temB;
        }
        static _getBoundPointS(x, y, width, height, sp) {
            _temA.length = 0;
            if (width == 0 || height == 0)
                return _temA;
            if (sp) {
                x *= sp.width;
                y *= sp.height;
                width *= sp.width;
                height *= sp.height;
            }
            _temA.push(x, y, x + width, y, x, y + height, x + width, y + height);
            return _temA;
        }
        static _getWrapRec(pointList, rst = null) {
            if (!pointList || pointList.length < 1)
                return rst ? rst.setTo(0, 0, 0, 0) : Rectangle.TEMP.setTo(0, 0, 0, 0);
            rst = rst ? rst : Rectangle.create();
            var i, len = pointList.length, minX, maxX, minY, maxY, tPoint = Point.TEMP;
            minX = minY = 99999;
            maxX = maxY = -minX;
            for (i = 0; i < len; i += 2) {
                tPoint.x = pointList[i];
                tPoint.y = pointList[i + 1];
                minX = minX < tPoint.x ? minX : tPoint.x;
                minY = minY < tPoint.y ? minY : tPoint.y;
                maxX = maxX > tPoint.x ? maxX : tPoint.x;
                maxY = maxY > tPoint.y ? maxY : tPoint.y;
            }
            return rst.setTo(minX, minY, maxX - minX, maxY - minY);
        }
        isEmpty() {
            if (this.width <= 0 || this.height <= 0)
                return true;
            return false;
        }
        clone(out = null) {
            out || (out = new Rectangle());
            this.cloneTo(out);
            return out;
        }
        cloneTo(destObject) {
            destObject.x = this.x;
            destObject.y = this.y;
            destObject.width = this.width;
            destObject.height = this.height;
        }
    }
    Rectangle.EMPTY = new Rectangle();
    Rectangle.TEMP = new Rectangle();
    const _temB = [];
    const _temA = [];

    class Matrix {
        constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0, nums = 0) {
            this._bTransform = false;
            if (Matrix._createFun != null) {
                return Matrix._createFun(a, b, c, d, tx, ty, nums);
            }
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.tx = tx;
            this.ty = ty;
            this._checkTransform();
        }
        identity() {
            this.a = this.d = 1;
            this.b = this.tx = this.ty = this.c = 0;
            this._bTransform = false;
            return this;
        }
        _checkTransform() {
            return this._bTransform = (this.a !== 1 || this.b !== 0 || this.c !== 0 || this.d !== 1);
        }
        setTranslate(x, y) {
            this.tx = x;
            this.ty = y;
            return this;
        }
        translate(x, y) {
            this.tx += x;
            this.ty += y;
            return this;
        }
        scale(x, y) {
            this.a *= x;
            this.d *= y;
            this.c *= x;
            this.b *= y;
            this.tx *= x;
            this.ty *= y;
            this._bTransform = true;
            return this;
        }
        rotate(angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var a1 = this.a;
            var c1 = this.c;
            var tx1 = this.tx;
            this.a = a1 * cos - this.b * sin;
            this.b = a1 * sin + this.b * cos;
            this.c = c1 * cos - this.d * sin;
            this.d = c1 * sin + this.d * cos;
            this.tx = tx1 * cos - this.ty * sin;
            this.ty = tx1 * sin + this.ty * cos;
            this._bTransform = true;
            return this;
        }
        skew(x, y) {
            var tanX = Math.tan(x);
            var tanY = Math.tan(y);
            var a1 = this.a;
            var b1 = this.b;
            this.a += tanY * this.c;
            this.b += tanY * this.d;
            this.c += tanX * a1;
            this.d += tanX * b1;
            return this;
        }
        invertTransformPoint(out) {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            var tx1 = this.tx;
            var n = a1 * d1 - b1 * c1;
            var a2 = d1 / n;
            var b2 = -b1 / n;
            var c2 = -c1 / n;
            var d2 = a1 / n;
            var tx2 = (c1 * this.ty - d1 * tx1) / n;
            var ty2 = -(a1 * this.ty - b1 * tx1) / n;
            return out.setTo(a2 * out.x + c2 * out.y + tx2, b2 * out.x + d2 * out.y + ty2);
        }
        transformPoint(out) {
            return out.setTo(this.a * out.x + this.c * out.y + this.tx, this.b * out.x + this.d * out.y + this.ty);
        }
        transformPointN(out) {
            return out.setTo(this.a * out.x + this.c * out.y, this.b * out.x + this.d * out.y);
        }
        getScaleX() {
            return this.b === 0 ? this.a : Math.sqrt(this.a * this.a + this.b * this.b);
        }
        getScaleY() {
            return this.c === 0 ? this.d : Math.sqrt(this.c * this.c + this.d * this.d);
        }
        invert() {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            var tx1 = this.tx;
            var n = a1 * d1 - b1 * c1;
            this.a = d1 / n;
            this.b = -b1 / n;
            this.c = -c1 / n;
            this.d = a1 / n;
            this.tx = (c1 * this.ty - d1 * tx1) / n;
            this.ty = -(a1 * this.ty - b1 * tx1) / n;
            return this;
        }
        setTo(a, b, c, d, tx, ty) {
            this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty;
            return this;
        }
        concat(matrix) {
            var a = this.a;
            var c = this.c;
            var tx = this.tx;
            this.a = a * matrix.a + this.b * matrix.c;
            this.b = a * matrix.b + this.b * matrix.d;
            this.c = c * matrix.a + this.d * matrix.c;
            this.d = c * matrix.b + this.d * matrix.d;
            this.tx = tx * matrix.a + this.ty * matrix.c + matrix.tx;
            this.ty = tx * matrix.b + this.ty * matrix.d + matrix.ty;
            return this;
        }
        static mul(m1, m2, out) {
            var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
            var ba = m2.a, bb = m2.b, bc = m2.c, bd = m2.d, btx = m2.tx, bty = m2.ty;
            if (bb !== 0 || bc !== 0) {
                out.a = aa * ba + ab * bc;
                out.b = aa * bb + ab * bd;
                out.c = ac * ba + ad * bc;
                out.d = ac * bb + ad * bd;
                out.tx = ba * atx + bc * aty + btx;
                out.ty = bb * atx + bd * aty + bty;
            }
            else {
                out.a = aa * ba;
                out.b = ab * bd;
                out.c = ac * ba;
                out.d = ad * bd;
                out.tx = ba * atx + btx;
                out.ty = bd * aty + bty;
            }
            return out;
        }
        static mul16(m1, m2, out) {
            var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
            var ba = m2.a, bb = m2.b, bc = m2.c, bd = m2.d, btx = m2.tx, bty = m2.ty;
            if (bb !== 0 || bc !== 0) {
                out[0] = aa * ba + ab * bc;
                out[1] = aa * bb + ab * bd;
                out[4] = ac * ba + ad * bc;
                out[5] = ac * bb + ad * bd;
                out[12] = ba * atx + bc * aty + btx;
                out[13] = bb * atx + bd * aty + bty;
            }
            else {
                out[0] = aa * ba;
                out[1] = ab * bd;
                out[4] = ac * ba;
                out[5] = ad * bd;
                out[12] = ba * atx + btx;
                out[13] = bd * aty + bty;
            }
            return out;
        }
        scaleEx(x, y) {
            var ba = this.a, bb = this.b, bc = this.c, bd = this.d;
            if (bb !== 0 || bc !== 0) {
                this.a = x * ba;
                this.b = x * bb;
                this.c = y * bc;
                this.d = y * bd;
            }
            else {
                this.a = x * ba;
                this.b = 0 * bd;
                this.c = 0 * ba;
                this.d = y * bd;
            }
            this._bTransform = true;
        }
        rotateEx(angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var ba = this.a, bb = this.b, bc = this.c, bd = this.d;
            if (bb !== 0 || bc !== 0) {
                this.a = cos * ba + sin * bc;
                this.b = cos * bb + sin * bd;
                this.c = -sin * ba + cos * bc;
                this.d = -sin * bb + cos * bd;
            }
            else {
                this.a = cos * ba;
                this.b = sin * bd;
                this.c = -sin * ba;
                this.d = cos * bd;
            }
            this._bTransform = true;
        }
        clone() {
            var dec = Matrix.create();
            dec.a = this.a;
            dec.b = this.b;
            dec.c = this.c;
            dec.d = this.d;
            dec.tx = this.tx;
            dec.ty = this.ty;
            dec._bTransform = this._bTransform;
            return dec;
        }
        copyTo(dec) {
            dec.a = this.a;
            dec.b = this.b;
            dec.c = this.c;
            dec.d = this.d;
            dec.tx = this.tx;
            dec.ty = this.ty;
            dec._bTransform = this._bTransform;
            return dec;
        }
        toString() {
            return this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.tx + "," + this.ty;
        }
        destroy() {
            this.recover();
        }
        recover() {
            Pool.recover("Matrix", this.identity());
        }
        static create() {
            return Pool.getItemByClass("Matrix", Matrix);
        }
    }
    Matrix.EMPTY = new Matrix();
    Matrix.TEMP = new Matrix();
    Matrix._createFun = null;

    class NotImplementedError extends Error {
        constructor() {
            super('Not implemented.');
        }
    }
    class OutOfRangeError extends Error {
        constructor(index) {
            super(`Index out of range: ${index}`);
        }
    }
    class NotReadableError extends Error {
        constructor() {
            super("readable flag need to be true.");
        }
    }

    class Byte {
        static getSystemEndian() {
            if (!Byte._sysEndian) {
                var buffer = new ArrayBuffer(2);
                new DataView(buffer).setInt16(0, 256, true);
                Byte._sysEndian = (new Int16Array(buffer))[0] === 256 ? Byte.LITTLE_ENDIAN : Byte.BIG_ENDIAN;
            }
            return Byte._sysEndian;
        }
        constructor(data = null) {
            this._xd_ = true;
            this._allocated_ = 8;
            this._pos_ = 0;
            this._length = 0;
            if (data) {
                this._u8d_ = new Uint8Array(data);
                this._d_ = new DataView(this._u8d_.buffer);
                this._length = this._d_.byteLength;
            }
            else {
                this._resizeBuffer(this._allocated_);
            }
        }
        get buffer() {
            var rstBuffer = this._d_.buffer;
            if (rstBuffer.byteLength === this._length)
                return rstBuffer;
            return rstBuffer.slice(0, this._length);
        }
        get endian() {
            return this._xd_ ? Byte.LITTLE_ENDIAN : Byte.BIG_ENDIAN;
        }
        set endian(value) {
            this._xd_ = (value === Byte.LITTLE_ENDIAN);
        }
        set length(value) {
            if (this._allocated_ < value)
                this._resizeBuffer(this._allocated_ = Math.floor(Math.max(value, this._allocated_ * 2)));
            else if (this._allocated_ > value)
                this._resizeBuffer(this._allocated_ = value);
            this._length = value;
        }
        get length() {
            return this._length;
        }
        _resizeBuffer(len) {
            try {
                var newByteView = new Uint8Array(len);
                if (this._u8d_ != null) {
                    if (this._u8d_.length <= len)
                        newByteView.set(this._u8d_);
                    else
                        newByteView.set(this._u8d_.subarray(0, len));
                }
                this._u8d_ = newByteView;
                this._d_ = new DataView(newByteView.buffer);
            }
            catch (err) {
                throw "Invalid typed array length:" + len;
            }
        }
        getString() {
            return this.readString();
        }
        readString() {
            return this._rUTF(this.getUint16());
        }
        getFloat32Array(start, len) {
            return this.readFloat32Array(start, len);
        }
        readFloat32Array(start, len) {
            var end = start + len;
            end = (end > this._length) ? this._length : end;
            var v = new Float32Array(this._d_.buffer.slice(start, end));
            this._pos_ = end;
            return v;
        }
        getUint8Array(start, len) {
            return this.readUint8Array(start, len);
        }
        readUint8Array(start, len) {
            var end = start + len;
            end = (end > this._length) ? this._length : end;
            var v = new Uint8Array(this._d_.buffer.slice(start, end));
            this._pos_ = end;
            return v;
        }
        getInt16Array(start, len) {
            return this.readInt16Array(start, len);
        }
        readInt16Array(start, len) {
            var end = start + len;
            end = (end > this._length) ? this._length : end;
            var v = new Int16Array(this._d_.buffer.slice(start, end));
            this._pos_ = end;
            return v;
        }
        getFloat32() {
            return this.readFloat32();
        }
        readFloat32() {
            if (this._pos_ + 4 > this._length)
                throw new OutOfRangeError(this._pos_ + 4);
            var v = this._d_.getFloat32(this._pos_, this._xd_);
            this._pos_ += 4;
            return v;
        }
        getFloat64() {
            return this.readFloat64();
        }
        readFloat64() {
            if (this._pos_ + 8 > this._length)
                throw new OutOfRangeError(this._pos_ + 8);
            var v = this._d_.getFloat64(this._pos_, this._xd_);
            this._pos_ += 8;
            return v;
        }
        writeFloat32(value) {
            this._ensureWrite(this._pos_ + 4);
            this._d_.setFloat32(this._pos_, value, this._xd_);
            this._pos_ += 4;
        }
        writeFloat64(value) {
            this._ensureWrite(this._pos_ + 8);
            this._d_.setFloat64(this._pos_, value, this._xd_);
            this._pos_ += 8;
        }
        getInt32() {
            return this.readInt32();
        }
        readInt32() {
            if (this._pos_ + 4 > this._length)
                throw new OutOfRangeError(this._pos_ + 4);
            var float = this._d_.getInt32(this._pos_, this._xd_);
            this._pos_ += 4;
            return float;
        }
        getUint32() {
            return this.readUint32();
        }
        readUint32() {
            if (this._pos_ + 4 > this._length)
                throw new OutOfRangeError(this._pos_ + 4);
            var v = this._d_.getUint32(this._pos_, this._xd_);
            this._pos_ += 4;
            return v;
        }
        writeInt32(value) {
            this._ensureWrite(this._pos_ + 4);
            this._d_.setInt32(this._pos_, value, this._xd_);
            this._pos_ += 4;
        }
        writeUint32(value) {
            this._ensureWrite(this._pos_ + 4);
            this._d_.setUint32(this._pos_, value, this._xd_);
            this._pos_ += 4;
        }
        getInt16() {
            return this.readInt16();
        }
        readInt16() {
            if (this._pos_ + 2 > this._length)
                throw new OutOfRangeError(this._pos_ + 2);
            var us = this._d_.getInt16(this._pos_, this._xd_);
            this._pos_ += 2;
            return us;
        }
        getUint16() {
            return this.readUint16();
        }
        readUint16() {
            if (this._pos_ + 2 > this._length)
                throw new OutOfRangeError(this._pos_ + 2);
            var us = this._d_.getUint16(this._pos_, this._xd_);
            this._pos_ += 2;
            return us;
        }
        writeUint16(value) {
            this._ensureWrite(this._pos_ + 2);
            this._d_.setUint16(this._pos_, value, this._xd_);
            this._pos_ += 2;
        }
        writeInt16(value) {
            this._ensureWrite(this._pos_ + 2);
            this._d_.setInt16(this._pos_, value, this._xd_);
            this._pos_ += 2;
        }
        getUint8() {
            return this.readUint8();
        }
        readUint8() {
            if (this._pos_ + 1 > this._length)
                throw new OutOfRangeError(this._pos_ + 1);
            return this._u8d_[this._pos_++];
        }
        writeUint8(value) {
            this._ensureWrite(this._pos_ + 1);
            this._d_.setUint8(this._pos_, value);
            this._pos_++;
        }
        _getUInt8(pos) {
            return this._readUInt8(pos);
        }
        _readUInt8(pos) {
            return this._d_.getUint8(pos);
        }
        _getUint16(pos) {
            return this._readUint16(pos);
        }
        _readUint16(pos) {
            return this._d_.getUint16(pos, this._xd_);
        }
        _getMatrix() {
            return this._readMatrix();
        }
        _readMatrix() {
            var rst = new Matrix(this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32());
            return rst;
        }
        _rUTF(len) {
            var max = this._pos_ + len, c, c2, c3, f = String.fromCharCode;
            var u = this._u8d_;
            var strs = [];
            var n = 0;
            strs.length = 1000;
            while (this._pos_ < max) {
                c = u[this._pos_++];
                if (c < 0x80) {
                    if (c != 0)
                        strs[n++] = f(c);
                }
                else if (c < 0xE0) {
                    strs[n++] = f(((c & 0x3F) << 6) | (u[this._pos_++] & 0x7F));
                }
                else if (c < 0xF0) {
                    c2 = u[this._pos_++];
                    strs[n++] = f(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (u[this._pos_++] & 0x7F));
                }
                else {
                    c2 = u[this._pos_++];
                    c3 = u[this._pos_++];
                    const _code = ((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 & 0x7F) << 6) | (u[this._pos_++] & 0x7F);
                    if (_code >= 0x10000) {
                        const _offset = _code - 0x10000;
                        const _lead = 0xd800 | (_offset >> 10);
                        const _trail = 0xdc00 | (_offset & 0x3ff);
                        strs[n++] = f(_lead);
                        strs[n++] = f(_trail);
                    }
                    else {
                        strs[n++] = f(_code);
                    }
                }
            }
            strs.length = n;
            return strs.join('');
        }
        getCustomString(len) {
            return this.readCustomString(len);
        }
        readCustomString(len) {
            var v = "", ulen = 0, c, c2, f = String.fromCharCode;
            var u = this._u8d_;
            while (len > 0) {
                c = u[this._pos_];
                if (c < 0x80) {
                    v += f(c);
                    this._pos_++;
                    len--;
                }
                else {
                    ulen = c - 0x80;
                    this._pos_++;
                    len -= ulen;
                    while (ulen > 0) {
                        c = u[this._pos_++];
                        c2 = u[this._pos_++];
                        v += f((c2 << 8) | c);
                        ulen--;
                    }
                }
            }
            return v;
        }
        get pos() {
            return this._pos_;
        }
        set pos(value) {
            this._pos_ = value;
        }
        get bytesAvailable() {
            return this._length - this._pos_;
        }
        clear() {
            this._pos_ = 0;
            this.length = 0;
        }
        __getBuffer() {
            return this._d_.buffer;
        }
        writeUTFBytes(value) {
            value = value + "";
            for (var i = 0, sz = value.length; i < sz; i++) {
                var c = value.charCodeAt(i);
                if (c <= 0x7F) {
                    this.writeByte(c);
                }
                else if (c <= 0x7FF) {
                    this._ensureWrite(this._pos_ + 2);
                    this._u8d_.set([0xC0 | (c >> 6), 0x80 | (c & 0x3F)], this._pos_);
                    this._pos_ += 2;
                }
                else if (c >= 0xD800 && c <= 0xDBFF) {
                    i++;
                    const c2 = value.charCodeAt(i);
                    if (!Number.isNaN(c2) && c2 >= 0xDC00 && c2 <= 0xDFFF) {
                        const _p1 = (c & 0x3FF) + 0x40;
                        const _p2 = c2 & 0x3FF;
                        const _b1 = 0xF0 | ((_p1 >> 8) & 0x3F);
                        const _b2 = 0x80 | ((_p1 >> 2) & 0x3F);
                        const _b3 = 0x80 | ((_p1 & 0x3) << 4) | ((_p2 >> 6) & 0xF);
                        const _b4 = 0x80 | (_p2 & 0x3F);
                        this._ensureWrite(this._pos_ + 4);
                        this._u8d_.set([_b1, _b2, _b3, _b4], this._pos_);
                        this._pos_ += 4;
                    }
                }
                else if (c <= 0xFFFF) {
                    this._ensureWrite(this._pos_ + 3);
                    this._u8d_.set([0xE0 | (c >> 12), 0x80 | ((c >> 6) & 0x3F), 0x80 | (c & 0x3F)], this._pos_);
                    this._pos_ += 3;
                }
                else {
                    this._ensureWrite(this._pos_ + 4);
                    this._u8d_.set([0xF0 | (c >> 18), 0x80 | ((c >> 12) & 0x3F), 0x80 | ((c >> 6) & 0x3F), 0x80 | (c & 0x3F)], this._pos_);
                    this._pos_ += 4;
                }
            }
        }
        writeUTFString(value) {
            var tPos = this.pos;
            this.writeUint16(1);
            this.writeUTFBytes(value);
            var dPos = this.pos - tPos - 2;
            this._d_.setUint16(tPos, dPos, this._xd_);
        }
        writeUTFString32(value) {
            var tPos = this.pos;
            this.writeUint32(1);
            this.writeUTFBytes(value);
            var dPos = this.pos - tPos - 4;
            this._d_.setUint32(tPos, dPos, this._xd_);
        }
        readUTFString() {
            return this.readUTFBytes(this.getUint16());
        }
        readUTFString32() {
            return this.readUTFBytes(this.getUint32());
        }
        getUTFString() {
            return this.readUTFString();
        }
        readUTFBytes(len = -1) {
            if (len === 0)
                return "";
            var lastBytes = this.bytesAvailable;
            if (len > lastBytes)
                throw new OutOfRangeError(this._pos_ + len);
            len = len > 0 ? len : lastBytes;
            return this._rUTF(len);
        }
        getUTFBytes(len = -1) {
            return this.readUTFBytes(len);
        }
        writeByte(value) {
            this._ensureWrite(this._pos_ + 1);
            this._d_.setInt8(this._pos_, value);
            this._pos_ += 1;
        }
        readByte() {
            if (this._pos_ + 1 > this._length)
                throw new OutOfRangeError(this._pos_ + 1);
            return this._d_.getInt8(this._pos_++);
        }
        getByte() {
            return this.readByte();
        }
        _ensureWrite(lengthToEnsure) {
            if (this._length < lengthToEnsure)
                this._length = lengthToEnsure;
            if (this._allocated_ < lengthToEnsure)
                this.length = lengthToEnsure;
        }
        writeArrayBuffer(arraybuffer, offset = 0, length = 0) {
            if (offset < 0 || length < 0)
                throw new OutOfRangeError(offset + length);
            if (length == 0)
                length = arraybuffer.byteLength - offset;
            this._ensureWrite(this._pos_ + length);
            var uint8array = new Uint8Array(arraybuffer);
            this._u8d_.set(uint8array.subarray(offset, offset + length), this._pos_);
            this._pos_ += length;
        }
        readArrayBuffer(length) {
            var rst;
            rst = this._u8d_.buffer.slice(this._pos_, this._pos_ + length);
            this._pos_ = this._pos_ + length;
            return rst;
        }
    }
    Byte.BIG_ENDIAN = "bigEndian";
    Byte.LITTLE_ENDIAN = "littleEndian";
    Byte._sysEndian = null;

    class HalfFloatUtils {
        static __init__() {
            for (var i = 0; i < 256; ++i) {
                var e = i - 127;
                if (e < -27) {
                    _baseTable[i | 0x000] = 0x0000;
                    _baseTable[i | 0x100] = 0x8000;
                    _shiftTable[i | 0x000] = 24;
                    _shiftTable[i | 0x100] = 24;
                }
                else if (e < -14) {
                    _baseTable[i | 0x000] = 0x0400 >> (-e - 14);
                    _baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;
                    _shiftTable[i | 0x000] = -e - 1;
                    _shiftTable[i | 0x100] = -e - 1;
                }
                else if (e <= 15) {
                    _baseTable[i | 0x000] = (e + 15) << 10;
                    _baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;
                    _shiftTable[i | 0x000] = 13;
                    _shiftTable[i | 0x100] = 13;
                }
                else if (e < 128) {
                    _baseTable[i | 0x000] = 0x7c00;
                    _baseTable[i | 0x100] = 0xfc00;
                    _shiftTable[i | 0x000] = 24;
                    _shiftTable[i | 0x100] = 24;
                }
                else {
                    _baseTable[i | 0x000] = 0x7c00;
                    _baseTable[i | 0x100] = 0xfc00;
                    _shiftTable[i | 0x000] = 13;
                    _shiftTable[i | 0x100] = 13;
                }
            }
            _mantissaTable[0] = 0;
            for (i = 1; i < 1024; ++i) {
                var m = i << 13;
                e = 0;
                while ((m & 0x00800000) === 0) {
                    e -= 0x00800000;
                    m <<= 1;
                }
                m &= ~0x00800000;
                e += 0x38800000;
                _mantissaTable[i] = m | e;
            }
            for (i = 1024; i < 2048; ++i) {
                _mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);
            }
            _exponentTable[0] = 0;
            for (i = 1; i < 31; ++i) {
                _exponentTable[i] = i << 23;
            }
            _exponentTable[31] = 0x47800000;
            _exponentTable[32] = 0x80000000;
            for (i = 33; i < 63; ++i) {
                _exponentTable[i] = 0x80000000 + ((i - 32) << 23);
            }
            _exponentTable[63] = 0xc7800000;
            _offsetTable[0] = 0;
            for (i = 1; i < 64; ++i) {
                if (i === 32) {
                    _offsetTable[i] = 0;
                }
                else {
                    _offsetTable[i] = 1024;
                }
            }
        }
        static roundToFloat16Bits(num) {
            _floatView[0] = num;
            var f = _uint32View[0];
            var e = (f >> 23) & 0x1ff;
            return _baseTable[e] + ((f & 0x007fffff) >> _shiftTable[e]);
        }
        static convertToNumber(float16bits) {
            var m = float16bits >> 10;
            _uint32View[0] = _mantissaTable[_offsetTable[m] + (float16bits & 0x3ff)] + _exponentTable[m];
            return _floatView[0];
        }
    }
    const _buffer = new ArrayBuffer(4);
    const _floatView = new Float32Array(_buffer);
    const _uint32View = new Uint32Array(_buffer);
    const _baseTable = new Uint32Array(512);
    const _shiftTable = new Uint32Array(512);
    const _mantissaTable = new Uint32Array(2048);
    const _exponentTable = new Uint32Array(64);
    const _offsetTable = new Uint32Array(64);

    exports.FilterMode = void 0;
    (function (FilterMode) {
        FilterMode[FilterMode["Point"] = 0] = "Point";
        FilterMode[FilterMode["Bilinear"] = 1] = "Bilinear";
        FilterMode[FilterMode["Trilinear"] = 2] = "Trilinear";
    })(exports.FilterMode || (exports.FilterMode = {}));

    exports.RenderCapable = void 0;
    (function (RenderCapable) {
        RenderCapable[RenderCapable["Element_Index_Uint32"] = 0] = "Element_Index_Uint32";
        RenderCapable[RenderCapable["TextureFormat_R32G32B32A32"] = 1] = "TextureFormat_R32G32B32A32";
        RenderCapable[RenderCapable["TextureFormat_R16G16B16A16"] = 2] = "TextureFormat_R16G16B16A16";
        RenderCapable[RenderCapable["Texture_anisotropic"] = 3] = "Texture_anisotropic";
        RenderCapable[RenderCapable["RenderTextureFormat_R16G16B16A16"] = 4] = "RenderTextureFormat_R16G16B16A16";
        RenderCapable[RenderCapable["RenderTextureFormat_R32G32B32A32"] = 5] = "RenderTextureFormat_R32G32B32A32";
        RenderCapable[RenderCapable["RenderTextureFormat_Depth"] = 6] = "RenderTextureFormat_Depth";
        RenderCapable[RenderCapable["RenderTextureFormat_ShadowMap"] = 7] = "RenderTextureFormat_ShadowMap";
        RenderCapable[RenderCapable["Vertex_VAO"] = 8] = "Vertex_VAO";
        RenderCapable[RenderCapable["DrawElement_Instance"] = 9] = "DrawElement_Instance";
        RenderCapable[RenderCapable["Shader_TextureLod"] = 10] = "Shader_TextureLod";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_S3TC"] = 11] = "COMPRESS_TEXTURE_S3TC";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_S3TC_SRGB"] = 12] = "COMPRESS_TEXTURE_S3TC_SRGB";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_PVRTC"] = 13] = "COMPRESS_TEXTURE_PVRTC";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_ETC1"] = 14] = "COMPRESS_TEXTURE_ETC1";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_ETC"] = 15] = "COMPRESS_TEXTURE_ETC";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_ASTC"] = 16] = "COMPRESS_TEXTURE_ASTC";
        RenderCapable[RenderCapable["Texture_SRGB"] = 17] = "Texture_SRGB";
        RenderCapable[RenderCapable["MSAA"] = 18] = "MSAA";
        RenderCapable[RenderCapable["UnifromBufferObject"] = 19] = "UnifromBufferObject";
        RenderCapable[RenderCapable["Texture3D"] = 20] = "Texture3D";
        RenderCapable[RenderCapable["Texture_FloatLinearFiltering"] = 21] = "Texture_FloatLinearFiltering";
        RenderCapable[RenderCapable["Texture_HalfFloatLinearFiltering"] = 22] = "Texture_HalfFloatLinearFiltering";
    })(exports.RenderCapable || (exports.RenderCapable = {}));

    const FOURCC_DXT1 = 827611204;
    const FOURCC_DXT3 = 861165636;
    const FOURCC_DXT4 = 877942852;
    const FOURCC_DXT5 = 894720068;
    const DDPF_FOURCC = 0x4;
    const DDPF_RGB = 0x40;
    const DDSCAPS2_CUBEMAP = 0x200;
    const DDPF_LUMINANCE = 0x20000;
    const DDSD_MIPMAPCOUNT = 0x20000;
    const DDS_MAGIC = 0x20534444;
    const DDS_HEADER_LENGTH = 31;
    const DDS_HEADER_MAGIC = 0;
    const DDS_HEADER_SIZE = 1;
    const DDS_HEADER_FLAGS = 2;
    const DDS_HEADER_HEIGHT = 3;
    const DDS_HEADER_WIDTH = 4;
    const DDS_HEADER_MIPMAPCOUNT = 7;
    const DDS_HEADER_PF_FLAGS = 20;
    const DDS_HEADER_PF_FOURCC = 21;
    const DDS_HEADER_PF_CAPS2 = 28;
    const FOURCC_D3DFMT_R16G16B16A16F = 113;
    const FOURCC_D3DFMT_R32G32B32A32F = 116;
    const Int32ToFourCC = (value) => {
        return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);
    };
    class DDSTextureInfo {
        constructor(width, height, mipmapCount, isCube, bpp, blockBytes, dataOffset, format, compressed, sourceData) {
            this.width = width;
            this.height = height;
            this.mipmapCount = mipmapCount;
            this.isCube = isCube;
            this.blockBytes = blockBytes;
            this.dataOffset = dataOffset;
            this.format = format;
            this.source = sourceData;
            this.bpp = bpp;
            this.compressed = compressed;
        }
        static getDDSTextureInfo(source) {
            let header = new Int32Array(source, 0, DDS_HEADER_LENGTH);
            let width = header[DDS_HEADER_WIDTH];
            let height = header[DDS_HEADER_HEIGHT];
            let mipmapCount = 1;
            if (header[DDS_HEADER_FLAGS] & DDSD_MIPMAPCOUNT) {
                mipmapCount = Math.max(1, header[DDS_HEADER_MIPMAPCOUNT]);
            }
            let fourCC = header[DDS_HEADER_PF_FOURCC];
            let isFourCC = (header[DDS_HEADER_PF_FLAGS] & DDPF_FOURCC) === DDPF_FOURCC;
            let isRGB = (header[DDS_HEADER_PF_FLAGS] & DDPF_RGB) === DDPF_RGB;
            let isLuminance = (header[DDS_HEADER_PF_FLAGS] & DDPF_LUMINANCE) === DDPF_LUMINANCE;
            let isCube = (header[DDS_HEADER_PF_CAPS2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP;
            let isCompressed = (fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5 || fourCC === FOURCC_DXT4);
            let layaTexFormat = exports.TextureFormat.DXT1;
            let dataOffset = header[DDS_HEADER_SIZE] + 4;
            let blockBytes = 1;
            switch (fourCC) {
                case FOURCC_DXT1:
                    layaTexFormat = exports.TextureFormat.DXT1;
                    blockBytes = 8;
                    break;
                case FOURCC_DXT3:
                    layaTexFormat = exports.TextureFormat.DXT3;
                    blockBytes = 16;
                    break;
                case FOURCC_DXT4:
                case FOURCC_DXT5:
                    layaTexFormat = exports.TextureFormat.DXT5;
                    blockBytes = 16;
                    break;
                case FOURCC_D3DFMT_R16G16B16A16F:
                    layaTexFormat = exports.TextureFormat.R16G16B16A16;
                    blockBytes = 4;
                    break;
                case FOURCC_D3DFMT_R32G32B32A32F:
                    layaTexFormat = exports.TextureFormat.R32G32B32A32;
                    blockBytes = 4;
                    break;
                default:
                    throw "Unsupported format " + Int32ToFourCC(fourCC);
            }
            if (header[DDS_HEADER_MAGIC] !== DDS_MAGIC) {
                throw "Invalid magic number in DDS header";
            }
            if (!isFourCC && !isRGB && !isLuminance) {
                throw "Unsupported format, must contain a FourCC, RGB or LUMINANCE code";
            }
            let ext = LayaGL.renderEngine.getCapable(exports.RenderCapable.COMPRESS_TEXTURE_S3TC) || LayaGL.renderEngine.getCapable(exports.RenderCapable.COMPRESS_TEXTURE_S3TC_SRGB);
            if (isCompressed && !ext) {
                throw "Compressed textures are not supported on this platform.";
            }
            return new DDSTextureInfo(width, height, mipmapCount, isCube, 0, blockBytes, dataOffset, layaTexFormat, isCompressed, source);
        }
    }

    const IdentifierByteSize = 12;
    const HeaderSize = 13;
    const COMPRESSED_RGB_ETC1_WEBGL = 36196;
    const COMPRESSED_RGB8_ETC2 = 37492;
    const COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494;
    const COMPRESSED_RGBA8_ETC2_EAC = 37496;
    const COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497;
    const COMPRESSED_SRGB8_ETC2 = 37493;
    const COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495;
    const COMPRESSED_RGBA_ASTC_4x4_KHR = 37808;
    const COMPRESSED_RGBA_ASTC_6x6_KHR = 37812;
    const COMPRESSED_RGBA_ASTC_8x8_KHR = 37815;
    const COMPRESSED_RGBA_ASTC_10x10_KHR = 37819;
    const COMPRESSED_RGBA_ASTC_12x12_KHR = 37821;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853;
    const GL_FORMAT_RGBA = 6408;
    const GL_FORMAT_RGB = 6407;
    const GL_FORMAT_RGBA32F = 0x8814;
    const GL_FORMAT_RGB32F = 0x8815;
    const GL_FORMAT_RGBA16F = 0x881A;
    const GL_FORMAT_RGB16F = 0x881B;
    const GL_FORMAT_SRGB8 = 0x8C41;
    const GL_INTERNALFORMAT_RGBA8 = 0x8058;
    const GL_INTERNALFORMAT_RGB8 = 0x8051;
    const GL_INTERNALFORMAT_SRGB8_ALPHA8 = 0x8C43;
    const GL_DATATYPE_UNSIGNED_BYTE = 0x1401;
    const GL_DATATYPE_FLOAT = 0x1406;
    const GL_DATATYPE_HALF_FLOAT = 0x140b;
    class KTXTextureInfo {
        static getLayaFormat(glFormat, glInternalFormat, glType, glTypeSize) {
            if (glFormat == 0) {
                switch (glInternalFormat) {
                    case COMPRESSED_RGB_ETC1_WEBGL:
                        return { format: exports.TextureFormat.ETC1RGB, sRGB: false };
                    case COMPRESSED_RGBA8_ETC2_EAC:
                        return { format: exports.TextureFormat.ETC2RGBA, sRGB: false };
                    case COMPRESSED_RGB8_ETC2:
                        return { format: exports.TextureFormat.ETC2RGB, sRGB: false };
                    case COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
                        return { format: exports.TextureFormat.ETC2SRGB_Alpha8, sRGB: true };
                    case COMPRESSED_SRGB8_ETC2:
                        return { format: exports.TextureFormat.ETC2SRGB, sRGB: true };
                    case COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
                        return { format: exports.TextureFormat.ETC2RGB_Alpha1, sRGB: false };
                    case COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
                        return { format: exports.TextureFormat.ETC2SRGB_Alpha1, sRGB: true };
                    case COMPRESSED_RGBA_ASTC_4x4_KHR:
                        return { format: exports.TextureFormat.ASTC4x4, sRGB: false };
                    case COMPRESSED_RGBA_ASTC_6x6_KHR:
                        return { format: exports.TextureFormat.ASTC6x6, sRGB: false };
                    case COMPRESSED_RGBA_ASTC_8x8_KHR:
                        return { format: exports.TextureFormat.ASTC8x8, sRGB: false };
                    case COMPRESSED_RGBA_ASTC_10x10_KHR:
                        return { format: exports.TextureFormat.ASTC10x10, sRGB: false };
                    case COMPRESSED_RGBA_ASTC_12x12_KHR:
                        return { format: exports.TextureFormat.ASTC12x12, sRGB: false };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:
                        return { format: exports.TextureFormat.ASTC4x4SRGB, sRGB: true };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:
                        return { format: exports.TextureFormat.ASTC6x6SRGB, sRGB: true };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:
                        return { format: exports.TextureFormat.ASTC8x8SRGB, sRGB: true };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:
                        return { format: exports.TextureFormat.ASTC10x10SRGB, sRGB: true };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:
                        return { format: exports.TextureFormat.ASTC12x12SRGB, sRGB: true };
                    default:
                        throw "KTX: UnSupported Compressed format.";
                }
            }
            else {
                if (glFormat == GL_FORMAT_RGBA && glInternalFormat == GL_INTERNALFORMAT_RGBA8 && glType == GL_DATATYPE_UNSIGNED_BYTE) {
                    return { format: exports.TextureFormat.R8G8B8A8, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGBA && glInternalFormat == GL_INTERNALFORMAT_SRGB8_ALPHA8 && glType == GL_DATATYPE_UNSIGNED_BYTE) {
                    return { format: exports.TextureFormat.R8G8B8A8, sRGB: true };
                }
                else if (glFormat == GL_FORMAT_RGBA && glInternalFormat == GL_FORMAT_RGBA32F && glType == GL_DATATYPE_FLOAT) {
                    return { format: exports.TextureFormat.R32G32B32A32, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGBA && glInternalFormat == GL_FORMAT_RGBA16F && glType == GL_DATATYPE_HALF_FLOAT) {
                    return { format: exports.TextureFormat.R16G16B16A16, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGB && glInternalFormat == GL_FORMAT_RGB32F && glType == GL_DATATYPE_FLOAT) {
                    return { format: exports.TextureFormat.R32G32B32, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGB && glInternalFormat == GL_FORMAT_RGB16F && glType == GL_DATATYPE_HALF_FLOAT) {
                    return { format: exports.TextureFormat.R16G16B16, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGB && glInternalFormat == GL_FORMAT_SRGB8 && glType == GL_DATATYPE_UNSIGNED_BYTE) {
                    return { format: exports.TextureFormat.R8G8B8, sRGB: true };
                }
                else if (glFormat == GL_FORMAT_RGB && glInternalFormat == GL_INTERNALFORMAT_RGB8 && glType == GL_DATATYPE_UNSIGNED_BYTE) {
                    return { format: exports.TextureFormat.R8G8B8, sRGB: false };
                }
                else {
                    throw "ktx: Unsupported UnCompressed image data.";
                }
            }
        }
        static getKTXTextureInfo(source) {
            let FileIdentifier = new Uint8Array(source, 0, 12);
            if (FileIdentifier[0] === 0xAB && FileIdentifier[1] === 0x4B && FileIdentifier[2] === 0x54 && FileIdentifier[3] === 0x58 && FileIdentifier[4] === 0x20 && FileIdentifier[5] === 0x32 && FileIdentifier[6] === 0x30 && FileIdentifier[7] === 0xBB && FileIdentifier[8] === 0x0D && FileIdentifier[9] === 0x0A && FileIdentifier[10] === 0x1A && FileIdentifier[11] === 0x0A) {
                throw "ktx2 !";
            }
            else if (FileIdentifier[0] === 0xAB && FileIdentifier[1] === 0x4B && FileIdentifier[2] === 0x54 && FileIdentifier[3] === 0x58 && FileIdentifier[4] === 0x20 && FileIdentifier[5] === 0x31 && FileIdentifier[6] === 0x31 && FileIdentifier[7] === 0xBB && FileIdentifier[8] === 0x0D && FileIdentifier[9] === 0x0A && FileIdentifier[10] === 0x1A && FileIdentifier[11] === 0x0A) {
                return KTXTextureInfo.createKTX1Info(source);
            }
            else {
                throw "ktx data wrong, not ktx1 or ktx2 buffer!";
            }
        }
        static createKTX1Info(source) {
            let dataSize = Uint32Array.BYTES_PER_ELEMENT;
            let headerDataView = new DataView(source, IdentifierByteSize, dataSize * HeaderSize);
            let endianness = headerDataView.getUint32(0, true);
            let littleEndian = endianness == 0x04030201;
            let glType = headerDataView.getUint32(1 * dataSize, littleEndian);
            let glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian);
            let glFormat = headerDataView.getUint32(3 * dataSize, littleEndian);
            let glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian);
            headerDataView.getUint32(5 * dataSize, littleEndian);
            let pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian);
            let pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian);
            headerDataView.getUint32(8 * dataSize, littleEndian);
            let numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian);
            let numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian);
            let numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian);
            let bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian);
            let formatInfo = KTXTextureInfo.getLayaFormat(glFormat, glInternalFormat, glType, glTypeSize);
            let layaFormat = formatInfo.format;
            let sRGBData = formatInfo.sRGB;
            let layaDemision = exports.TextureDimension.Tex2D;
            if (numberOfFaces > 1 && numberOfArrayElements > 1) {
                layaDemision = exports.TextureDimension.CubeArray;
            }
            else if (numberOfFaces > 1 && numberOfArrayElements <= 1) {
                layaDemision = exports.TextureDimension.Cube;
            }
            else if (numberOfFaces <= 1 && numberOfArrayElements > 1) {
                layaDemision = exports.TextureDimension.Texture2DArray;
            }
            let headerOffset = IdentifierByteSize + HeaderSize * 4;
            return new KTXTextureInfo(source, glFormat == 0, sRGBData, layaDemision, pixelWidth, pixelHeight, layaFormat, numberOfMipmapLevels || 1, bytesOfKeyValueData, headerOffset);
        }
        constructor(source, compress, sRGB, dimension, width, height, format, mipmapCount, bytesOfKeyValueData, headerOffset) {
            this.source = source;
            this.compress = compress;
            this.sRGB = sRGB;
            this.dimension = dimension;
            this.width = width;
            this.height = height;
            this.format = format;
            this.mipmapCount = mipmapCount;
            this.bytesOfKeyValueData = bytesOfKeyValueData;
            this.headerOffset = headerOffset;
        }
    }

    class Texture2D extends BaseTexture {
        static __init__() {
            var pixels = new Uint8Array(4);
            pixels[0] = 128;
            pixels[1] = 128;
            pixels[2] = 128;
            pixels[3] = 255;
            Texture2D.grayTexture = new Texture2D(1, 1, exports.TextureFormat.R8G8B8A8, false, false);
            Texture2D.grayTexture.setPixelsData(pixels, false, false);
            Texture2D.grayTexture.lock = true;
            Texture2D.grayTexture.name = "Default_Gray";
            pixels[0] = 255;
            pixels[1] = 255;
            pixels[2] = 255;
            pixels[3] = 255;
            Texture2D.whiteTexture = new Texture2D(1, 1, exports.TextureFormat.R8G8B8A8, false, false);
            Texture2D.whiteTexture.setPixelsData(pixels, false, false);
            Texture2D.whiteTexture.lock = true;
            Texture2D.whiteTexture.name = "Default_White";
            pixels[0] = 0;
            pixels[1] = 0;
            pixels[2] = 0;
            pixels[3] = 255;
            Texture2D.blackTexture = new Texture2D(1, 1, exports.TextureFormat.R8G8B8A8, false, false);
            Texture2D.blackTexture.setPixelsData(pixels, false, false);
            Texture2D.blackTexture.lock = true;
            Texture2D.blackTexture.name = "Default_Black";
            if (LayaGL.renderEngine.getCapable(exports.RenderCapable.TextureFormat_R16G16B16A16)) {
                let floatPixle = new Uint16Array(4);
                floatPixle[0] = 14336;
                floatPixle[1] = 14336;
                floatPixle[2] = 15360;
                floatPixle[3] = 15360;
                Texture2D.normalTexture = new Texture2D(1, 1, exports.TextureFormat.R16G16B16A16, false, false, false);
                Texture2D.normalTexture.setPixelsData(floatPixle, false, false);
            }
            else {
                pixels[0] = 128;
                pixels[1] = 128;
                pixels[2] = 255;
                pixels[3] = 255;
                Texture2D.normalTexture = new Texture2D(1, 1, exports.TextureFormat.R8G8B8A8, false, false, false);
                Texture2D.normalTexture.setPixelsData(pixels, false, false);
            }
            Texture2D.normalTexture.lock = true;
            Texture2D.normalTexture.name = "Default_Normal";
            Texture2D.errorTexture = Texture2D.whiteTexture;
        }
        static _SimpleAnimatorTextureParse(data, propertyParams = null, constructParams = null) {
            var byte = new Byte(data);
            var version = byte.readUTFString();
            var texture;
            var pixelDataArrays;
            var usePixelData;
            switch (version) {
                case "LAYAANIMATORTEXTURE:0000":
                    var textureWidth = byte.readInt32();
                    var pixelDataLength = byte.readInt32();
                    pixelDataArrays = new Float32Array(textureWidth * textureWidth * 4);
                    usePixelData = new Float32Array(byte.readArrayBuffer(pixelDataLength * 4));
                    pixelDataArrays.set(usePixelData, 0);
                    var texture = new Texture2D(textureWidth, textureWidth, exports.TextureFormat.R32G32B32A32, false, false);
                    texture.setPixelsData(pixelDataArrays, false, false);
                    texture.filterMode = exports.FilterMode.Point;
                    break;
                case "LAYACOMPRESSANIMATORTEXTURE:0000":
                    var textureWidth = byte.readInt32();
                    var pixelDataLength = byte.readInt32();
                    pixelDataArrays = new Uint16Array(byte.readArrayBuffer(pixelDataLength * 2));
                    if (!LayaGL.renderEngine.getCapable(exports.RenderCapable.TextureFormat_R16G16B16A16)) {
                        console.log("The platform does not support 16-bit floating-point textures");
                        if (!LayaGL.renderEngine.getCapable(exports.RenderCapable.TextureFormat_R32G32B32A32))
                            console.error("The platform does not support 32-bit floating-point textures");
                        usePixelData = new Float32Array(textureWidth * textureWidth * 4);
                        for (var i = 0, n = pixelDataArrays.length; i < n; i++) {
                            usePixelData[i] = HalfFloatUtils.convertToNumber(pixelDataArrays[i]);
                        }
                        texture = new Texture2D(textureWidth, textureWidth, exports.TextureFormat.R32G32B32A32, false, false);
                        texture.setPixelsData(usePixelData, false, false);
                        texture.filterMode = exports.FilterMode.Point;
                    }
                    else {
                        usePixelData = new Uint16Array(textureWidth * textureWidth * 4);
                        usePixelData.set(pixelDataArrays, 0);
                        texture = new Texture2D(textureWidth, textureWidth, exports.TextureFormat.R16G16B16A16, false, false);
                        texture.setPixelsData(usePixelData, false, false);
                        texture.filterMode = exports.FilterMode.Point;
                    }
                    break;
                default:
                    throw "Laya3D:unknow version.";
            }
            return texture;
        }
        static _parseImage(imageSource, propertyParams = null, constructParams = null) {
            let format = constructParams ? constructParams[2] : exports.TextureFormat.R8G8B8A8;
            let mipmap = constructParams ? constructParams[3] : true;
            let canread = constructParams ? constructParams[4] : false;
            let srgb = constructParams ? constructParams[5] : false;
            let pma = propertyParams ? propertyParams.premultiplyAlpha : false;
            let texture = new Texture2D(imageSource.width, imageSource.height, format, mipmap, canread, srgb, pma);
            if (propertyParams) {
                texture.setImageData(imageSource, pma, false);
                texture.setProperties(propertyParams);
            }
            else
                texture.setImageData(imageSource, false, false);
            if (canread) {
                if (LayaEnv.isConch && imageSource._nativeObj) {
                    texture._pixels = new Uint8Array(imageSource._nativeObj.getImageData(0, 0, imageSource.width, imageSource.height));
                }
                else {
                    ILaya.Browser.canvas.size(imageSource.width, imageSource.height);
                    ILaya.Browser.canvas.clear();
                    ILaya.Browser.context.drawImage(imageSource, 0, 0, imageSource.width, imageSource.height);
                    texture._pixels = new Uint8Array(ILaya.Browser.context.getImageData(0, 0, imageSource.width, imageSource.height).data.buffer);
                }
            }
            return texture;
        }
        static _parseDDS(data, propertyParams = null, constructParams = null) {
            let ddsInfo = DDSTextureInfo.getDDSTextureInfo(data);
            let sRGB = constructParams[5];
            let texture = new Texture2D(ddsInfo.width, ddsInfo.height, ddsInfo.format, ddsInfo.mipmapCount > 1, false, sRGB);
            texture.setDDSData(ddsInfo);
            if (propertyParams)
                texture.setProperties(propertyParams);
            return texture;
        }
        static _parseKTX(data, propertyParams = null, constructParams = null) {
            let ktxInfo = KTXTextureInfo.getKTXTextureInfo(data);
            let texture = new Texture2D(ktxInfo.width, ktxInfo.height, ktxInfo.format, ktxInfo.mipmapCount > 1, false, ktxInfo.sRGB);
            texture.setKTXData(ktxInfo);
            if (propertyParams)
                texture.setProperties(propertyParams);
            return texture;
        }
        static _parsePVR(data, propertyParams = null, constructParams = null) {
            throw "pvr !";
        }
        static load(url, complete) {
            ILaya.loader.load(url, complete, null, ILaya.Loader.TEXTURE2D);
        }
        constructor(width, height, format, mipmap = true, canRead, sRGB = false, premultiplyAlpha = false) {
            super(width, height, format);
            this._canRead = false;
            this._premultiplyAlpha = false;
            this._dimension = exports.TextureDimension.Tex2D;
            this._gammaSpace = sRGB;
            this._canRead = canRead;
            this._premultiplyAlpha = premultiplyAlpha;
            this._texture = LayaGL.textureContext.createTextureInternal(this._dimension, width, height, format, mipmap, sRGB, premultiplyAlpha);
            return;
        }
        setImageData(source, premultiplyAlpha, invertY) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureImageData(texture, source, premultiplyAlpha, invertY);
        }
        setPixelsData(source, premultiplyAlpha, invertY) {
            let texture = this._texture;
            LayaGL.textureContext.setTexturePixelsData(texture, source, premultiplyAlpha, invertY);
        }
        setSubPixelsData(xOffset, yOffset, width, height, pixels, mipmapLevel, generateMipmap, premultiplyAlpha, invertY) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureSubPixelsData(texture, pixels, mipmapLevel, generateMipmap, xOffset, yOffset, width, height, premultiplyAlpha, invertY);
        }
        setDDSData(ddsInfo) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureDDSData(texture, ddsInfo);
        }
        setKTXData(ktxInfo) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureKTXData(texture, ktxInfo);
        }
        setHDRData(hdrInfo) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureHDRData(texture, hdrInfo);
        }
        get defaultTexture() {
            return Texture2D.grayTexture;
        }
        getPixels() {
            if (this._canRead && this._pixels) {
                return this._pixels;
            }
            else {
                throw new Error("Texture2D: must set texture canRead is true.");
            }
        }
        setProperties(propertyParams) {
            if (propertyParams) {
                if (propertyParams.wrapModeU != null)
                    this.wrapModeU = propertyParams.wrapModeU;
                if (propertyParams.wrapModeV != null)
                    this.wrapModeV = propertyParams.wrapModeV;
                if (propertyParams.filterMode != null)
                    this.filterMode = propertyParams.filterMode;
                if (propertyParams.anisoLevel != null)
                    this.anisoLevel = propertyParams.anisoLevel;
            }
        }
    }
    Texture2D.TEXTURE2D = "TEXTURE2D";
    Texture2D.grayTexture = null;
    Texture2D.whiteTexture = null;
    Texture2D.blackTexture = null;
    Texture2D.normalTexture = null;
    Texture2D.errorTexture = null;

    class Color {
        static gammaToLinearSpace(value) {
            if (value <= 0.04045)
                return value / 12.92;
            else if (value < 1.0)
                return Math.pow((value + 0.055) / 1.055, 2.4);
            else
                return Math.pow(value, 2.4);
        }
        static linearToGammaSpace(value) {
            if (value <= 0.0)
                return 0.0;
            else if (value <= 0.0031308)
                return 12.92 * value;
            else if (value <= 1.0)
                return 1.055 * Math.pow(value, 0.41666) - 0.055;
            else
                return Math.pow(value, 0.41666);
        }
        constructor(r = 1, g = 1, b = 1, a = 1) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
        equal(c) {
            if (!c)
                return false;
            const toFIxed = (a, b) => {
                var delta = 1e-5;
                return -delta < a - b && a - b < delta;
            };
            return toFIxed(c.r, this.r) && toFIxed(c.g, this.g) && toFIxed(c.b, this.b) && toFIxed(c.a, this.a);
        }
        toLinear(out) {
            out.r = Color.gammaToLinearSpace(this.r);
            out.g = Color.gammaToLinearSpace(this.g);
            out.b = Color.gammaToLinearSpace(this.b);
            out.a = this.a;
        }
        toGamma(out) {
            out.r = Color.linearToGammaSpace(this.r);
            out.g = Color.linearToGammaSpace(this.g);
            out.b = Color.linearToGammaSpace(this.b);
            out.a = this.a;
        }
        cloneTo(destObject) {
            destObject.r = this.r;
            destObject.g = this.g;
            destObject.b = this.b;
            destObject.a = this.a;
        }
        scale(value) {
            this.r = this.r * value;
            this.g = this.g * value;
            this.b = this.b * value;
            return this;
        }
        setValue(r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
        fromArray(array, offset = 0) {
            this.r = array[offset + 0];
            this.g = array[offset + 1];
            this.b = array[offset + 2];
            this.a = array[offset + 3];
        }
        toArray() {
            return [this.r, this.g, this.b, this.a];
        }
        clone() {
            var dest = new Color();
            this.cloneTo(dest);
            return dest;
        }
    }
    Color.RED = new Color(1, 0, 0, 1);
    Color.GREEN = new Color(0, 1, 0, 1);
    Color.BLUE = new Color(0, 0, 1, 1);
    Color.CYAN = new Color(0, 1, 1, 1);
    Color.YELLOW = new Color(1, 0.92, 0.016, 1);
    Color.MAGENTA = new Color(1, 0, 1, 1);
    Color.GRAY = new Color(0.5, 0.5, 0.5, 1);
    Color.WHITE = new Color(1, 1, 1, 1);
    Color.BLACK = new Color(0, 0, 0, 1);
    Color.CLEAR = new Color(0, 0, 0, 0);

    class RenderTexture2D extends BaseTexture {
        static get currentActive() {
            return RenderTexture2D._currentActive;
        }
        get depthStencilFormat() {
            return this._depthStencilFormat;
        }
        get defaultTexture() {
            return Texture2D.grayTexture;
        }
        getIsReady() {
            return true;
        }
        getColorFormat() {
            return this._colorFormat;
        }
        get sourceWidth() {
            return this._width;
        }
        get sourceHeight() {
            return this._height;
        }
        get offsetX() {
            return 0;
        }
        get offsetY() {
            return 0;
        }
        constructor(width, height, format = exports.RenderTargetFormat.R8G8B8, depthStencilFormat = exports.RenderTargetFormat.None) {
            super(width, height, format);
            this._mgrKey = 0;
            this._invertY = false;
            this._colorFormat = format;
            this._depthStencilFormat = depthStencilFormat;
            if (width != 0 && height != 0) {
                this._create();
            }
            this.lock = true;
        }
        get isCube() {
            return this._renderTarget._isCube;
        }
        get samples() {
            return this._renderTarget._samples;
        }
        get generateMipmap() {
            return this._renderTarget._generateMipmap;
        }
        _start() {
            throw new NotImplementedError();
        }
        _end() {
            throw new NotImplementedError();
        }
        _create() {
            this._renderTarget = LayaGL.textureContext.createRenderTargetInternal(this.width, this.height, this._colorFormat, this.depthStencilFormat, false, false, 1);
            this._texture = this._renderTarget._textures[0];
            this._texture.gammaCorrection = 2.2;
        }
        clear(r = 0.0, g = 0.0, b = 0.0, a = 1.0) {
            RenderTexture2D._clearColor.r = r;
            RenderTexture2D._clearColor.g = g;
            RenderTexture2D._clearColor.b = b;
            RenderTexture2D._clearColor.a = a;
            RenderTexture2D._clear = true;
        }
        getData(x, y, width, height) {
            const pixelCount = width * height * 4;
            let pixelArray;
            switch (this._renderTarget.colorFormat) {
                case exports.RenderTargetFormat.R8G8B8:
                case exports.RenderTargetFormat.R8G8B8A8:
                    pixelArray = new Uint8Array(pixelCount);
                    break;
                case exports.RenderTargetFormat.R16G16B16A16:
                    pixelArray = new Float32Array(pixelCount);
                    break;
                default:
                    throw "this function is not surpprt " + this._renderTarget.colorFormat.toString() + "format Material";
            }
            LayaGL.textureContext.readRenderTargetPixelData(this._renderTarget, x, y, width, height, pixelArray);
            return pixelArray;
        }
        getDataAsync(xOffset, yOffset, width, height, out) {
            return LayaGL.textureContext.readRenderTargetPixelDataAsync(this._renderTarget, xOffset, yOffset, width, height, out);
        }
        recycle() {
        }
        _disposeResource() {
            this._renderTarget && this._renderTarget.dispose();
        }
    }
    RenderTexture2D._clearColor = new Color(0, 0, 0, 0);
    RenderTexture2D._clear = false;
    RenderTexture2D._clearLinearColor = new Color();
    RenderTexture2D.defuv = [0, 0, 1, 0, 1, 1, 0, 1];
    RenderTexture2D.flipyuv = [0, 1, 1, 1, 1, 0, 0, 0];

    const _rect1 = new Rectangle();
    const _rect2 = new Rectangle();
    class Texture extends Resource {
        static create(source, x, y, width, height, offsetX = 0, offsetY = 0, sourceWidth = 0, sourceHeight = 0) {
            return Texture._create(source, x, y, width, height, offsetX, offsetY, sourceWidth, sourceHeight);
        }
        static _create(source, x, y, width, height, offsetX = 0, offsetY = 0, sourceWidth = 0, sourceHeight = 0, outTexture = null) {
            var btex = source instanceof Texture;
            var uv = btex ? source.uv : Texture.DEF_UV;
            var bitmap = btex ? source.bitmap : source;
            if (bitmap.width && (x + width) > bitmap.width)
                width = bitmap.width - x;
            if (bitmap.height && (y + height) > bitmap.height)
                height = bitmap.height - y;
            var tex;
            if (outTexture) {
                tex = outTexture;
                tex.setTo(bitmap, null, sourceWidth || width, sourceHeight || height);
            }
            else {
                tex = new Texture(bitmap, null, sourceWidth || width, sourceHeight || height);
            }
            tex.width = width;
            tex.height = height;
            tex.offsetX = offsetX;
            tex.offsetY = offsetY;
            var dwidth = 1 / bitmap.width;
            var dheight = 1 / bitmap.height;
            x *= dwidth;
            y *= dheight;
            width *= dwidth;
            height *= dheight;
            var u1 = tex.uv[0], v1 = tex.uv[1], u2 = tex.uv[4], v2 = tex.uv[5];
            var inAltasUVWidth = (u2 - u1), inAltasUVHeight = (v2 - v1);
            var oriUV = moveUV(uv[0], uv[1], [x, y, x + width, y, x + width, y + height, x, y + height]);
            tex.uv = new Float32Array([u1 + oriUV[0] * inAltasUVWidth, v1 + oriUV[1] * inAltasUVHeight,
                u2 - (1 - oriUV[2]) * inAltasUVWidth, v1 + oriUV[3] * inAltasUVHeight,
                u2 - (1 - oriUV[4]) * inAltasUVWidth, v2 - (1 - oriUV[5]) * inAltasUVHeight,
                u1 + oriUV[6] * inAltasUVWidth, v2 - (1 - oriUV[7]) * inAltasUVHeight]);
            var bitmapScale = source.scaleRate;
            if (bitmapScale && bitmapScale != 1) {
                tex.sourceWidth /= bitmapScale;
                tex.sourceHeight /= bitmapScale;
                tex.width /= bitmapScale;
                tex.height /= bitmapScale;
                tex.scaleRate = bitmapScale;
                tex.offsetX /= bitmapScale;
                tex.offsetY /= bitmapScale;
            }
            else {
                tex.scaleRate = 1;
            }
            return tex;
        }
        static createFromTexture(texture, x, y, width, height) {
            var texScaleRate = texture.scaleRate;
            if (texScaleRate != 1) {
                x *= texScaleRate;
                y *= texScaleRate;
                width *= texScaleRate;
                height *= texScaleRate;
            }
            var rect = Rectangle.TEMP.setTo(x - texture.offsetX, y - texture.offsetY, width, height);
            var result = rect.intersection(_rect1.setTo(0, 0, texture.width, texture.height), _rect2);
            if (result)
                return Texture.create(texture, result.x, result.y, result.width, result.height, result.x - rect.x, result.y - rect.y, width, height);
            else
                return null;
        }
        get uv() {
            return this._uv;
        }
        set uv(value) {
            this.uvrect[0] = Math.min(value[0], value[2], value[4], value[6]);
            this.uvrect[1] = Math.min(value[1], value[3], value[5], value[7]);
            this.uvrect[2] = Math.max(value[0], value[2], value[4], value[6]) - this.uvrect[0];
            this.uvrect[3] = Math.max(value[1], value[3], value[5], value[7]) - this.uvrect[1];
            this._uv = value;
        }
        get width() {
            if (this._w)
                return this._w;
            if (!this.bitmap)
                return 0;
            return (this.uv && this.uv !== Texture.DEF_UV) ? (this.uv[2] - this.uv[0]) * this.bitmap.width : this.bitmap.width;
        }
        set width(value) {
            this._w = value;
            this.sourceWidth || (this.sourceWidth = value);
        }
        get height() {
            if (this._h)
                return this._h;
            if (!this.bitmap)
                return 0;
            return (this.uv && this.uv !== Texture.DEF_UV) ? (this.uv[5] - this.uv[1]) * this.bitmap.height : this.bitmap.height;
        }
        set height(value) {
            this._h = value;
            this.sourceHeight || (this.sourceHeight = value);
        }
        get bitmap() {
            return this._bitmap;
        }
        set bitmap(value) {
            if (this._bitmap == value)
                return;
            this._bitmap && this._bitmap._removeReference(this._referenceCount);
            this._bitmap = value;
            value && (value._addReference(this._referenceCount));
        }
        constructor(source = null, uv = null, sourceWidth = 0, sourceHeight = 0) {
            super(false);
            this.uvrect = [0, 0, 1, 1];
            this._w = 0;
            this._h = 0;
            this.offsetX = 0;
            this.offsetY = 0;
            this.sourceWidth = 0;
            this.sourceHeight = 0;
            this.scaleRate = 1;
            let bitmap = (source instanceof Texture) ? source.bitmap : source;
            this.setTo(bitmap, uv, sourceWidth, sourceHeight);
        }
        _addReference(count = 1) {
            var _a, _b;
            super._addReference(count);
            (_a = this._bitmap) === null || _a === void 0 ? void 0 : _a._addReference(count);
            (_b = this._atlas) === null || _b === void 0 ? void 0 : _b._addReference(count);
        }
        _removeReference(count = 1) {
            var _a, _b;
            (_a = this._bitmap) === null || _a === void 0 ? void 0 : _a._removeReference(count);
            (_b = this._atlas) === null || _b === void 0 ? void 0 : _b._removeReference(count);
            super._removeReference(count);
        }
        _getSource(cb = null) {
            if (this._destroyed || !this._bitmap)
                return null;
            this.recoverBitmap(cb);
            return this._bitmap.destroyed ? null : this.bitmap._getSource();
        }
        setTo(bitmap = null, uv = null, sourceWidth = 0, sourceHeight = 0) {
            this.bitmap = bitmap;
            this.sourceWidth = sourceWidth;
            this.sourceHeight = sourceHeight;
            if (bitmap) {
                this._w = bitmap.width;
                this._h = bitmap.height;
                this.sourceWidth = this.sourceWidth || bitmap.width;
                this.sourceHeight = this.sourceHeight || bitmap.height;
            }
            this.uv = uv || Texture.DEF_UV;
        }
        load(url, complete) {
            if (this._destroyed)
                return Promise.resolve();
            return ILaya.loader.load(url).then((tex) => {
                let bit = tex.bitmap;
                this.bitmap = bit;
                this.sourceWidth = this._w = bit.width;
                this.sourceHeight = this._h = bit.height;
                complete && complete.run();
                this.event(Event.READY, this);
            });
        }
        getTexturePixels(x, y, width, height) {
            var st, dst, i;
            var tex2d = this.bitmap;
            var texw = this._w;
            var texh = this._h;
            var sourceWidth = this.sourceWidth;
            var sourceHeight = this.sourceHeight;
            var tex2dw = tex2d.width;
            var tex2dh = tex2d.height;
            var offsetX = this.offsetX;
            var offsetY = this.offsetY;
            let draww = width;
            let drawh = height;
            if (x + width > texw + offsetX)
                draww -= (x + width) - texw - offsetX;
            if (x + width > sourceWidth)
                width -= (x + width) - sourceWidth;
            if (y + height > texh + offsetY)
                drawh -= (y + height) - texh - offsetY;
            if (y + height > sourceHeight)
                height -= (y + height) - sourceHeight;
            if (width <= 0 || height <= 0)
                return null;
            let marginL = offsetX > x ? offsetX - x : 0;
            let marginT = offsetY > y ? offsetY - y : 0;
            let rePosX = x > offsetX ? x - offsetX : 0;
            let rePosY = y > offsetY ? y - offsetY : 0;
            draww -= marginL;
            drawh -= marginT;
            var wstride = width * 4;
            var pix = null;
            try {
                pix = tex2d.getPixels();
            }
            catch (e) {
            }
            if (pix) {
                if (x == 0 && y == 0 && width == tex2dw && height == tex2dh)
                    return pix;
                let uv = this._uv.slice();
                let atlasPosX = Math.round(uv[0] * tex2dw);
                let atlasPosY = Math.round(uv[1] * tex2dh);
                var ret = new Uint8Array(width * height * 4);
                wstride = tex2dw * 4;
                dst = (atlasPosY + rePosY) * wstride;
                st = atlasPosX * 4 + rePosX * 4 + dst;
                for (i = 0; i < drawh; i++) {
                    ret.set(pix.slice(st, st + draww * 4), width * 4 * (i + marginT) + marginL * 4);
                    st += wstride;
                }
                return ret;
            }
            var ctx = new ILaya.Context();
            ctx.size(width, height);
            let rt = new RenderTexture2D(width, height, exports.RenderTargetFormat.R8G8B8A8);
            ctx.render2D = ctx.render2D.clone(rt);
            var uv = null;
            if (x != 0 || y != 0 || width != tex2dw || height != tex2dh) {
                uv = this._uv.slice();
                var stu = uv[0];
                var stv = uv[1];
                var uvw = uv[2] - stu;
                var uvh = uv[7] - stv;
                var uk = uvw / texw;
                var vk = uvh / texh;
                uv = [stu + rePosX * uk, stv + rePosY * vk,
                    stu + (rePosX + draww) * uk, stv + rePosY * vk,
                    stu + (rePosX + draww) * uk, stv + (rePosY + drawh) * vk,
                    stu + rePosX * uk, stv + (rePosY + drawh) * vk];
            }
            ctx.startRender();
            ctx._drawTextureM(this, marginL, marginT, draww, drawh, null, 1.0, uv, 0xffffffff);
            ctx.endRender();
            var dt = rt.getData(0, 0, width, height);
            ctx.destroy();
            rt.destroy();
            ret = new Uint8Array(width * height * 4);
            st = 0;
            dst = (height - 1) * wstride;
            for (i = height - 1; i >= 0; i--) {
                ret.set(dt.slice(dst, dst + wstride), st);
                st += wstride;
                dst -= wstride;
            }
            return ret;
        }
        getPixels(x, y, width, height) {
            return this.getTexturePixels(x, y, width, height);
        }
        recoverBitmap(callback) {
            var url = this._bitmap.url;
            if (!this._destroyed && (!this._bitmap || this._bitmap.destroyed) && url) {
                ILaya.loader.load(url, Loader.IMAGE).then((tex) => {
                    this.bitmap = tex.bitmap;
                    callback && callback();
                });
            }
        }
        disposeBitmap() {
            if (!this._destroyed && this._bitmap) {
                this._bitmap.destroy();
            }
        }
        get valid() {
            return !this._destroyed && this._bitmap && !this._bitmap.destroyed;
        }
        get obsolute() {
            return this._obsolute || !this._bitmap || this._bitmap.destroyed || this._bitmap.obsolute;
        }
        set obsolute(value) {
            this._obsolute = value;
        }
        _disposeResource() {
            let bit = this._bitmap;
            this._bitmap = null;
            if (bit)
                bit._removeReference(this._referenceCount);
            let atlas = this._atlas;
            this._atlas = null;
            if (atlas)
                atlas._removeReference(this._referenceCount);
        }
        getCachedClip(x, y, width, height) {
            if (this.destroyed)
                return null;
            let key = `${x}_${y}_${width}_${height}`;
            if (!this._clipCache)
                this._clipCache = new Map();
            let tex = this._clipCache.get(key);
            if (tex)
                return tex;
            tex = Texture.createFromTexture(this, x, y, width, height);
            if (tex)
                tex._sizeGrid = this._sizeGrid;
            if (this._clipCache.size > 100)
                this._clipCache.clear();
            this._clipCache.set(key, tex);
            return tex;
        }
    }
    Texture.DEF_UV = new Float32Array([0, 0, 1.0, 0, 1.0, 1.0, 0, 1.0]);
    Texture.NO_UV = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0]);
    Texture.INV_UV = new Float32Array([0, 1, 1.0, 1, 1.0, 0.0, 0, 0.0]);
    function moveUV(offsetX, offsetY, uv) {
        for (var i = 0; i < 8; i += 2) {
            uv[i] += offsetX;
            uv[i + 1] += offsetY;
        }
        return uv;
    }

    class AtlasInfoManager {
        static enable(infoFile, callback = null) {
            ILaya.loader.fetch(infoFile, "json").then(data => {
                if (!data)
                    return;
                AtlasInfoManager.addAtlases(data);
                callback && callback.run();
            });
        }
        static addAtlases(data) {
            let dic = AtlasInfoManager._fileLoadDic;
            for (let key in data) {
                let arr = data[key];
                let prefix = URL.formatURL(arr[0]);
                let frames = arr[1];
                let len = frames.length;
                let entry = { url: key };
                for (let i = 0; i < len; i++) {
                    dic[prefix + frames[i]] = entry;
                }
            }
        }
        static addAtlas(atlasUrl, prefix, frames) {
            prefix = URL.formatURL(prefix);
            let dic = AtlasInfoManager._fileLoadDic;
            let entry = { url: atlasUrl };
            for (let i of frames) {
                dic[prefix + i] = entry;
            }
        }
        static getFileLoadPath(file) {
            return AtlasInfoManager._fileLoadDic[file];
        }
    }
    AtlasInfoManager._fileLoadDic = {};

    class WorkerLoader {
        static workerSupported() {
            return Worker ? true : false;
        }
        static get enable() {
            return WorkerLoader._enable;
        }
        static set enable(value) {
            if (WorkerLoader._enable != value) {
                if (value) {
                    if (!Worker)
                        return;
                    if (!WorkerLoader._worker) {
                        WorkerLoader._worker = new Worker(PlayerConfig.workerLoaderLib || WorkerLoader.workerPath);
                        WorkerLoader._worker.onmessage = WorkerLoader.workerMessage;
                        WorkerLoader._dispatcher = new EventDispatcher();
                    }
                }
                WorkerLoader._enable = value;
            }
        }
        static load(url, options) {
            return new Promise((resolve, reject) => {
                WorkerLoader._worker.postMessage({ url, options });
                WorkerLoader._dispatcher.once(url, (data) => {
                    if (data.imageBitmap)
                        resolve(data.imageBitmap);
                    else
                        reject(data.msg);
                });
            });
        }
        static workerMessage(evt) {
            let data = evt.data;
            if (data) {
                switch (data.type) {
                    case "Image":
                        WorkerLoader._dispatcher.event(data.url, data);
                        break;
                    case "Disable":
                        WorkerLoader.enable = false;
                        break;
                }
            }
        }
    }
    WorkerLoader.workerPath = "libs/laya.workerloader.js";
    WorkerLoader._enable = false;

    class AtlasResource extends Resource {
        constructor(dir, textures, frames) {
            super();
            this.dir = dir;
            this.textures = textures;
            this.frames = frames;
            for (let tex of frames) {
                tex._addReference();
                tex._atlas = this;
            }
            for (let tex of textures) {
                tex._addReference();
                tex._atlas = this;
            }
        }
        _disposeResource() {
            for (let tex of this.textures) {
                tex._atlas = null;
                tex._removeReference();
            }
            for (let tex of this.frames) {
                tex._atlas = null;
                tex._removeReference();
            }
            this.frames.length = 0;
            this.textures.length = 0;
        }
    }

    class BatchProgress {
        constructor(callback) {
            this._callback = callback;
            this._items = [];
            this._weights = [];
            this._progress = 0;
        }
        get itemCount() {
            return this._items.length;
        }
        reset() {
            this._items.length = 0;
            this._weights.length = 0;
            this._progress = 0;
        }
        createCallback(weight) {
            let index = this._items.length;
            this._items.push(0);
            if (weight == null)
                this._weights.push(null);
            else
                this._weights.push(Math.max(0, Math.min(weight, 1)));
            return (progress) => this.update(index, progress);
        }
        update(index, value) {
            if (index != -1) {
                this._items[index] = Math.max(0, Math.min(value, 1));
                let np = 0;
                let col = this._items;
                let ws = this._weights;
                let perc = 1 / col.length;
                for (let i = 0; i < col.length; i++) {
                    let p = col[i];
                    let w = ws[i];
                    if (p != null)
                        np += p * (w != null ? w : perc);
                }
                value = np;
                if (value > 1)
                    value = 1;
            }
            if (value > this._progress) {
                this._progress = value;
                this._callback(value);
            }
        }
    }

    class Handler {
        constructor(caller = null, method = null, args = null, once = false) {
            this.once = false;
            this._id = 0;
            this.setTo(caller, method, args, once);
        }
        setTo(caller, method, args, once = false) {
            this._id = Handler._gid++;
            this.caller = caller;
            this.method = method;
            this.args = args;
            this.once = once;
            return this;
        }
        run() {
            if (this.method == null)
                return null;
            var id = this._id;
            var result = this.method.apply(this.caller, this.args);
            this._id === id && this.once && this.recover();
            return result;
        }
        runWith(data) {
            if (this.method == null)
                return null;
            var id = this._id;
            if (data == null)
                var result = this.method.apply(this.caller, this.args);
            else if (!this.args && !data.unshift)
                result = this.method.call(this.caller, data);
            else if (this.args)
                result = this.method.apply(this.caller, this.args.concat(data));
            else
                result = this.method.apply(this.caller, data);
            this._id === id && this.once && this.recover();
            return result;
        }
        clear() {
            this.caller = null;
            this.method = null;
            this.args = null;
            return this;
        }
        recover() {
            if (this._id > 0) {
                this._id = 0;
                Handler._pool.push(this.clear());
            }
        }
        static create(caller, method, args = null, once = true) {
            if (Handler._pool.length)
                return Handler._pool.pop().setTo(caller, method, args, once);
            return new Handler(caller, method, args, once);
        }
    }
    Handler._pool = [];
    Handler._gid = 1;

    class ImgUtils {
        static compareVersion(curVersion, needVersion) {
            let curVersionArr = curVersion.split('.');
            let needVersionArr = needVersion.split('.');
            const len = Math.max(curVersionArr.length, needVersionArr.length);
            while (curVersionArr.length < len) {
                curVersionArr.push('0');
            }
            while (needVersionArr.length < len) {
                needVersionArr.push('0');
            }
            for (let i = 0; i < len; i++) {
                const num1 = parseInt(curVersionArr[i]);
                const num2 = parseInt(needVersionArr[i]);
                if (num1 > num2) {
                    return true;
                }
                else if (num1 < num2) {
                    return false;
                }
            }
            return true;
        }
        static get isSupport() {
            if (Browser._isMiniGame) {
                var version = Browser.window.wx.getSystemInfoSync().SDKVersion;
                return ImgUtils.compareVersion(version, '2.14.0');
            }
            else if (Browser.onLayaRuntime) {
                return true;
            }
            else if (Browser.window.Blob)
                return Browser.window.Blob ? true : false;
            return false;
        }
        static arrayBufferToURL(url, arrayBuffer) {
            if (!ImgUtils.isSupport)
                return url;
            if (ImgUtils.data[url])
                return ImgUtils.data[url];
            var newurl = "";
            if (Browser._isMiniGame || Browser.onLayaRuntime) {
                newurl = Browser.window.wx.createBufferURL(arrayBuffer);
            }
            else if (Browser.window.Blob) {
                let blob = new Blob([arrayBuffer], { type: 'application/octet-binary' });
                newurl = Browser.window.URL.createObjectURL(blob);
            }
            if (ImgUtils.isSavaData)
                ImgUtils.data[url] = newurl;
            return newurl;
        }
        static _arrayBufferToURL(arrayBuffer) {
            if (!ImgUtils.isSupport)
                return null;
            var newurl = "";
            if (Browser._isMiniGame || Browser.onLayaRuntime) {
                newurl = Browser.window.wx.createBufferURL(arrayBuffer);
            }
            else if (Browser.window.Blob) {
                let blob = new Blob([arrayBuffer], { type: 'application/octet-binary' });
                newurl = Browser.window.URL.createObjectURL(blob);
            }
            return newurl;
        }
        static destroy(url) {
            if (!ImgUtils.isSupport)
                return;
            var newurl = ImgUtils.data[url];
            if (newurl) {
                if (Browser._isMiniGame || Browser.onLayaRuntime)
                    Browser.window.wx.revokeBufferURL(newurl);
                else if (Browser.window.Blob)
                    Browser.window.URL.revokeObjectURL(newurl);
                delete ImgUtils.data[url];
            }
        }
    }
    ImgUtils.data = {};
    ImgUtils.isSavaData = false;

    class XMLUtils {
        static decodeString(aSource) {
            let len = aSource.length;
            let sb = "";
            let pos1 = 0, pos2 = 0;
            while (true) {
                pos2 = aSource.indexOf('&', pos1);
                if (pos2 == -1) {
                    sb += aSource.substring(pos1);
                    break;
                }
                sb += aSource.substring(pos1, pos2);
                pos1 = pos2 + 1;
                pos2 = pos1;
                let end = Math.min(len, pos2 + 10);
                for (; pos2 < end; pos2++) {
                    if (aSource[pos2] == ';')
                        break;
                }
                if (pos2 < end && pos2 > pos1) {
                    let entity = aSource.substring(pos1, pos2);
                    let u = 0;
                    if (entity[0] == '#') {
                        if (entity.length > 1) {
                            if (entity[1] == 'x')
                                u = parseInt(entity.substring(2), 16);
                            else
                                u = parseInt(entity.substring(1));
                            sb += String.fromCharCode(u);
                            pos1 = pos2 + 1;
                        }
                        else
                            sb += '&';
                    }
                    else {
                        switch (entity) {
                            case "amp":
                                u = 38;
                                break;
                            case "apos":
                                u = 39;
                                break;
                            case "gt":
                                u = 62;
                                break;
                            case "lt":
                                u = 60;
                                break;
                            case "nbsp":
                                u = 32;
                                break;
                            case "quot":
                                u = 34;
                                break;
                        }
                        if (u > 0) {
                            sb += String.fromCharCode(u);
                            pos1 = pos2 + 1;
                        }
                        else
                            sb += '&';
                    }
                }
                else {
                    sb += '&';
                }
            }
            return sb;
        }
        static encodeString(str) {
            return str.replace(/&/g, "&amp;").replace(/</g, "&lt;")
                .replace(/>/g, "&gt;").replace(/'/g, "&apos;").replace(/"/g, "&quot;");
        }
        static getString(attrs, attrName, defValue) {
            if (attrs == null)
                return defValue == null ? null : defValue;
            let ret = attrs[attrName];
            if (ret != null)
                return "" + ret;
            else
                return defValue == null ? null : defValue;
        }
        static getInt(attrs, attrName, defValue) {
            let value = this.getString(attrs, attrName);
            if (value != null && value.length > 0) {
                if (value[value.length - 1] == '%') {
                    let ret = parseInt(value.substring(0, value.length - 1));
                    if (!isNaN(ret))
                        return Math.ceil(ret / 100.0 * defValue);
                }
                else {
                    let ret = parseInt(value);
                    if (!isNaN(ret))
                        return ret;
                }
            }
            return defValue == null ? 0 : defValue;
        }
        static getFloat(attrs, attrName, defValue) {
            let value = this.getString(attrs, attrName);
            if (value == null || value.length == 0)
                return defValue == null ? 0 : defValue;
            let ret = parseFloat(value);
            if (isNaN(ret))
                return defValue == null ? 0 : defValue;
            else
                return ret;
        }
        static getBool(attrs, attrName, defValue) {
            let value = this.getString(attrs, attrName);
            if (value == null || value.length == 0)
                return defValue == null ? false : defValue;
            if (value == "true" || value == "1")
                return true;
            else if (value == "false" || value == "0")
                return false;
            else
                return defValue == null ? false : defValue;
        }
    }

    exports.XMLTagType = void 0;
    (function (XMLTagType) {
        XMLTagType[XMLTagType["Start"] = 0] = "Start";
        XMLTagType[XMLTagType["End"] = 1] = "End";
        XMLTagType[XMLTagType["Void"] = 2] = "Void";
        XMLTagType[XMLTagType["CDATA"] = 3] = "CDATA";
        XMLTagType[XMLTagType["Comment"] = 4] = "Comment";
        XMLTagType[XMLTagType["Instruction"] = 5] = "Instruction";
    })(exports.XMLTagType || (exports.XMLTagType = {}));
    const CDATA_START = "<![CDATA[";
    const CDATA_END = "]]>";
    const COMMENT_START = "<!--";
    const COMMENT_END = "-->";
    class XMLIterator {
        static begin(source, lowerCaseName) {
            XMLIterator.source = source;
            XMLIterator.lowerCaseName = lowerCaseName;
            this.sourceLen = source.length;
            this.parsePos = 0;
            this.lastTagEnd = 0;
            this.tagPos = 0;
            this.tagLength = 0;
            this.tagName = null;
        }
        static nextTag() {
            let pos;
            let c;
            let buffer = "";
            this.tagType = exports.XMLTagType.Start;
            this.lastTagEnd = this.parsePos;
            this.attrParsed = false;
            this.lastTagName = this.tagName;
            while ((pos = this.source.indexOf('<', this.parsePos)) != -1) {
                this.parsePos = pos;
                pos++;
                if (pos == this.sourceLen)
                    break;
                c = this.source[pos];
                if (c == '!') {
                    if (this.sourceLen > pos + 7 && this.source.substring(pos - 1, pos + 8) == CDATA_START) {
                        pos = this.source.indexOf(CDATA_END, pos);
                        this.tagType = exports.XMLTagType.CDATA;
                        this.tagName = "";
                        this.tagPos = this.parsePos;
                        if (pos == -1)
                            this.tagLength = this.sourceLen - this.parsePos;
                        else
                            this.tagLength = pos + 3 - this.parsePos;
                        this.parsePos += this.tagLength;
                        return true;
                    }
                    else if (this.sourceLen > pos + 2 && this.source.substring(pos - 1, pos + 3) == COMMENT_START) {
                        pos = this.source.indexOf(COMMENT_END, pos);
                        this.tagType = exports.XMLTagType.Comment;
                        this.tagName = "";
                        this.tagPos = this.parsePos;
                        if (pos == -1)
                            this.tagLength = this.sourceLen - this.parsePos;
                        else
                            this.tagLength = pos + 3 - this.parsePos;
                        this.parsePos += this.tagLength;
                        return true;
                    }
                    else {
                        pos++;
                        this.tagType = exports.XMLTagType.Instruction;
                    }
                }
                else if (c == '/') {
                    pos++;
                    this.tagType = exports.XMLTagType.End;
                }
                else if (c == '?') {
                    pos++;
                    this.tagType = exports.XMLTagType.Instruction;
                }
                for (; pos < this.sourceLen; pos++) {
                    c = this.source[pos];
                    if (' \t\n\r\v'.indexOf(c) != -1 || c == '>' || c == '/')
                        break;
                }
                if (pos == this.sourceLen)
                    break;
                buffer += this.source.substring(this.parsePos + 1, pos);
                if (buffer.length > 0 && buffer[0] == '/')
                    buffer = buffer.substring(1);
                let singleQuoted = false, doubleQuoted = false;
                let possibleEnd = -1;
                for (; pos < this.sourceLen; pos++) {
                    c = this.source[pos];
                    if (c == '"') {
                        if (!singleQuoted)
                            doubleQuoted = !doubleQuoted;
                    }
                    else if (c == '\'') {
                        if (!doubleQuoted)
                            singleQuoted = !singleQuoted;
                    }
                    if (c == '>') {
                        if (!(singleQuoted || doubleQuoted)) {
                            possibleEnd = -1;
                            break;
                        }
                        possibleEnd = pos;
                    }
                    else if (c == '<')
                        break;
                }
                if (possibleEnd != -1)
                    pos = possibleEnd;
                if (pos == this.sourceLen)
                    break;
                if (this.source[pos - 1] == '/')
                    this.tagType = exports.XMLTagType.Void;
                this.tagName = buffer;
                if (this.lowerCaseName)
                    this.tagName = this.tagName.toLowerCase();
                this.tagPos = this.parsePos;
                this.tagLength = pos + 1 - this.parsePos;
                this.parsePos += this.tagLength;
                return true;
            }
            this.tagPos = this.sourceLen;
            this.tagLength = 0;
            this.tagName = null;
            return false;
        }
        static getTagSource() {
            return this.source.substring(this.tagPos, this.tagPos + this.tagLength);
        }
        static getRawText(trim) {
            if (this.lastTagEnd == this.tagPos)
                return "";
            else if (trim) {
                let i = this.lastTagEnd;
                for (; i < this.tagPos; i++) {
                    let c = this.source[i];
                    if (' \t\n\r\v'.indexOf(c) == -1)
                        break;
                }
                if (i == this.tagPos)
                    return "";
                else
                    return this.source.substring(i, this.tagPos).trim();
            }
            else
                return this.source.substring(this.lastTagEnd, this.tagPos);
        }
        static getText(trim) {
            if (this.lastTagEnd == this.tagPos)
                return "";
            else if (trim) {
                let i = this.lastTagEnd;
                for (; i < this.tagPos; i++) {
                    let c = this.source[i];
                    if (' \t\n\r\v'.indexOf(c) == -1)
                        break;
                }
                if (i == this.tagPos)
                    return "";
                else
                    return XMLUtils.decodeString(this.source.substring(i, this.tagPos)).trimEnd();
            }
            else
                return XMLUtils.decodeString(this.source.substring(this.lastTagEnd, this.tagPos));
        }
        static get attributes() {
            if (!this.attrParsed) {
                for (let key in this._attrs) {
                    delete this._attrs[key];
                }
                this.parseAttributes(this._attrs);
                this.attrParsed = true;
            }
            return this._attrs;
        }
        static getAttribute(attrName) {
            return this.attributes[attrName];
        }
        static parseAttributes(attrs) {
            let attrName;
            let valueStart = 0;
            let valueEnd = 0;
            let waitValue = false;
            let quoted = 0;
            let buffer = "";
            let i = this.tagPos;
            let attrEnd = this.tagPos + this.tagLength;
            if (i < attrEnd && this.source[i] == '<') {
                for (; i < attrEnd; i++) {
                    let c = this.source[i];
                    if (' \t\n\r\v'.indexOf(c) != -1 || c == '>' || c == '/')
                        break;
                }
            }
            for (; i < attrEnd; i++) {
                let c = this.source[i];
                if (c == '=') {
                    valueStart = -1;
                    valueEnd = -1;
                    quoted = 0;
                    for (let j = i + 1; j < attrEnd; j++) {
                        let c2 = this.source[j];
                        if (' \t\n\r\v'.indexOf(c2) != -1) {
                            if (valueStart != -1 && quoted == 0) {
                                valueEnd = j - 1;
                                break;
                            }
                        }
                        else if (c2 == '>') {
                            if (quoted == 0) {
                                valueEnd = j - 1;
                                break;
                            }
                        }
                        else if (c2 == '"') {
                            if (valueStart != -1) {
                                if (quoted != 1) {
                                    valueEnd = j - 1;
                                    break;
                                }
                            }
                            else {
                                quoted = 2;
                                valueStart = j + 1;
                            }
                        }
                        else if (c2 == '\'') {
                            if (valueStart != -1) {
                                if (quoted != 2) {
                                    valueEnd = j - 1;
                                    break;
                                }
                            }
                            else {
                                quoted = 1;
                                valueStart = j + 1;
                            }
                        }
                        else if (valueStart == -1) {
                            valueStart = j;
                        }
                    }
                    if (valueStart != -1 && valueEnd != -1) {
                        attrName = buffer;
                        if (this.lowerCaseName)
                            attrName = attrName.toLowerCase();
                        buffer = "";
                        attrs[attrName] = XMLUtils.decodeString(this.source.substring(valueStart, valueEnd + 1));
                        i = valueEnd + 1;
                    }
                    else
                        break;
                }
                else if (' \t\n\r\v'.indexOf(c) == -1) {
                    if (waitValue || c == '/' || c == '>') {
                        if (buffer.length > 0) {
                            attrName = buffer;
                            if (this.lowerCaseName)
                                attrName = attrName.toLowerCase();
                            attrs[attrName] = "";
                            buffer = "";
                        }
                        waitValue = false;
                    }
                    if (c != '/' && c != '>')
                        buffer += c;
                }
                else {
                    if (buffer.length > 0)
                        waitValue = true;
                }
            }
        }
    }
    XMLIterator._attrs = {};
    if (!String.prototype.trimEnd) {
        String.prototype.trimEnd = function () {
            return this.replace(/\s+$/g, "");
        };
    }

    class XML {
        constructor(XmlString) {
            if (XmlString)
                this.parse(XmlString);
        }
        get attributes() {
            if (!this._attrs)
                this._attrs = {};
            return this._attrs;
        }
        getAttrString(attrName, defValue) {
            return XMLUtils.getString(this._attrs, attrName, defValue);
        }
        getAttrInt(attrName, defValue) {
            return XMLUtils.getInt(this._attrs, attrName, defValue);
        }
        getAttrFloat(attrName, defValue) {
            return XMLUtils.getFloat(this._attrs, attrName, defValue);
        }
        getAttrBool(attrName, defValue) {
            return XMLUtils.getBool(this._attrs, attrName, defValue);
        }
        setAttribute(attrName, attrValue) {
            if (!this._attrs)
                this._attrs = {};
            this._attrs[attrName] = attrValue;
        }
        getNode(selector) {
            if (!this._children)
                return null;
            else
                return this._children.find(value => {
                    return value.name == selector;
                });
        }
        elements(selector) {
            if (!this._children)
                this._children = new Array();
            if (selector)
                return this._children.filter(value => {
                    return value.name == selector;
                });
            else
                return this._children;
        }
        parse(aSource) {
            this.reset();
            let lastOpenNode;
            let nodeStack = new Array();
            XMLIterator.begin(aSource);
            while (XMLIterator.nextTag()) {
                if (XMLIterator.tagType == exports.XMLTagType.Start || XMLIterator.tagType == exports.XMLTagType.Void) {
                    let childNode;
                    if (lastOpenNode)
                        childNode = new XML();
                    else {
                        if (this.name != null) {
                            this.reset();
                            throw new Error("Invalid xml format - no root node.");
                        }
                        childNode = this;
                    }
                    childNode.name = XMLIterator.tagName;
                    childNode._attrs = Object.assign({}, XMLIterator.attributes);
                    if (lastOpenNode) {
                        if (XMLIterator.tagType != exports.XMLTagType.Void)
                            nodeStack.push(lastOpenNode);
                        if (lastOpenNode._children == null)
                            lastOpenNode._children = new Array();
                        lastOpenNode._children.push(childNode);
                    }
                    if (XMLIterator.tagType != exports.XMLTagType.Void)
                        lastOpenNode = childNode;
                }
                else if (XMLIterator.tagType == exports.XMLTagType.End) {
                    if (lastOpenNode == null || lastOpenNode.name != XMLIterator.tagName) {
                        this.reset();
                        throw new Error("Invalid xml format - <" + XMLIterator.tagName + "> dismatched.");
                    }
                    if (lastOpenNode._children == null || lastOpenNode._children.length == 0) {
                        lastOpenNode.text = XMLIterator.getText();
                    }
                    if (nodeStack.length > 0)
                        lastOpenNode = nodeStack.pop();
                    else
                        lastOpenNode = null;
                }
            }
        }
        reset() {
            this._attrs = null;
            if (this._children != null)
                this._children.length == 0;
            this.text = null;
        }
    }

    class HttpRequest extends EventDispatcher {
        constructor() {
            super(...arguments);
            this._http = new XMLHttpRequest();
        }
        send(url, data = null, method = "get", responseType = "text", headers) {
            this._responseType = responseType;
            this._data = null;
            if (Browser.onVVMiniGame || Browser.onQGMiniGame || Browser.onQQMiniGame || Browser.onAlipayMiniGame || Browser.onBLMiniGame || Browser.onHWMiniGame || Browser.onTTMiniGame || Browser.onTBMiniGame) {
                url = HttpRequest._urlEncode(url);
            }
            this._url = url;
            let http = this._http;
            http.open(method, url, true);
            if (data) {
                if (typeof (data) == 'string') {
                    http.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                }
                else {
                    http.setRequestHeader("Content-Type", "application/json");
                    if (!(data instanceof ArrayBuffer))
                        data = JSON.stringify(data);
                }
            }
            else if (Browser.onBLMiniGame && Browser.onAndroid)
                data = {};
            if (headers) {
                for (let i = 0; i < headers.length; i++) {
                    http.setRequestHeader(headers[i++], headers[i]);
                }
            }
            let restype = responseType !== "arraybuffer" ? "text" : "arraybuffer";
            http.responseType = restype;
            if (http.dataType) {
                http.dataType = restype;
            }
            http.onerror = (e) => {
                this._onError(e);
            };
            http.onabort = (e) => {
                this._onAbort(e);
            };
            http.onprogress = (e) => {
                this._onProgress(e);
            };
            http.onload = (e) => {
                this._onLoad(e);
            };
            http.send(data);
        }
        _onProgress(e) {
            if (e && e.lengthComputable)
                this.event(Event.PROGRESS, e.loaded / e.total);
        }
        _onAbort(e) {
            this.error("Request was aborted by user");
        }
        _onError(e) {
            this.error("Request failed Status:" + this._http.status + " text:" + this._http.statusText);
        }
        _onLoad(e) {
            var http = this._http;
            var status = http.status !== undefined ? http.status : 200;
            if (status === 200 || status === 204 || status === 0) {
                this.complete();
            }
            else {
                this.error("[" + http.status + "]" + http.statusText + ":" + http.responseURL);
            }
        }
        error(message) {
            this.clear();
            this.event(Event.ERROR, message);
        }
        complete() {
            this.clear();
            var flag = true;
            try {
                if (this._responseType === "json") {
                    this._data = JSON.parse(this._http.responseText);
                }
                else if (this._responseType === "xml") {
                    this._data = new XML(this._http.responseText);
                }
                else {
                    this._data = this._http.response || this._http.responseText;
                }
            }
            catch (e) {
                flag = false;
                this.error(e.message);
            }
            flag && this.event(Event.COMPLETE, this._data instanceof Array ? [this._data] : this._data);
        }
        clear() {
            var http = this._http;
            http.onerror = http.onabort = http.onprogress = http.onload = null;
        }
        get url() {
            return this._url;
        }
        get data() {
            return this._data;
        }
        get http() {
            return this._http;
        }
        reset() {
            this.offAll();
            this._data = null;
        }
    }
    HttpRequest._urlEncode = encodeURI;

    class Downloader {
        constructor() {
            this.httpRequestPool = [];
        }
        common(owner, url, originalUrl, contentType, onProgress, onComplete) {
            let http = this.getRequestInst();
            http.on(Event.COMPLETE, () => {
                let data = http.data;
                this.returnRequestInst(http);
                onComplete(data);
            });
            http.on(Event.ERROR, null, (error) => {
                this.returnRequestInst(http);
                onComplete(null, error);
            });
            if (onProgress)
                http.on(Event.PROGRESS, onProgress);
            http.send(url, null, "get", contentType);
            owner.$ref = http;
        }
        image(owner, url, originalUrl, onProgress, onComplete) {
            let image = new Browser.window.Image();
            image.crossOrigin = "";
            image.onload = () => {
                image.onload = null;
                image.onerror = null;
                onComplete(image);
            };
            image.onerror = () => {
                image.onload = null;
                image.onerror = null;
                onComplete(null, "");
            };
            image.src = url;
            owner.$ref = image;
        }
        imageWithBlob(owner, blob, originalUrl, onProgress, onComplete) {
            let url = ImgUtils.arrayBufferToURL(originalUrl, blob);
            this.image(owner, url, originalUrl, onProgress, onComplete);
        }
        imageWithWorker(owner, url, originalUrl, onProgress, onComplete) {
            WorkerLoader.enable = true;
            if (WorkerLoader.enable) {
                WorkerLoader.load(url, owner.workerLoaderOptions)
                    .then(onComplete)
                    .catch((error) => onComplete(null, error));
            }
            else
                this.image(owner, url, originalUrl, onProgress, onComplete);
        }
        audio(owner, url, originalUrl, onProgress, onComplete) {
            let audio = Browser.createElement("audio");
            audio.crossOrigin = "";
            audio.oncanplaythrough = () => {
                audio.oncanplaythrough = null;
                audio.onerror = null;
                onComplete(audio);
            };
            audio.onerror = () => {
                audio.oncanplaythrough = null;
                audio.onerror = null;
                onComplete(null, "");
            };
            audio.src = url;
            owner.$ref = audio;
        }
        getRequestInst() {
            if (this.httpRequestPool.length == 0
                || Browser.onVVMiniGame || Browser.onHWMiniGame) {
                return new HttpRequest();
            }
            else {
                return this.httpRequestPool.pop();
            }
        }
        returnRequestInst(inst) {
            inst.reset();
            if (this.httpRequestPool.length < 10)
                this.httpRequestPool.push(inst);
        }
    }

    var typeIdCounter = 0;
    const NullURLInfo = { ext: null, typeId: null, main: false, loaderType: null };
    class Loader extends EventDispatcher {
        static registerLoader(exts, cls, type, hotReloadable) {
            let typeEntry;
            if (type) {
                typeEntry = Loader.typeMap[type];
                if (!typeEntry)
                    Loader.typeMap[type] = typeEntry = { typeId: typeIdCounter++, loaderType: cls };
                else if (typeEntry.loaderType != cls)
                    typeEntry = { typeId: typeEntry.typeId, loaderType: cls };
            }
            else
                typeEntry = { typeId: typeIdCounter++, loaderType: cls };
            if (hotReloadable)
                Loader.hotReloadableFlags[typeEntry.typeId] = true;
            for (let ext of exts) {
                let entry = Loader.extMap[ext];
                if (entry && type) {
                    let i = entry.findIndex(e => e.typeId == typeEntry.typeId);
                    if (i == -1)
                        entry.push(typeEntry);
                    else
                        entry[i].loaderType = cls;
                }
                else {
                    Loader.extMap[ext] = [typeEntry];
                }
            }
        }
        constructor() {
            super();
            this.retryNum = 1;
            this.retryDelay = 0;
            this.maxLoader = 5;
            this._loadings = new Map();
            this._queue = [];
            this._downloadings = new Set();
        }
        get loading() {
            return this._loadings.size > 0;
        }
        load(url, arg1, arg2, arg3, priority, cache, group, ignoreCache, useWorkerLoader) {
            let complete;
            let type;
            let options = dummyOptions;
            if (arg1 instanceof Handler) {
                complete = arg1;
                type = arg3;
            }
            else if (typeof (arg1) === "string")
                type = arg1;
            else if (arg1 != null) {
                type = arg1.type;
                options = arg1;
            }
            if (priority != null || cache != null || ignoreCache != null || group != null || useWorkerLoader != null) {
                if (options === dummyOptions)
                    options = { priority, cache, ignoreCache, group, useWorkerLoader };
                else
                    options = Object.assign(options, { priority, cache, ignoreCache, group, useWorkerLoader });
            }
            if (options.cache === false)
                options.ignoreCache = true;
            let onProgress;
            if (arg2 instanceof Handler)
                onProgress = (value) => arg2.runWith(value);
            else
                onProgress = arg2;
            let promise;
            if (Array.isArray(url)) {
                let pd;
                if (onProgress)
                    pd = new BatchProgress(onProgress);
                let promises = [];
                for (let i = 0; i < url.length; i++) {
                    let url2 = url[i];
                    if (!url2)
                        continue;
                    if (typeof (url2) === "string") {
                        promises.push(this._load1(url2, type, options, pd === null || pd === void 0 ? void 0 : pd.createCallback()));
                    }
                    else {
                        promises.push(this._load1(url2.url, url2.type || type, options !== dummyOptions ? Object.assign({}, options, url2) : url2, pd === null || pd === void 0 ? void 0 : pd.createCallback()));
                    }
                }
                promise = Promise.all(promises);
            }
            else if (typeof (url) === "string")
                promise = this._load1(url, type, options, onProgress);
            else
                promise = this._load1(url.url, url.type || type, options !== dummyOptions ? Object.assign({}, options, url) : url, onProgress);
            if (complete)
                return promise.then(result => {
                    complete.runWith(result);
                    return result;
                });
            else
                return promise;
        }
        _load1(url, type, options, onProgress) {
            if (LayaEnv.isPreview) {
                if (url.startsWith("res://")) {
                    let uuid = url.substring(6);
                    return AssetDb.inst.UUID_to_URL_async(uuid).then(url2 => {
                        var _a;
                        if (url2)
                            return this._load2(url2, uuid, type, options, onProgress);
                        else {
                            !options.silent && Loader.warnFailed(url, undefined, (_a = options.initiator) === null || _a === void 0 ? void 0 : _a.url);
                            return Promise.resolve(null);
                        }
                    });
                }
                else {
                    return AssetDb.inst.URL_to_UUID_async(url).then(uuid => {
                        return this._load2(url, uuid, type, options, onProgress);
                    });
                }
            }
            else
                return this._load2(url, null, type, options, onProgress);
        }
        _load2(url, uuid, type, options, onProgress) {
            var _a, _b;
            let { ext, typeId, main, loaderType } = Loader.getURLInfo(url, type);
            if (!loaderType) {
                !options.silent && Loader.warnFailed(url, type ? `unsupported load type:${type}` : !url.startsWith("res://") ? `unsupported suffix` : "", (_a = options.initiator) === null || _a === void 0 ? void 0 : _a.url);
                return Promise.resolve(null);
            }
            let formattedUrl = URL.formatURL(url);
            if (options.group) {
                let set = Loader.groupMap[options.group];
                if (!set)
                    set = Loader.groupMap[options.group] = new Set();
                set.add(formattedUrl);
            }
            let obsoluteRes;
            if (!options.ignoreCache) {
                let cacheRes = Loader._getRes(formattedUrl, type);
                if (cacheRes !== undefined) {
                    if (cacheRes == null)
                        return Promise.resolve(null);
                    else {
                        if (!(cacheRes instanceof Resource))
                            return Promise.resolve(cacheRes);
                        if (cacheRes.obsolute)
                            obsoluteRes = cacheRes;
                        if (!obsoluteRes && (!cacheRes.uuid || !uuid || uuid == cacheRes.uuid))
                            return Promise.resolve(cacheRes);
                    }
                }
            }
            let loadingKey = formattedUrl;
            if (!main)
                loadingKey += "@" + typeId;
            let task = this._loadings.get(loadingKey);
            if (task) {
                let p = options.initiator;
                while (p) {
                    if (p === task)
                        return Promise.resolve();
                    p = p.options.initiator;
                }
                if (task.result != null)
                    return task.result;
                if (onProgress)
                    task.onProgress.add(onProgress);
                return new Promise((resolve) => task.onComplete.add(resolve));
            }
            let atlasInfo = AtlasInfoManager.getFileLoadPath(formattedUrl);
            if (atlasInfo) {
                return this.load(atlasInfo.url, { type: Loader.ATLAS, baseUrl: atlasInfo.baseUrl }).then(() => {
                    return Loader.getRes(url, type);
                });
            }
            if (loadTaskPool.length > 0)
                task = loadTaskPool.pop();
            else
                task = new LoadTask();
            task.type = type;
            task.url = url;
            task.uuid = uuid;
            task.ext = ext;
            options = Object.assign(task.options, options);
            delete options.type;
            if (options.priority == null)
                options.priority = 0;
            if (options.useWorkerLoader == null)
                options.useWorkerLoader = WorkerLoader.enable;
            if (onProgress)
                task.onProgress.add(onProgress);
            task.loader = this;
            task.obsoluteInst = obsoluteRes;
            let assetLoader = new loaderType();
            this._loadings.set(loadingKey, task);
            let promise;
            try {
                Loader.LoaderStat_LoaderResourceCount++;
                this._tempTime = performance.now();
                promise = assetLoader.load(task);
            }
            catch (err) {
                !options.silent && Loader.warnFailed(url, err, (_b = options.initiator) === null || _b === void 0 ? void 0 : _b.url);
                promise = Promise.resolve(null);
            }
            return promise.then(content => {
                Loader.LoaderStat_LoadResourceTime += performance.now() - this._tempTime;
                if (content instanceof Resource) {
                    content.obsolute = false;
                    content._setCreateURL(url, uuid);
                }
                if (task.options.cache !== false)
                    Loader._cacheRes(formattedUrl, content, typeId, main);
                if (content != null && assetLoader.postLoad != null) {
                    task.result = content;
                    return assetLoader.postLoad(task, content).then(() => {
                        task.progress.update(-1, 1);
                        task.onComplete.invoke(content);
                        return content;
                    });
                }
                else {
                    task.progress.update(-1, 1);
                    task.onComplete.invoke(content);
                    return content;
                }
            }).catch(error => {
                var _a;
                !options.silent && Loader.warnFailed(url, error, (_a = options.initiator) === null || _a === void 0 ? void 0 : _a.url);
                if (task.options.cache !== false)
                    Loader._cacheRes(formattedUrl, null, typeId, main);
                task.onComplete.invoke(null);
                return null;
            }).then(content => {
                this._loadings.delete(loadingKey);
                task.reset();
                loadTaskPool.push(task);
                if (this._loadings.size == 0)
                    this.event(Event.COMPLETE);
                return content;
            });
        }
        fetch(url, contentType, onProgress, options) {
            var _a;
            options = options || dummyOptions;
            let task = {
                originalUrl: url,
                url: url,
                contentType: contentType,
                priority: (_a = options.priority) !== null && _a !== void 0 ? _a : 1,
                retryCnt: 0,
                onProgress: onProgress,
                onComplete: null,
            };
            if (options.useWorkerLoader) {
                task.useWorkerLoader = true;
                task.workerLoaderOptions = options.workerLoaderOptions;
            }
            if (options.blob)
                task.blob = options.blob;
            if (options.noRetry)
                task.retryCnt = -1;
            if (options.silent)
                task.silent = true;
            return AssetDb.inst.resolveURL(url).then(url => {
                if (url)
                    return new Promise((resolve) => {
                        task.url = URL.formatURL(url);
                        task.onComplete = resolve;
                        this.queueToDownload(task);
                    });
                else
                    return null;
            });
        }
        queueToDownload(item) {
            if (this._downloadings.size < this.maxLoader) {
                this.download(item);
                return;
            }
            let priority = item.priority;
            if (priority == 0)
                this._queue.push(item);
            else {
                let i = this._queue.findIndex(e => e.priority < priority);
                if (i != -1)
                    this._queue.splice(i, 0, item);
                else
                    this._queue.push(item);
            }
        }
        download(item) {
            this._downloadings.add(item);
            Loader.LoaderStat_LoadRequestCount++;
            item.startTime = performance.now();
            let url = URL.postFormatURL(item.url);
            if (item.contentType == "image") {
                let preloadedContent = Loader.preLoadedMap[item.url];
                if (preloadedContent) {
                    if (!(preloadedContent instanceof ArrayBuffer)) {
                        this.completeItem(item, preloadedContent);
                        return;
                    }
                    item.blob = preloadedContent;
                }
                if (item.blob) {
                    Loader.downloader.imageWithBlob(item, item.blob, item.originalUrl, item.onProgress, (data, error) => {
                        if (!data)
                            item.retryCnt = -1;
                        this.completeItem(item, data, error);
                    });
                }
                else if (item.useWorkerLoader) {
                    Loader.downloader.imageWithWorker(item, url, item.originalUrl, item.onProgress, (data, error) => {
                        if (!data) {
                            item.useWorkerLoader = false;
                            if (!item.silent)
                                Loader.warnFailed(item.url, error);
                        }
                        this.completeItem(item, data, error);
                    });
                }
                else {
                    Loader.downloader.image(item, url, item.originalUrl, item.onProgress, (data, error) => this.completeItem(item, data, error));
                }
            }
            else if (item.contentType == "sound") {
                Loader.downloader.audio(item, url, item.originalUrl, item.onProgress, (data, error) => this.completeItem(item, data, error));
            }
            else {
                let preloadedContent = Loader.preLoadedMap[item.url];
                if (preloadedContent) {
                    this.completeItem(item, preloadedContent);
                    return;
                }
                Loader.downloader.common(item, url, item.originalUrl, item.contentType, item.onProgress, (data, error) => this.completeItem(item, data, error));
            }
        }
        completeItem(item, content, error) {
            this._downloadings.delete(item);
            Loader.LoaderStat_LoadRequestTime += performance.now() - item.startTime;
            if (content) {
                if (this._downloadings.size < this.maxLoader && this._queue.length > 0)
                    this.download(this._queue.shift());
                if (item.onProgress)
                    item.onProgress(1);
                item.onComplete(content);
            }
            else if (item.retryCnt != -1 && item.retryCnt < this.retryNum) {
                item.retryCnt++;
                if (!item.silent)
                    console.debug(`Retry to load ${item.url} (${item.retryCnt})`);
                ILaya.systemTimer.once(this.retryDelay, this, this.queueToDownload, [item], false);
            }
            else {
                !item.silent && Loader.warnFailed(item.url, error);
                if (item.onProgress)
                    item.onProgress(1);
                if (this._downloadings.size < this.maxLoader && this._queue.length > 0)
                    this.download(this._queue.shift());
                item.onComplete(null);
            }
        }
        static getURLInfo(url, type) {
            let ext = url.startsWith("data:") ? "png" : Utils.getFileExtension(url);
            let extEntry;
            if (ext.length > 0)
                extEntry = Loader.extMap[ext];
            let typeId;
            let main;
            let loaderType;
            if (type) {
                let typeEntry = Loader.typeMap[type];
                if (!typeEntry)
                    return NullURLInfo;
                typeId = typeEntry.typeId;
                let i = 0;
                if (extEntry) {
                    if (extEntry[0].typeId === typeId
                        || (i = extEntry.findIndex(e => e.typeId === typeId)) != -1) {
                        main = i == 0;
                        loaderType = extEntry[i].loaderType;
                    }
                    else {
                        main = false;
                        loaderType = typeEntry.loaderType;
                    }
                }
                else {
                    main = type != Loader.TEXTURE2D;
                    loaderType = typeEntry.loaderType;
                }
            }
            else {
                if (!extEntry)
                    return NullURLInfo;
                main = true;
                typeId = extEntry[0].typeId;
                loaderType = extEntry[0].loaderType;
            }
            return { ext, main, typeId, loaderType };
        }
        static warnFailed(url, err, initiatorUrl) {
            if (initiatorUrl)
                this.warn(`Failed to load '${url}' (in '${initiatorUrl}')`, err);
            else
                this.warn(`Failed to load '${url}'`, err);
        }
        static warn(msg, err) {
            if (err)
                console.warn(msg, err);
            else
                console.warn(msg);
        }
        static getRes(url, type) {
            url = URL.formatURL(url);
            let ret = Loader._getRes(url, type);
            return ret || null;
        }
        static _getRes(url, type) {
            let resArr = Loader.loadedMap[url];
            if (!resArr)
                return undefined;
            let ret;
            if (type) {
                let typeEntry = Loader.typeMap[type];
                if (!typeEntry)
                    return undefined;
                if (resArr.length == 2) {
                    if (resArr[0] == typeEntry.typeId)
                        ret = resArr[1];
                }
                else {
                    let i = resArr.indexOf(typeEntry.typeId);
                    if (i != -1)
                        ret = resArr[i + 1];
                }
            }
            else
                ret = resArr[1];
            if ((ret instanceof Resource) && ret.destroyed)
                return undefined;
            else
                return ret;
        }
        static getTexture2D(url) {
            return Loader.getRes(url, Loader.TEXTURE2D);
        }
        static getBaseTexture(url) {
            return Loader.getRes(url, Loader.TEXTURE2D);
        }
        static getAtlas(url) {
            return Loader.getRes(url, Loader.ATLAS);
        }
        getRes(url, type) {
            return Loader.getRes(url, type);
        }
        static createNodes(url) {
            var _a;
            return (_a = Loader.getRes(url)) === null || _a === void 0 ? void 0 : _a.create();
        }
        static cacheRes(url, data, type) {
            url = URL.formatURL(url);
            let urlInfo = Loader.getURLInfo(url, type);
            if (urlInfo.typeId != null)
                Loader._cacheRes(url, data, urlInfo.typeId, urlInfo.main);
        }
        static _cacheRes(url, data, typeId, main) {
            let entry = Loader.loadedMap[url];
            if (main) {
                if (entry) {
                    entry[0] = typeId;
                    entry[1] = data;
                }
                else
                    entry = Loader.loadedMap[url] = [typeId, data];
            }
            else {
                if (entry) {
                    let i = entry.findIndex(e => e === typeId);
                    if (i != -1)
                        entry[i + 1] = data;
                    else
                        entry.push(typeId, data);
                }
                else
                    entry = Loader.loadedMap[url] = [null, undefined, typeId, data];
            }
        }
        cacheRes(url, data, type) {
            Loader.cacheRes(url, data, type);
        }
        static clearRes(url, checkObj) {
            url = URL.formatURL(url);
            Loader._clearRes(url, checkObj);
        }
        clearRes(url, checkObj) {
            url = URL.formatURL(url);
            Loader._clearRes(url, checkObj);
        }
        static _clearRes(url, checkObj) {
            let entry = Loader.loadedMap[url];
            if (!entry)
                return;
            if (checkObj) {
                if (entry[1] == checkObj) {
                    if (entry.length == 2)
                        delete Loader.loadedMap[url];
                    else
                        entry[1] = undefined;
                }
                else {
                    let i = entry.indexOf(checkObj);
                    if (i == -1)
                        return;
                    if (entry.length == 4 && entry[0] == null)
                        delete Loader.loadedMap[url];
                    else
                        entry.splice(i - 1, 2);
                }
                if ((checkObj instanceof Resource) && !checkObj.destroyed) {
                    checkObj.destroy();
                }
            }
            else {
                delete Loader.loadedMap[url];
                if (entry.length > 2) {
                    for (let i = 1; i < entry.length; i += 2) {
                        let obj = entry[i];
                        if ((obj instanceof Resource) && !obj.destroyed) {
                            obj.destroy();
                        }
                    }
                }
                else {
                    let obj = entry[1];
                    if ((obj instanceof Resource) && !obj.destroyed) {
                        obj.destroy();
                    }
                }
            }
        }
        clearTextureRes(url) {
            url = URL.formatURL(url);
            let entry = Loader.loadedMap[url];
            if (!entry)
                return;
            let res = entry[1];
            if (res instanceof Texture) {
                res.disposeBitmap();
            }
            else if (res instanceof AtlasResource) {
                for (let tex of res.textures)
                    tex.disposeBitmap();
            }
        }
        static setGroup(url, group) {
            url = URL.formatURL(url);
            let set = Loader.groupMap[group];
            if (!set)
                set = Loader.groupMap[group] = new Set();
            set.add(url);
        }
        static clearResByGroup(group) {
            let set = Loader.groupMap[group];
            if (set) {
                for (let k of set)
                    Loader._clearRes(k);
            }
        }
        clearUnLoaded() {
            if (this._queue.length == 0)
                return;
            let arr = this._queue.concat();
            this._queue.length = 0;
            for (let item of arr)
                item.onComplete(null);
        }
        cancelLoadByUrls(urls) {
            if (!urls)
                return;
            for (var i = 0, n = urls.length; i < n; i++) {
                this.cancelLoadByUrl(urls[i]);
            }
        }
        cancelLoadByUrl(url) {
            url = URL.formatURL(url);
            let i = this._queue.findIndex(item => item.url == url);
            if (i != -1) {
                let item = this._queue[i];
                this._queue.splice(i, 1);
                item.onComplete(null);
            }
        }
        loadPackage(path, arg2, arg3) {
            let progress;
            let remoteUrl;
            if (typeof (arg2) === "string") {
                remoteUrl = arg2;
                progress = arg3;
            }
            else {
                progress = arg3 || arg2;
            }
            if (remoteUrl) {
                if (!remoteUrl.endsWith("/"))
                    remoteUrl += "/";
                URL.basePaths[path.length > 0 ? (path + "/") : path] = remoteUrl;
                return this._loadSubFileConfig(path, null, progress);
            }
            else {
                if (LayaEnv.isPreview)
                    return Promise.resolve();
                let mini = ILaya.Browser.miniGameContext;
                if (mini == null) {
                    return this._loadSubFileConfig(path, null, progress);
                }
                else {
                    return this._loadMiniPackage(mini, path, progress).then(() => this._loadSubFileConfig(path, mini, progress));
                }
            }
        }
        _loadMiniPackage(mini, packName, progress) {
            if (mini.subPkgNameSeperator)
                packName = packName.replace(/\//g, mini.subPkgNameSeperator);
            if (!(packName.length > 0))
                return Promise.resolve();
            return new Promise((resolve, reject) => {
                let loadTask = mini.loadSubpackage({
                    name: packName,
                    success: (res) => {
                        resolve(res);
                    },
                    fail: (res) => {
                        reject(res);
                    }
                });
                loadTask.onProgressUpdate && loadTask.onProgressUpdate((res) => {
                    progress && progress(res);
                });
            });
        }
        _loadSubFileConfig(path, mini, onProgress) {
            if (mini && mini.subPkgPathSeperator)
                path = path.replace(/\//g, mini.subPkgPathSeperator);
            if (path.length > 0)
                path += "/";
            return this.fetch(path + "fileconfig.json", "json", onProgress).then(fileConfig => {
                let files = [];
                let col = fileConfig.files;
                for (let k in col) {
                    if (k.length > 0) {
                        for (let file of col[k])
                            files.push(k + "/" + file);
                    }
                    else {
                        for (let file of col[k])
                            files.push(file);
                    }
                }
                if (fileConfig.hash) {
                    let i = 0;
                    let version = URL.version;
                    for (let k of fileConfig.hash) {
                        if (k != null)
                            version[files[i]] = k;
                        i++;
                    }
                }
                let configs = fileConfig.config;
                let len = configs.length;
                let i = 0, j = 0, m = 0, k = 0, n = 0;
                let indice;
                let c;
                let metaMap = AssetDb.inst.metaMap;
                while (true) {
                    if (indice == null) {
                        if (i >= len)
                            break;
                        c = configs[i];
                        indice = c.i;
                        if (Array.isArray(indice))
                            n = indice.length;
                        else {
                            m = indice;
                            n = 0;
                            k = 1;
                        }
                        j = 0;
                    }
                    if (k == 0) {
                        if (j >= n) {
                            i++;
                            indice = null;
                            continue;
                        }
                        k = indice[j++];
                        if (k > 0) {
                            m = k;
                            k = 0;
                        }
                        else
                            k = -k;
                    }
                    else
                        k--;
                    let file = files[m + k];
                    switch (c.t) {
                        case 0:
                            metaMap[file] = c;
                            break;
                        case 1:
                            AtlasInfoManager.addAtlas(file, c.prefix, c.frames);
                            break;
                        case 2:
                            AssetDb.inst.shaderNameMap[c.shaderName] = file;
                            break;
                        case 3:
                            Loader.preLoadedMap[URL.formatURL(file)] = c;
                            break;
                    }
                }
                if (!mini && fileConfig.entry)
                    return ILaya.Browser.loadLib(URL.formatURL(path + fileConfig.entry));
                else
                    return Promise.resolve();
            });
        }
    }
    Loader.TEXT = "text";
    Loader.JSON = "json";
    Loader.XML = "xml";
    Loader.BUFFER = "arraybuffer";
    Loader.IMAGE = "image";
    Loader.SOUND = "sound";
    Loader.VIDEO = "video";
    Loader.ATLAS = "atlas";
    Loader.FONT = "font";
    Loader.TTF = "ttf";
    Loader.HIERARCHY = "HIERARCHY";
    Loader.MESH = "MESH";
    Loader.MATERIAL = "MATERIAL";
    Loader.TEXTURE2D = "TEXTURE2D";
    Loader.TEXTURECUBE = "TEXTURE2D";
    Loader.TEXTURE2DARRAY = "TEXTURE2D";
    Loader.ANIMATIONCLIP = "ANIMATIONCLIP";
    Loader.TERRAINHEIGHTDATA = "TERRAINHEIGHTDATA";
    Loader.TERRAINRES = "TERRAIN";
    Loader.SPINE = "SPINE";
    Loader.extMap = {};
    Loader.typeMap = {};
    Loader.hotReloadableFlags = {};
    Loader.assetTypeToLoadType = {
        "Image": Loader.IMAGE,
        "Texture2D": Loader.TEXTURE2D,
        "RenderTexture": Loader.TEXTURE2D,
        "TextureCube": Loader.TEXTURECUBE,
        "Prefab": Loader.HIERARCHY,
        "Material": Loader.MATERIAL,
        "Mesh": Loader.MESH,
        "Spine": Loader.SPINE,
    };
    Loader.downloader = new Downloader();
    Loader.groupMap = {};
    Loader.loadedMap = {};
    Loader.preLoadedMap = {};
    class LoadTask {
        constructor() {
            this.options = {};
            this.onProgress = new Delegate();
            this.onComplete = new Delegate();
            this.progress = new BatchProgress((progress) => this.onProgress.invoke(progress));
        }
        reset() {
            for (let k in this.options)
                delete this.options[k];
            this.onProgress.clear();
            this.onComplete.clear();
            this.progress.reset();
            this.obsoluteInst = null;
            this.result = null;
        }
    }
    const loadTaskPool = [];
    const dummyOptions = {};

    class ClassUtils {
        static regClass(className, classDef) {
            ClassUtils._classMap[className] = classDef;
        }
        static getClass(className) {
            return ClassUtils._classMap[className];
        }
        static getInstance(className) {
            var compClass = ClassUtils.getClass(className);
            if (compClass)
                return new compClass();
            else
                console.warn("[error] Undefined class:", className);
            return null;
        }
    }
    ClassUtils._classMap = {};

    function dummy() { }
    function regClass(assetId) {
        return function (constructor) {
            ClassUtils.regClass(assetId, constructor);
        };
    }
    function classInfo(info) { return dummy; }
    function runInEditor(constructor) { }
    function allowMultiple(constructor) {
        constructor.prototype._$singleton = false;
    }
    function property(info) { return dummy; }
    function regLoader(fileExtensions, type, hotReloadable) {
        return function (constructor) {
            Loader.registerLoader(fileExtensions, constructor, type, hotReloadable);
        };
    }

    class Const {
    }
    Const.ENUM_TEXTALIGN_DEFAULT = 0;
    Const.ENUM_TEXTALIGN_CENTER = 1;
    Const.ENUM_TEXTALIGN_RIGHT = 2;
    Const.INDEX_BYTES = 2;
    Const.MAX_CLIP_SIZE = 99999999;
    class NodeFlags {
    }
    NodeFlags.NOT_ACTIVE = 0x01;
    NodeFlags.ACTIVE_INHIERARCHY = 0x02;
    NodeFlags.AWAKED = 0x04;
    NodeFlags.NOT_READY = 0x08;
    NodeFlags.DISPLAY = 0x10;
    NodeFlags.HAS_ZORDER = 0x20;
    NodeFlags.HAS_MOUSE = 0x40;
    NodeFlags.DISPLAYED_INSTAGE = 0x80;
    NodeFlags.DRAWCALL_OPTIMIZE = 0x100;
    NodeFlags.PROCESS_COLLISIONS = 0x200;
    NodeFlags.PROCESS_TRIGGERS = 0x400;
    NodeFlags.HAS_SCRIPT = 0x800;
    NodeFlags.ESCAPE_DRAWING_TO_TEXTURE = 0x1000;
    NodeFlags.DISABLE_INNER_CLIPPING = 0x2000;
    NodeFlags.DISABLE_OUTER_CLIPPING = 0x4000;
    NodeFlags.DISABLE_VISIBILITY = 0x8000;
    NodeFlags.EDITING_NODE = 0x10000;
    NodeFlags.HIDE_BY_EDITOR = 0x20000;
    NodeFlags.LOCK_BY_EDITOR = 0x40000;
    class HideFlags {
    }
    HideFlags.HideInHierarchy = 0x1;
    HideFlags.HideInInspector = 0x2;
    HideFlags.DontSave = 0x4;
    HideFlags.HideAndDontSave = 0x7;

    class Component {
        get hideFlags() {
            return this._hideFlags;
        }
        set hideFlags(value) {
            this._hideFlags = value;
        }
        constructor() {
            var _a;
            this._hideFlags = 0;
            this._status = 0;
            this._enabled = true;
            this._id = Utils.getGID();
            this._singleton = (_a = Object.getPrototypeOf(this)._$singleton) !== null && _a !== void 0 ? _a : true;
            this._initialize();
        }
        _initialize() {
            this._extra = {};
        }
        hasHideFlag(flag) {
            return (this._hideFlags & flag) != 0;
        }
        get id() {
            return this._id;
        }
        get enabled() {
            return this._enabled;
        }
        set enabled(value) {
            if (this._enabled != value) {
                this._enabled = value;
                if (this.owner)
                    this._setActive(value && this.owner.activeInHierarchy);
            }
        }
        get awaked() {
            return this._status > 0;
        }
        get destroyed() {
            return this._status == 4;
        }
        _isScript() {
            return false;
        }
        _resetComp() {
            this._enabled = true;
            this._status = 0;
            this._enableState = false;
            this.owner = null;
        }
        _setOwner(node) {
            if (this._status != 0) {
                throw new Error('reuse a destroyed component');
            }
            this.owner = node;
            if (this._isScript())
                node._setBit(NodeFlags.HAS_SCRIPT, true);
            this._onAdded();
            this.onAdded();
        }
        _onAdded() {
        }
        _onAwake() {
        }
        _onEnable() {
            this.onEnable();
        }
        _onDisable() {
            this.onDisable();
        }
        _onDestroy() {
        }
        _parse(data, interactMap = null) {
        }
        _parseInteractive(data = null, spriteMap = null) {
        }
        _cloneTo(dest) {
        }
        _setActive(value) {
            var _a;
            if (value) {
                if (this._status == 0) {
                    this._status = 1;
                    if (LayaEnv.isPlaying || this.runInEditor) {
                        this._onAwake();
                        this.onAwake();
                    }
                }
                if (this._enabled && !this._enableState) {
                    this._enableState = true;
                    if (LayaEnv.isPlaying || this.runInEditor) {
                        this._driver = ((_a = (this.owner._is3D && this.owner._scene)) === null || _a === void 0 ? void 0 : _a._componentDriver) || ILaya.stage._componentDriver;
                        this._driver.add(this);
                        if (LayaEnv.isPlaying && this._isScript())
                            this.setupScript();
                        this._onEnable();
                    }
                }
            }
            else if (this._enableState) {
                this._enableState = false;
                if (LayaEnv.isPlaying || this.runInEditor) {
                    if (this._driver)
                        this._driver.remove(this);
                    ILaya.stage.offAllCaller(this);
                    this._onDisable();
                }
            }
        }
        setupScript() {
        }
        destroy() {
            if (this._status == 4)
                return;
            if (this.owner)
                this.owner._destroyComponent(this);
            else if (!this.destroyed)
                this._destroy(true);
        }
        _destroy(second) {
            if (second) {
                if (LayaEnv.isPlaying || this.runInEditor) {
                    this._onDestroy();
                    this.onDestroy();
                    if (this.onReset) {
                        this.onReset();
                        this._resetComp();
                        Pool.recoverByClass(this);
                    }
                }
                return;
            }
            this._setActive(false);
            this._status = 4;
            if (LayaEnv.isPlaying || this.runInEditor)
                (this._driver || ILaya.stage._componentDriver)._toDestroys.add(this);
            this._driver = null;
        }
        onAdded() {
        }
        onAwake() {
        }
        onEnable() {
        }
        onDisable() {
        }
        onDestroy() {
        }
    }

    exports.RenderParams = void 0;
    (function (RenderParams) {
        RenderParams[RenderParams["Max_Active_Texture_Count"] = 0] = "Max_Active_Texture_Count";
        RenderParams[RenderParams["Max_Uniform_Count"] = 1] = "Max_Uniform_Count";
        RenderParams[RenderParams["Max_AnisoLevel_Count"] = 2] = "Max_AnisoLevel_Count";
        RenderParams[RenderParams["MAX_Texture_Size"] = 3] = "MAX_Texture_Size";
        RenderParams[RenderParams["MAX_Texture_Image_Uint"] = 4] = "MAX_Texture_Image_Uint";
        RenderParams[RenderParams["SHADER_CAPAILITY_LEVEL"] = 5] = "SHADER_CAPAILITY_LEVEL";
        RenderParams[RenderParams["FLOAT"] = 6] = "FLOAT";
        RenderParams[RenderParams["UNSIGNED_BYTE"] = 7] = "UNSIGNED_BYTE";
        RenderParams[RenderParams["BYTE"] = 8] = "BYTE";
        RenderParams[RenderParams["UNSIGNED_SHORT"] = 9] = "UNSIGNED_SHORT";
    })(exports.RenderParams || (exports.RenderParams = {}));

    class VertexElementFormat {
        static __init__() {
            VertexElementFormat._elementInfos = {
                "single": [1, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "vector2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "vector3": [3, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "vector4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "color": [4, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "byte4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 0],
                "byte3": [3, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 0],
                "byte2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 0],
                "byte": [1, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 0],
                "short2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_SHORT), 0],
                "short4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_SHORT), 0],
                "normalizedshort2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_SHORT), 1],
                "normalizedshort4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_SHORT), 1],
                "halfvector2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "halfvector4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "nbyte4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.BYTE), 1],
                "ubyte4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 1],
            };
        }
        static getElementInfos(element) {
            var info = VertexElementFormat._elementInfos[element];
            if (info)
                return info;
            else
                throw "VertexElementFormat: this vertexElementFormat is not implement.";
        }
    }
    VertexElementFormat.Single = "single";
    VertexElementFormat.Vector2 = "vector2";
    VertexElementFormat.Vector3 = "vector3";
    VertexElementFormat.Vector4 = "vector4";
    VertexElementFormat.Color = "color";
    VertexElementFormat.Byte4 = "byte4";
    VertexElementFormat.Byte3 = "byte3";
    VertexElementFormat.Byte2 = "byte2";
    VertexElementFormat.ByteOne = "byte";
    VertexElementFormat.Short2 = "short2";
    VertexElementFormat.Short4 = "short4";
    VertexElementFormat.NormalizedShort2 = "normalizedshort2";
    VertexElementFormat.NormalizedShort4 = "normalizedshort4";
    VertexElementFormat.HalfVector2 = "halfvector2";
    VertexElementFormat.HalfVector4 = "halfvector4";
    VertexElementFormat.NorByte4 = "nbyte4";
    VertexElementFormat.NorUByte4 = "ubyte4";

    class VertexStateContext {
    }
    class VertexDeclaration {
        get id() {
            return this._id;
        }
        get vertexStride() {
            return this._vertexStride;
        }
        get vertexElementCount() {
            return this._vertexElements.length;
        }
        constructor(vertexStride, vertexElements) {
            this._id = ++VertexDeclaration._uniqueIDCounter;
            this._vertexElementsDic = {};
            this._vertexStride = vertexStride;
            this._vertexElements = vertexElements;
            this._VAElements = [];
            var count = vertexElements.length;
            this._shaderValues = {};
            for (var j = 0; j < count; j++) {
                var vertexElement = vertexElements[j];
                var name = vertexElement._elementUsage;
                this._vertexElementsDic[name] = vertexElement;
                var value = new VertexStateContext();
                var elmentInfo = VertexElementFormat.getElementInfos(vertexElement._elementFormat);
                value.elementString = vertexElement._elementFormat;
                value.elementCount = elmentInfo[0];
                value.elementType = elmentInfo[1];
                value.normalized = elmentInfo[2];
                value.vertexStride = this._vertexStride;
                value.elementOffset = vertexElement._offset;
                this._shaderValues[name] = value;
                this._VAElements.push({ format: vertexElement._elementFormat, stride: vertexElement._offset, shaderLocation: name });
            }
        }
        getVertexElementByIndex(index) {
            return this._vertexElements[index];
        }
        getVertexElementByUsage(usage) {
            return this._vertexElementsDic[usage];
        }
    }
    VertexDeclaration._uniqueIDCounter = 1;

    class VertexElement {
        get offset() {
            return this._offset;
        }
        get elementFormat() {
            return this._elementFormat;
        }
        get elementUsage() {
            return this._elementUsage;
        }
        constructor(offset, elementFormat, elementUsage) {
            this._offset = offset;
            this._elementFormat = elementFormat;
            this._elementUsage = elementUsage;
        }
    }

    class Sprite2DGeometry {
        constructor(stride, vballoc, iballoc) {
            this._stride = 0;
            this._vertNum = 0;
            this._indexNum = 0;
            this._stride = stride;
            this._VBBuff = new ArrayBuffer(vballoc || 32);
            this._IBBuff = new ArrayBuffer(iballoc || 8);
            this.onVBRealloc(this._VBBuff);
            this.onIBRealloc(this._IBBuff);
        }
        get vbBuffer() {
            return this._VBBuff;
        }
        get ibBuffer() {
            return this._IBBuff;
        }
        get indexNum() {
            return this._indexNum;
        }
        get vertexNum() {
            return this._vertNum;
        }
        clearMesh() {
            this._vertNum = 0;
            this._indexNum = 0;
        }
        expVBSize(len) {
            if (len) {
                let curLen = this._vertNum * this._stride;
                if (curLen + len > this._VBBuff.byteLength) {
                    let old = this._VBBuff;
                    this._VBBuff = new ArrayBuffer(curLen + len * 8);
                    (new Uint8Array(this._VBBuff, 0, curLen)).set(new Uint8Array(old, 0, curLen));
                    this.onVBRealloc(this._VBBuff);
                }
            }
        }
        expIBSize(len) {
            if (len) {
                let curlen = this._indexNum * 2;
                if (curlen + len > this._IBBuff.byteLength) {
                    let old = this._IBBuff;
                    this._IBBuff = new ArrayBuffer(curlen + len * 8);
                    (new Uint8Array(this._IBBuff, 0, curlen)).set(new Uint8Array(old, 0, curlen));
                    this.onIBRealloc(this._IBBuff);
                }
            }
        }
    }

    function createQuadIB(quadNum) {
        let ibbuf = new Byte(quadNum * 6 * 2);
        let ib = new Uint16Array(ibbuf.buffer);
        var idx = 0;
        var curvert = 0;
        for (var i = 0; i < quadNum; i++) {
            ib[idx++] = curvert;
            ib[idx++] = curvert + 2;
            ib[idx++] = curvert + 1;
            ib[idx++] = curvert;
            ib[idx++] = curvert + 3;
            ib[idx++] = curvert + 2;
            curvert += 4;
        }
        return ib;
    }
    class MeshQuadTexture extends Sprite2DGeometry {
        static __int__() {
            MeshQuadTexture._fixib = createQuadIB(MeshQuadTexture._maxIB);
            MeshQuadTexture.VertexDeclarition = new VertexDeclaration(48, [
                new VertexElement(0, VertexElementFormat.Vector4, 0),
                new VertexElement(16, VertexElementFormat.Vector4, 1),
                new VertexElement(32, VertexElementFormat.Vector4, 2),
            ]);
        }
        constructor(vballoc = 4) {
            super(MeshQuadTexture.const_stride, vballoc, 4);
            this._curVBPos = 0;
        }
        onVBRealloc(buff) {
            this._vbFloat32Array = new Float32Array(buff);
        }
        onIBRealloc(buff) {
        }
        addQuad(pos, uv, color, useTex) {
            this.expVBSize(MeshQuadTexture.const_stride);
            var vbdata = this._vbFloat32Array;
            let r = ((color >>> 16) & 0xff) / 255.0;
            let g = ((color >>> 8) & 0xff) / 255.0;
            let b = (color & 0xff) / 255.0;
            let a = (color >>> 24) / 255.0;
            var cpos = this._curVBPos;
            var useTexVal = useTex ? 1 : 0;
            vbdata[cpos++] = pos[0];
            vbdata[cpos++] = pos[1];
            vbdata[cpos++] = uv[0];
            vbdata[cpos++] = uv[1];
            vbdata[cpos++] = b;
            vbdata[cpos++] = g;
            vbdata[cpos++] = r;
            vbdata[cpos++] = a;
            vbdata[cpos++] = useTexVal;
            cpos += 3;
            vbdata[cpos++] = pos[2];
            vbdata[cpos++] = pos[3];
            vbdata[cpos++] = uv[2];
            vbdata[cpos++] = uv[3];
            vbdata[cpos++] = b;
            vbdata[cpos++] = g;
            vbdata[cpos++] = r;
            vbdata[cpos++] = a;
            vbdata[cpos++] = useTexVal;
            cpos += 3;
            vbdata[cpos++] = pos[4];
            vbdata[cpos++] = pos[5];
            vbdata[cpos++] = uv[4];
            vbdata[cpos++] = uv[5];
            vbdata[cpos++] = b;
            vbdata[cpos++] = g;
            vbdata[cpos++] = r;
            vbdata[cpos++] = a;
            vbdata[cpos++] = useTexVal;
            cpos += 3;
            vbdata[cpos++] = pos[6];
            vbdata[cpos++] = pos[7];
            vbdata[cpos++] = uv[6];
            vbdata[cpos++] = uv[7];
            vbdata[cpos++] = b;
            vbdata[cpos++] = g;
            vbdata[cpos++] = r;
            vbdata[cpos++] = a;
            vbdata[cpos++] = useTexVal;
            cpos += 3;
            this._curVBPos = cpos;
            this._vertNum += 4;
            this._indexNum += 6;
        }
        clearMesh() {
            super.clearMesh();
            this._curVBPos = 0;
        }
        get ibBuffer() {
            return MeshQuadTexture._fixib.buffer;
        }
        get vertexDeclarition() {
            return MeshQuadTexture.VertexDeclarition;
        }
    }
    MeshQuadTexture.const_stride = 48;
    MeshQuadTexture._maxIB = 16 * 1024;

    class Filter extends EventDispatcher {
        constructor() {
            super();
            this.left = 0;
            this.top = 0;
            this.width = 0;
            this.height = 0;
            let rect1 = this._rectMeshNormY = new MeshQuadTexture();
            rect1.addQuad([0, 0, 1, 0, 1, 1, 0, 1], [0, 0, 1, 0, 1, 1, 0, 1], 0xffffffff, true);
            this._rectMeshVBNormY = new Float32Array(rect1.vbBuffer);
            let rectInvY = this._rectMeshInvY = new MeshQuadTexture();
            rectInvY.addQuad([0, 0, 1, 0, 1, 1, 0, 1], [0, 1, 1, 1, 1, 0, 0, 0], 0xffffffff, true);
            this._rectMeshVBInvY = new Float32Array(rectInvY.vbBuffer);
            this.useFlipY(false);
        }
        onChange() {
            this.event(Filter.EVENT_CHANGE);
        }
        useFlipY(b) {
            this._rectMesh = b ? this._rectMeshInvY : this._rectMeshNormY;
            this._rectMeshVB = b ? this._rectMeshVBInvY : this._rectMeshVBNormY;
        }
        set render2D(r) {
            this._render2D = r;
        }
        get type() { return -1; }
    }
    Filter.COLOR = 0x20;
    Filter.EVENT_CHANGE = 'change';
    Filter._filter = function (sprite, context, x, y) {
        var next = this._next;
        if (!next)
            return;
        var filters = sprite.filters, len = filters.length;
        if (len == 1 && (filters[0].type == Filter.COLOR)) {
            context.save();
            context.setColorFilter(filters[0]);
            next._fun.call(next, sprite, context, x, y);
            context.restore();
            return;
        }
        let cache = sprite._getCacheStyle();
        let rtOffX = 0, rtOffY = 0;
        if (this._renderNextToCacheRT(sprite, context, 16, 16, 16, 16)) {
            rtOffX = cache.cacheRect.x;
            rtOffY = cache.cacheRect.y;
            let src = cache.renderTexture;
            let dst = src;
            let width = src.width;
            let height = src.height;
            let lastRT = context.render2D.out;
            for (let i = 0; i < len; i++) {
                src = dst;
                var filter = filters[i];
                filter._render2D = context.render2D;
                filter.useFlipY(i != 0);
                filter.render(src, width, height);
                width = filter.width;
                height = filter.height;
                dst = filter.texture;
                rtOffX += filter.left;
                rtOffY += filter.top;
            }
            context.render2D.setRenderTarget(lastRT);
            cache.renderTexture = dst;
            cache.renderTexOffx = rtOffX;
            cache.renderTexOffy = rtOffY;
        }
        cache.renderTexture && context._drawRenderTexture(cache.renderTexture, x + cache.renderTexOffx, y + cache.renderTexOffy, cache.renderTexture.width, cache.renderTexture.height, null, 1.0, RenderTexture2D.defuv);
    };

    class GrahamScan {
        static multiply(p1, p2, p0) {
            return ((p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y));
        }
        static dis(p1, p2) {
            return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
        }
        static _getPoints(count, tempUse = false, rst = null) {
            if (!GrahamScan._mPointList)
                GrahamScan._mPointList = [];
            while (GrahamScan._mPointList.length < count)
                GrahamScan._mPointList.push(new Point());
            if (!rst)
                rst = [];
            rst.length = 0;
            if (tempUse) {
                GrahamScan.getFrom(rst, GrahamScan._mPointList, count);
            }
            else {
                GrahamScan.getFromR(rst, GrahamScan._mPointList, count);
            }
            return rst;
        }
        static getFrom(rst, src, count) {
            var i;
            for (i = 0; i < count; i++) {
                rst.push(src[i]);
            }
            return rst;
        }
        static getFromR(rst, src, count) {
            var i;
            for (i = 0; i < count; i++) {
                rst.push(src.pop());
            }
            return rst;
        }
        static pListToPointList(pList, tempUse = false) {
            var i, len = pList.length / 2, rst = GrahamScan._getPoints(len, tempUse, GrahamScan._tempPointList);
            for (i = 0; i < len; i++) {
                rst[i].setTo(pList[i + i], pList[i + i + 1]);
            }
            return rst;
        }
        static pointListToPlist(pointList) {
            var i, len = pointList.length, rst = GrahamScan._temPList, tPoint;
            rst.length = 0;
            for (i = 0; i < len; i++) {
                tPoint = pointList[i];
                rst.push(tPoint.x, tPoint.y);
            }
            return rst;
        }
        static scanPList(pList) {
            return Utils.copyArray(pList, GrahamScan.pointListToPlist(GrahamScan.scan(GrahamScan.pListToPointList(pList, true))));
        }
        static scan(PointSet) {
            var i, j, k = 0, tmp, n = PointSet.length, ch;
            var _tmpDic = {};
            var key;
            ch = GrahamScan._temArr;
            ch.length = 0;
            n = PointSet.length;
            for (i = n - 1; i >= 0; i--) {
                tmp = PointSet[i];
                key = tmp.x + "_" + tmp.y;
                if (!(key in _tmpDic)) {
                    _tmpDic[key] = true;
                    ch.push(tmp);
                }
            }
            n = ch.length;
            Utils.copyArray(PointSet, ch);
            for (i = 1; i < n; i++)
                if ((PointSet[i].y < PointSet[k].y) || ((PointSet[i].y == PointSet[k].y) && (PointSet[i].x < PointSet[k].x)))
                    k = i;
            tmp = PointSet[0];
            PointSet[0] = PointSet[k];
            PointSet[k] = tmp;
            for (i = 1; i < n - 1; i++) {
                k = i;
                for (j = i + 1; j < n; j++)
                    if ((GrahamScan.multiply(PointSet[j], PointSet[k], PointSet[0]) > 0) || ((GrahamScan.multiply(PointSet[j], PointSet[k], PointSet[0]) == 0) && (GrahamScan.dis(PointSet[0], PointSet[j]) < GrahamScan.dis(PointSet[0], PointSet[k]))))
                        k = j;
                tmp = PointSet[i];
                PointSet[i] = PointSet[k];
                PointSet[k] = tmp;
            }
            ch = GrahamScan._temArr;
            ch.length = 0;
            if (PointSet.length < 3) {
                return Utils.copyArray(ch, PointSet);
            }
            ch.push(PointSet[0], PointSet[1], PointSet[2]);
            for (i = 3; i < n; i++) {
                while (ch.length >= 2 && GrahamScan.multiply(PointSet[i], ch[ch.length - 1], ch[ch.length - 2]) >= 0)
                    ch.pop();
                PointSet[i] && ch.push(PointSet[i]);
            }
            return ch;
        }
    }
    GrahamScan._tempPointList = [];
    GrahamScan._temPList = [];
    GrahamScan._temArr = [];

    class SpriteConst {
    }
    SpriteConst.ALPHA = 0x01;
    SpriteConst.TRANSFORM = 0x02;
    SpriteConst.BLEND = 0x04;
    SpriteConst.CANVAS = 0x08;
    SpriteConst.FILTERS = 0x10;
    SpriteConst.MASK = 0x20;
    SpriteConst.CLIP = 0x40;
    SpriteConst.TEXTURE = 0x80;
    SpriteConst.GRAPHICS = 0x100;
    SpriteConst.RENDERNODE2D = 0x200;
    SpriteConst.CUSTOM = 0x400;
    SpriteConst.HITAREA = 0x800;
    SpriteConst.CHILDS = 0x1000;
    SpriteConst.REPAINT_NONE = 0;
    SpriteConst.REPAINT_NODE = 0x01;
    SpriteConst.REPAINT_CACHE = 0x02;
    SpriteConst.REPAINT_ALL = 0x03;

    exports.GPUEngineStatisticsInfo = void 0;
    (function (GPUEngineStatisticsInfo) {
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["C_UniformBufferUploadCount"] = 0] = "C_UniformBufferUploadCount";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["C_GeometryBufferUploadCount"] = 1] = "C_GeometryBufferUploadCount";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["C_TriangleCount"] = 2] = "C_TriangleCount";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["C_SetRenderPassCount"] = 3] = "C_SetRenderPassCount";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["C_DrawCallCount"] = 4] = "C_DrawCallCount";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["C_Instancing_DrawCallCount"] = 5] = "C_Instancing_DrawCallCount";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["C_ShaderCompile"] = 6] = "C_ShaderCompile";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["T_ShaderCompile"] = 7] = "T_ShaderCompile";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["FrameClearCount"] = 8] = "FrameClearCount";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_GPUMemory"] = 9] = "M_GPUMemory";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_GPUBuffer"] = 10] = "M_GPUBuffer";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_VertexBuffer"] = 11] = "M_VertexBuffer";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_IndexBuffer"] = 12] = "M_IndexBuffer";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_UniformBlockBuffer"] = 13] = "M_UniformBlockBuffer";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_GPUBuffer"] = 14] = "RC_GPUBuffer";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_VertexBuffer"] = 15] = "RC_VertexBuffer";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_IndexBuffer"] = 16] = "RC_IndexBuffer";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_UniformBlockBuffer"] = 17] = "RC_UniformBlockBuffer";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_ALLTexture"] = 18] = "M_ALLTexture";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_Texture2D"] = 19] = "M_Texture2D";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_TextureCube"] = 20] = "M_TextureCube";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_Texture3D"] = 21] = "M_Texture3D";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_Texture2DArray"] = 22] = "M_Texture2DArray";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_ALLTexture"] = 23] = "RC_ALLTexture";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_Texture2D"] = 24] = "RC_Texture2D";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_TextureCube"] = 25] = "RC_TextureCube";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_Texture3D"] = 26] = "RC_Texture3D";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_Texture2DArray"] = 27] = "RC_Texture2DArray";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_ALLRenderTexture"] = 28] = "M_ALLRenderTexture";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_ALLRenderTexture"] = 29] = "RC_ALLRenderTexture";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["Count"] = 30] = "Count";
    })(exports.GPUEngineStatisticsInfo || (exports.GPUEngineStatisticsInfo = {}));
    exports.RenderPassStatisticsInfo = void 0;
    (function (RenderPassStatisticsInfo) {
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_CameraRender"] = 0] = "T_CameraRender";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_Render_OpaqueRender"] = 1] = "T_Render_OpaqueRender";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_Render_TransparentRender"] = 2] = "T_Render_TransparentRender";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_Render_PostProcess"] = 3] = "T_Render_PostProcess";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_Render_CameraEventCMD"] = 4] = "T_Render_CameraEventCMD";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_Render_ShadowPassMode"] = 5] = "T_Render_ShadowPassMode";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_Render_CameraOtherDest"] = 6] = "T_Render_CameraOtherDest";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_RenderPreUpdate"] = 7] = "T_RenderPreUpdate";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_OtherRender"] = 8] = "T_OtherRender";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_OnlyMeshRender"] = 9] = "T_OnlyMeshRender";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_OnlySkinnedMeshRender"] = 10] = "T_OnlySkinnedMeshRender";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_OnlyShurikenParticleRender"] = 11] = "T_OnlyShurikenParticleRender";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_CameraMainCull"] = 12] = "T_CameraMainCull";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_ShadowMapCull"] = 13] = "T_ShadowMapCull";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["RenderPassStatisticCount"] = 14] = "RenderPassStatisticCount";
    })(exports.RenderPassStatisticsInfo || (exports.RenderPassStatisticsInfo = {}));

    class Stat {
        static show(x, y, views) {
            if (!Stat.checkUI())
                return;
            this.hide();
            Stat._show = true;
            LayaGL.renderEngine._enableStatistics = true;
            Stat._currentShowArray = views || Stat.AllShow;
            Stat._statUI.show(x, y, Stat._currentShowArray);
            ILaya.systemTimer.frameLoop(1, null, Stat.loop);
            ILaya.timer.frameLoop(1, null, Stat.clear);
        }
        static showToggle(x, y, views) {
            if (!Stat.checkUI())
                return;
            this.hide();
            Stat._show = true;
            Stat._currentToggleArray = views;
            Stat._statUI.showToggle(x, y, views);
            ILaya.systemTimer.frameLoop(1, null, Stat.loop);
            ILaya.timer.frameLoop(1, null, Stat.clear);
        }
        static checkUI() {
            if (!Stat._statUI) {
                let cls = ClassUtils.getClass("StatUI");
                if (!cls) {
                    console.error("StatUI not found");
                    return false;
                }
                Stat._statUI = new cls();
            }
            return true;
        }
        static hide() {
            if (!Stat._show)
                return;
            Stat._show = false;
            Stat._currentShowArray = null;
            Stat._currentToggleArray = null;
            ILaya.timer.clear(null, Stat.loop);
            ILaya.timer.clear(null, Stat.clear);
            if (Stat._statUI)
                Stat._statUI.hide();
        }
        static loop() {
            Stat._count++;
            let timer = Browser.now();
            if (timer - Stat._timer < 1000)
                return;
            let count = Stat._count;
            Stat.FPS = Math.round((count * 1000) / (timer - Stat._timer));
            if (Stat._show) {
                Stat.updateEngineData();
                let delay = Stat.FPS > 0 ? Math.floor(1000 / Stat.FPS).toString() : " ";
                Stat._fpsStr = Stat.FPS + (Stat.renderSlow ? " slow" : "") + " " + delay + "ms";
                Stat._statUI.update();
            }
            Stat._count = 0;
            Stat._timer = timer;
        }
        static updateEngineData() {
            Stat.trianglesFaces += LayaGL.renderEngine.getStatisticsInfo(exports.GPUEngineStatisticsInfo.C_TriangleCount);
            Stat.drawCall += LayaGL.renderEngine.getStatisticsInfo(exports.GPUEngineStatisticsInfo.C_DrawCallCount);
            Stat.instanceDrawCall += LayaGL.renderEngine.getStatisticsInfo(exports.GPUEngineStatisticsInfo.C_Instancing_DrawCallCount);
            Stat.gpuMemory = LayaGL.renderEngine.getStatisticsInfo(exports.GPUEngineStatisticsInfo.M_GPUMemory);
            Stat.textureMemory = LayaGL.renderEngine.getStatisticsInfo(exports.GPUEngineStatisticsInfo.M_ALLTexture);
            Stat.renderTextureMemory = LayaGL.renderEngine.getStatisticsInfo(exports.GPUEngineStatisticsInfo.M_ALLRenderTexture);
            Stat.bufferMemory = LayaGL.renderEngine.getStatisticsInfo(exports.GPUEngineStatisticsInfo.M_GPUBuffer);
        }
        static clear() {
            if (!Stat._currentShowArray || Stat._count)
                return;
            Stat._currentShowArray.forEach(element => {
                if (element.mode == "average")
                    Stat[element.value] = 0;
            });
            LayaGL.renderEngine.clearStatisticsInfo();
            Stat.renderPassStatArray.fill(0);
        }
        static render(ctx, x, y) {
            if (Stat._show)
                Stat._statUI.render(ctx, x, y);
        }
    }
    Stat.FPSStatUIParams = { title: "FPS", value: "_fpsStr", color: "yellow", units: "int", mode: "summit" };
    Stat.NodeStatUIParams = { title: "Node", value: "spriteCount", color: "white", units: "int", mode: "summit" };
    Stat.Sprite3DStatUIParams = { title: "Sprite3D", value: "sprite3DCount", color: "white", units: "int", mode: "summit" };
    Stat.DrawCall = { title: "DrawCall", value: "drawCall", color: "white", units: "int", mode: "average" };
    Stat.TriangleFace = { title: "TriangleFace", value: "trianglesFaces", color: "white", units: "int", mode: "average" };
    Stat.RenderNode = { title: "RenderNode", value: "renderNode", color: "white", units: "int", mode: "summit" };
    Stat.SkinRenderNode = { title: "SkinRenderNode", value: "skinRenderNode", color: "white", units: "int", mode: "summit" };
    Stat.ParticleRenderNode = { title: "ParticleRenderNode", value: "particleRenderNode", color: "white", units: "int", mode: "summit" };
    Stat.FrustumCulling = { title: "FrustumCulling", value: "frustumCulling", color: "white", units: "int", mode: "average" };
    Stat.UniformUpload = { title: "UniformUpload", value: "uniformUpload", color: "white", units: "int", mode: "average" };
    Stat.OpaqueDrawCall = { title: "OpaqueDrawCall", value: "opaqueDrawCall", color: "white", units: "int", mode: "average" };
    Stat.TransDrawCall = { title: "TransDrawCall", value: "transDrawCall", color: "white", units: "int", mode: "average" };
    Stat.DepthCastDrawCall = { title: "DepthCastDrawCall", value: "depthCastDrawCall", color: "white", units: "int", mode: "average" };
    Stat.ShadowDrawCall = { title: "ShadowDrawCall", value: "shadowMapDrawCall", color: "white", units: "int", mode: "average" };
    Stat.InstanceDrawCall = { title: "InstanceDrawCall", value: "instanceDrawCall", color: "white", units: "int", mode: "average" };
    Stat.CMDDrawCall = { title: "CMDDrawCall", value: "cmdDrawCall", color: "white", units: "int", mode: "average" };
    Stat.BlitDrawCall = { title: "BlitDrawCall", value: "blitDrawCall", color: "white", units: "int", mode: "average" };
    Stat.GPUMemory = { title: "GPUMemory", value: "gpuMemory", color: "white", units: "M", mode: "summit" };
    Stat.TextureMemeory = { title: "TextureMemory", value: "textureMemory", color: "white", units: "M", mode: "summit" };
    Stat.RenderTextureMemory = { title: "RenderTextureMemory", value: "renderTextureMemory", color: "white", units: "M", mode: "summit" };
    Stat.BufferMemory = { title: "BufferMemory", value: "bufferMemory", color: "white", units: "M", mode: "summit" };
    Stat.uploadUniformNum = { title: "UploadUniformNum", value: "uploadUniform", color: "white", units: "int", mode: "average" };
    Stat.AllShow = [Stat.FPSStatUIParams, Stat.NodeStatUIParams, Stat.Sprite3DStatUIParams, Stat.DrawCall, Stat.TriangleFace, Stat.RenderNode, Stat.SkinRenderNode, Stat.ParticleRenderNode,
        Stat.FrustumCulling, Stat.OpaqueDrawCall, Stat.TransDrawCall, Stat.ShadowDrawCall, Stat.DepthCastDrawCall, Stat.InstanceDrawCall, Stat.CMDDrawCall, Stat.BlitDrawCall, Stat.GPUMemory, Stat.TextureMemeory, Stat.RenderTextureMemory, Stat.BufferMemory, Stat.uploadUniformNum];
    Stat.memoryShow = [Stat.GPUMemory, Stat.TextureMemeory, Stat.RenderTextureMemory, Stat.BufferMemory];
    Stat.renderShow = [Stat.DrawCall, Stat.TriangleFace, Stat.OpaqueDrawCall, Stat.TransDrawCall, Stat.ShadowDrawCall, Stat.DepthCastDrawCall, Stat.InstanceDrawCall, Stat.CMDDrawCall, Stat.BlitDrawCall];
    Stat.toogle_Shadow = { title: "Shadow", value: "enableShadow", color: "white" };
    Stat.toogle_MulLight = { title: "MulLight", value: "enableMulLight", color: "white" };
    Stat.toogle_Light = { title: "Light", value: "enableLight", color: "white" };
    Stat.toogle_Postprocess = { title: "Postprocess", value: "enablePostprocess", color: "white" };
    Stat.toogle_AnimatorUpdate = { title: "AnimatorUpdate", value: "enableAnimatorUpdate", color: "white" };
    Stat.toogle_PhysicsUpdate = { title: "PhysicsUpdate", value: "enablePhysicsUpdate", color: "white" };
    Stat.toogle_Skin = { title: "Skin", value: "enableSkin", color: "white" };
    Stat.toogle_Transparent = { title: "Transparent", value: "enableTransparent", color: "white" };
    Stat.toogle_Particle = { title: "Particle", value: "enableParticle", color: "white" };
    Stat.toogle_msaa = { title: "MSAA", value: "enablemsaa", color: "white" };
    Stat.toogle_CameraCMD = { title: "CameraCMD", value: "enableCameraCMD", color: "white" };
    Stat.toogle_Opaque = { title: "Opaque", value: "enableOpaque", color: "white" };
    Stat.AllToggle = [Stat.toogle_Shadow, Stat.toogle_Light, Stat.toogle_MulLight, Stat.toogle_Postprocess, Stat.toogle_AnimatorUpdate, Stat.toogle_PhysicsUpdate, Stat.toogle_Opaque, Stat.toogle_Transparent, Stat.toogle_CameraCMD, Stat.toogle_Skin, Stat.toogle_Particle, Stat.toogle_msaa];
    Stat.RenderModeToggle = [Stat.toogle_Shadow, Stat.toogle_Light, Stat.toogle_MulLight, Stat.toogle_Postprocess, Stat.toogle_AnimatorUpdate, Stat.toogle_PhysicsUpdate];
    Stat.RenderFuncToggle = [Stat.toogle_Opaque, Stat.toogle_Transparent, Stat.toogle_CameraCMD, Stat.toogle_Skin, Stat.toogle_Particle, Stat.toogle_msaa];
    Stat.FPS = 0;
    Stat.loopCount = 0;
    Stat.spriteRenderUseCacheCount = 0;
    Stat.canvasNormal = 0;
    Stat.canvasBitmap = 0;
    Stat.canvasReCache = 0;
    Stat.renderSlow = false;
    Stat._timer = 0;
    Stat._count = 0;
    Stat._fpsStr = "";
    Stat.spriteCount = 0;
    Stat.sprite3DCount = 0;
    Stat.drawCall = 0;
    Stat.draw2D = 0;
    Stat.trianglesFaces = 0;
    Stat.renderNode = 0;
    Stat.meshRenderNode = 0;
    Stat.skinRenderNode = 0;
    Stat.particleRenderNode = 0;
    Stat.frustumCulling = 0;
    Stat.uniformUpload = 0;
    Stat.opaqueDrawCall = 0;
    Stat.transDrawCall = 0;
    Stat.depthCastDrawCall = 0;
    Stat.shadowMapDrawCall = 0;
    Stat.instanceDrawCall = 0;
    Stat.cmdDrawCall = 0;
    Stat.blitDrawCall = 0;
    Stat.renderPassStatArray = [];
    Stat.enableRenderPassStatArray = false;
    Stat.textureMemory = 0;
    Stat.renderTextureMemory = 0;
    Stat.bufferMemory = 0;
    Stat.uploadUniform = 0;
    Stat.enableShadow = true;
    Stat.enableMulLight = true;
    Stat.enableLight = true;
    Stat.enableCameraCMD = true;
    Stat.enablePostprocess = true;
    Stat.enableSkin = true;
    Stat.enableTransparent = true;
    Stat.enableParticle = true;
    Stat.enableAnimatorUpdate = true;
    Stat.enablePhysicsUpdate = true;
    Stat.enablemsaa = true;
    Stat.enableOpaque = true;
    window.Stat = Stat;

    exports.BufferTargetType = void 0;
    (function (BufferTargetType) {
        BufferTargetType[BufferTargetType["ARRAY_BUFFER"] = 0] = "ARRAY_BUFFER";
        BufferTargetType[BufferTargetType["ELEMENT_ARRAY_BUFFER"] = 1] = "ELEMENT_ARRAY_BUFFER";
        BufferTargetType[BufferTargetType["UNIFORM_BUFFER"] = 2] = "UNIFORM_BUFFER";
        BufferTargetType[BufferTargetType["COPY_READ_BUFFER"] = 3] = "COPY_READ_BUFFER";
        BufferTargetType[BufferTargetType["COPY_WRITE_BUFFER"] = 4] = "COPY_WRITE_BUFFER";
        BufferTargetType[BufferTargetType["TRANSFORM_FEEDBACK_BUFFER"] = 5] = "TRANSFORM_FEEDBACK_BUFFER";
    })(exports.BufferTargetType || (exports.BufferTargetType = {}));
    exports.BufferUsage = void 0;
    (function (BufferUsage) {
        BufferUsage[BufferUsage["Static"] = 0] = "Static";
        BufferUsage[BufferUsage["Dynamic"] = 1] = "Dynamic";
        BufferUsage[BufferUsage["Stream"] = 2] = "Stream";
    })(exports.BufferUsage || (exports.BufferUsage = {}));

    exports.DrawType = void 0;
    (function (DrawType) {
        DrawType[DrawType["DrawArray"] = 0] = "DrawArray";
        DrawType[DrawType["DrawArrayInstance"] = 1] = "DrawArrayInstance";
        DrawType[DrawType["DrawElement"] = 2] = "DrawElement";
        DrawType[DrawType["DrawElementInstance"] = 3] = "DrawElementInstance";
    })(exports.DrawType || (exports.DrawType = {}));

    exports.IndexFormat = void 0;
    (function (IndexFormat) {
        IndexFormat[IndexFormat["UInt8"] = 0] = "UInt8";
        IndexFormat[IndexFormat["UInt16"] = 1] = "UInt16";
        IndexFormat[IndexFormat["UInt32"] = 2] = "UInt32";
    })(exports.IndexFormat || (exports.IndexFormat = {}));

    exports.MeshTopology = void 0;
    (function (MeshTopology) {
        MeshTopology[MeshTopology["Points"] = 0] = "Points";
        MeshTopology[MeshTopology["Lines"] = 1] = "Lines";
        MeshTopology[MeshTopology["LineLoop"] = 2] = "LineLoop";
        MeshTopology[MeshTopology["LineStrip"] = 3] = "LineStrip";
        MeshTopology[MeshTopology["Triangles"] = 4] = "Triangles";
        MeshTopology[MeshTopology["TriangleStrip"] = 5] = "TriangleStrip";
        MeshTopology[MeshTopology["TriangleFan"] = 6] = "TriangleFan";
    })(exports.MeshTopology || (exports.MeshTopology = {}));

    const TEMPMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    class RenderState2D {
        static restoreTempArray() {
            TEMPMAT4_ARRAY[0] = 1;
            TEMPMAT4_ARRAY[1] = 0;
            TEMPMAT4_ARRAY[4] = 0;
            TEMPMAT4_ARRAY[5] = 1;
            TEMPMAT4_ARRAY[12] = 0;
            TEMPMAT4_ARRAY[13] = 0;
        }
        static clear() {
            RenderState2D.worldAlpha = 1;
        }
    }
    RenderState2D.worldMatrix4 = TEMPMAT4_ARRAY;
    RenderState2D.worldMatrix = new Matrix();
    RenderState2D.matWVP = null;
    RenderState2D.worldAlpha = 1.0;
    RenderState2D.worldScissorTest = false;
    RenderState2D.width = 0;
    RenderState2D.height = 0;
    RenderState2D.InvertY = false;

    class Render2D {
        constructor(out = null) {
            this._renderTexture = null;
            this._renderTexture = out;
        }
        setRenderTarget(rt) { }
        ;
        get out() {
            return this._renderTexture;
        }
    }
    class Render2DSimple extends Render2D {
        constructor(out = null) {
            super(out);
            if (!Render2DSimple.rendercontext2D) {
                Render2DSimple.rendercontext2D = LayaGL.render2DRenderPassFactory.createRenderContext2D();
            }
            this._renderElement = LayaGL.render2DRenderPassFactory.createRenderElement2D();
        }
        clone(out) {
            return new Render2DSimple(out);
        }
        _createMesh(decl) {
            let geo = LayaGL.renderDeviceFactory.createRenderGeometryElement(exports.MeshTopology.Triangles, exports.DrawType.DrawElement);
            let mesh = LayaGL.renderDeviceFactory.createBufferState();
            geo.bufferState = mesh;
            let vb = LayaGL.renderDeviceFactory.createVertexBuffer(exports.BufferUsage.Dynamic);
            vb.vertexDeclaration = decl;
            let ib = LayaGL.renderDeviceFactory.createIndexBuffer(exports.BufferUsage.Dynamic);
            mesh.applyState([vb], ib);
            geo.indexFormat = exports.IndexFormat.UInt16;
            return geo;
        }
        getGeo(decl) {
            let geo = Render2DSimple._geoMap[decl.id];
            if (geo == undefined) {
                geo = this._createMesh(decl);
                Render2DSimple._geoMap[decl.id] = geo;
            }
            return geo;
        }
        renderStart(clear, clearColor) {
            if (this._renderTexture) {
                Render2DSimple.rendercontext2D.invertY = this._renderTexture._invertY;
                Render2DSimple.rendercontext2D.setRenderTarget(this._renderTexture._renderTarget, clear, clearColor);
            }
            else {
                Render2DSimple.rendercontext2D.invertY = false;
                Render2DSimple.rendercontext2D.setOffscreenView(RenderState2D.width, RenderState2D.height);
                Render2DSimple.rendercontext2D.setRenderTarget(null, clear, clearColor);
            }
            RenderTexture2D._clear = false;
        }
        setRenderTarget(rt) {
            Render2DSimple.rendercontext2D.setRenderTarget(rt === null || rt === void 0 ? void 0 : rt._renderTarget, false, RenderTexture2D._clearColor);
        }
        drawMesh(geo, mtl) {
            Stat.draw2D++;
            this._renderElement.geometry = geo;
            this._renderElement.value2DShaderData = mtl.shaderData;
            this._renderElement.subShader = mtl._shader.getSubShaderAt(0);
            this._renderElement.materialShaderData = mtl.shaderData;
            Render2DSimple.rendercontext2D.drawRenderElementOne(this._renderElement);
        }
        drawElement(ele) {
            Render2DSimple.rendercontext2D.drawRenderElementOne(ele);
        }
        draw(mesh2d, vboff, vblen, iboff, iblen, mtl, customMaterial) {
            Stat.draw2D++;
            let geo = this.getGeo(mesh2d.vertexDeclarition);
            let mesh = geo.bufferState;
            let vb = mesh._vertexBuffers[0];
            let ib = mesh._bindedIndexBuffer;
            vb.setDataLength(vblen);
            vb.setData(mesh2d.vbBuffer, vboff, 0, vblen);
            ib._setIndexDataLength(iblen);
            ib._setIndexData(new Uint16Array(mesh2d.ibBuffer, iboff, iblen / 2), 0);
            geo.clearRenderParams();
            geo.setDrawElemenParams(iblen / 2, 0);
            let mat = customMaterial;
            this._renderElement.geometry = geo;
            this._renderElement.value2DShaderData = mtl.shaderData;
            if (mat) {
                this._renderElement.subShader = mat._shader.getSubShaderAt(0);
                this._renderElement.materialShaderData = mat.shaderData;
            }
            else {
                this._renderElement.subShader = mtl._defaultShader.getSubShaderAt(0);
                this._renderElement.materialShaderData = null;
            }
            Render2DSimple.rendercontext2D.drawRenderElementOne(this._renderElement);
        }
        renderEnd() {
        }
    }
    Render2DSimple._geoMap = {};

    class SingletonList {
        constructor() {
            this.elements = [];
            this.length = 0;
        }
        _add(element) {
            if (this.length === this.elements.length)
                this.elements.push(element);
            else
                this.elements[this.length] = element;
        }
        add(element) {
            let index = this.elements.indexOf(element);
            if ((typeof (element) != "number") && index != -1 && index < this.length)
                return;
            if (this.length === this.elements.length)
                this.elements.push(element);
            else
                this.elements[this.length] = element;
            this.length++;
        }
        indexof(element) {
            let index = this.elements.indexOf(element);
            if (index != -1 && index < this.length)
                return index;
            return -1;
        }
        remove(element) {
            let index = this.elements.indexOf(element);
            if (index != -1 && index < this.length) {
                this.elements[index] = this.elements[this.length - 1];
                this.elements[this.length - 1] = null;
                this.length--;
            }
        }
        clear() {
            this.elements = [];
            this.length = 0;
        }
        clean() {
            this.elements.length = this.length;
        }
        destroy() {
            this.elements = null;
        }
    }
    class FastSinglelist extends SingletonList {
        add(element) {
            this._add(element);
            this.length++;
        }
    }

    class Batch2DInfo {
        constructor() {
            this.batchFun = null;
            this.batch = false;
            this.indexStart = -1;
            this.elementLenth = 0;
        }
        static create() {
            if (this._pool.length != 0) {
                return this._pool.pop();
            }
            else
                return new Batch2DInfo();
        }
        static recover(info) {
            this._pool.push(info);
        }
    }
    Batch2DInfo._pool = [];
    class RenderManager2D {
        static regisBatch(renderElementType, batch) {
            if (RenderManager2D._batchMapManager[renderElementType])
                throw "Overlapping batch optimization";
            else
                RenderManager2D._batchMapManager[renderElementType] = batch;
        }
        get list() {
            return this._list;
        }
        set list(value) {
            this._list = value;
        }
        constructor() {
            this._lastRenderNodeType = -1;
            this._renderEnd = true;
            this.list = new FastSinglelist();
            this._renderElementList = new FastSinglelist();
            this._batchInfoList = new FastSinglelist();
        }
        addRenderObject(object) {
            this.list.add(object);
        }
        removeRenderObject(object) {
            this.list.remove(object);
        }
        clearList() {
            this._list.clear();
            this._renderElementList.clear();
            for (var i = 0, n = this._batchInfoList.length; i < n; i++) {
                let element = this._batchInfoList.elements[i];
                if (element.batch) {
                    element.batchFun.recover();
                }
                Batch2DInfo.recover(element);
            }
            this._batchInfoList.clear();
        }
        renderUpdate() {
            var context = Render2DSimple.rendercontext2D;
            let lists = this._list.elements;
            for (let i = 0, n = this._list.length; i < n; i++) {
                let render = lists[i];
                if (render.renderUpdate && render._renderUpdateMask != Stat.loopCount) {
                    render.renderUpdate(context);
                    render._renderUpdateMask = Stat.loopCount;
                }
            }
        }
        render(context) {
            this.renderUpdate();
            for (var i = 0, n = this._list.length; i < n; i++) {
                this._cull(this._list.elements[i], context);
            }
            this._batch();
            context.drawRenderElementList(this._renderElementList);
            this.endRender();
        }
        _cull(renderNode, context) {
            {
                if (renderNode.preRenderUpdate)
                    renderNode.preRenderUpdate(context);
                let n = renderNode._renderElements.length;
                if (n == 1) {
                    this._batchStart(renderNode._renderType, 1);
                    this._renderElementList.add(renderNode._renderElements[0]);
                }
                else {
                    this._batchStart(renderNode._renderType, n);
                    for (var i = 0; i < n; i++) {
                        this._renderElementList.add(renderNode._renderElements[i]);
                    }
                }
            }
        }
        _batch() {
            this._batchInfoList.add(this._lastbatch2DInfo);
            this._renderElementList.length = 0;
            for (var i = 0, n = this._batchInfoList.length; i < n; i++) {
                let info = this._batchInfoList.elements[i];
                if (info.batch) {
                    info.batchFun.batchRenderElement(this._renderElementList, info.indexStart, info.elementLenth);
                }
                else {
                    for (let j = info.indexStart, m = info.elementLenth + info.indexStart; j < m; j++)
                        this._renderElementList.add(this._renderElementList.elements[j]);
                }
            }
        }
        _batchStart(renderNodeType, elementLength) {
            if (this._lastRenderNodeType == -1) {
                this._lastbatch2DInfo = Batch2DInfo.create();
                this._lastbatch2DInfo.batch = false;
                this._lastbatch2DInfo.batchFun = RenderManager2D._batchMapManager[renderNodeType];
                this._lastbatch2DInfo.indexStart = 0;
                this._lastbatch2DInfo.elementLenth = elementLength;
                this._lastRenderNodeType = renderNodeType;
                return;
            }
            if (this._lastRenderNodeType == renderNodeType) {
                this._lastbatch2DInfo.batch = !!(this._lastbatch2DInfo.batchFun);
                this._lastbatch2DInfo.elementLenth += elementLength;
            }
            else {
                this._batchInfoList.add(this._lastbatch2DInfo);
                this._lastbatch2DInfo = Batch2DInfo.create();
                this._lastbatch2DInfo.batch = false;
                this._lastbatch2DInfo.batchFun = RenderManager2D._batchMapManager[renderNodeType];
                this._lastbatch2DInfo.indexStart = this._renderElementList.length;
                this._lastbatch2DInfo.elementLenth = elementLength;
                this._lastRenderNodeType = renderNodeType;
            }
        }
        endRender() {
            this.clearList();
            this._renderEnd = true;
            this._lastRenderNodeType = -1;
        }
    }
    RenderManager2D._batchMapManager = {};

    exports.BlendEquationSeparate = void 0;
    (function (BlendEquationSeparate) {
        BlendEquationSeparate[BlendEquationSeparate["ADD"] = 0] = "ADD";
        BlendEquationSeparate[BlendEquationSeparate["SUBTRACT"] = 1] = "SUBTRACT";
        BlendEquationSeparate[BlendEquationSeparate["REVERSE_SUBTRACT"] = 2] = "REVERSE_SUBTRACT";
        BlendEquationSeparate[BlendEquationSeparate["MIN"] = 3] = "MIN";
        BlendEquationSeparate[BlendEquationSeparate["MAX"] = 4] = "MAX";
    })(exports.BlendEquationSeparate || (exports.BlendEquationSeparate = {}));

    exports.BlendFactor = void 0;
    (function (BlendFactor) {
        BlendFactor[BlendFactor["Zero"] = 0] = "Zero";
        BlendFactor[BlendFactor["One"] = 1] = "One";
        BlendFactor[BlendFactor["SourceColor"] = 2] = "SourceColor";
        BlendFactor[BlendFactor["OneMinusSourceColor"] = 3] = "OneMinusSourceColor";
        BlendFactor[BlendFactor["DestinationColor"] = 4] = "DestinationColor";
        BlendFactor[BlendFactor["OneMinusDestinationColor"] = 5] = "OneMinusDestinationColor";
        BlendFactor[BlendFactor["SourceAlpha"] = 6] = "SourceAlpha";
        BlendFactor[BlendFactor["OneMinusSourceAlpha"] = 7] = "OneMinusSourceAlpha";
        BlendFactor[BlendFactor["DestinationAlpha"] = 8] = "DestinationAlpha";
        BlendFactor[BlendFactor["OneMinusDestinationAlpha"] = 9] = "OneMinusDestinationAlpha";
        BlendFactor[BlendFactor["SourceAlphaSaturate"] = 10] = "SourceAlphaSaturate";
        BlendFactor[BlendFactor["BlendColor"] = 11] = "BlendColor";
        BlendFactor[BlendFactor["OneMinusBlendColor"] = 12] = "OneMinusBlendColor";
    })(exports.BlendFactor || (exports.BlendFactor = {}));

    exports.BlendType = void 0;
    (function (BlendType) {
        BlendType[BlendType["BLEND_DISABLE"] = 0] = "BLEND_DISABLE";
        BlendType[BlendType["BLEND_ENABLE_ALL"] = 1] = "BLEND_ENABLE_ALL";
        BlendType[BlendType["BLEND_ENABLE_SEPERATE"] = 2] = "BLEND_ENABLE_SEPERATE";
    })(exports.BlendType || (exports.BlendType = {}));

    exports.CompareFunction = void 0;
    (function (CompareFunction) {
        CompareFunction[CompareFunction["Never"] = 0] = "Never";
        CompareFunction[CompareFunction["Less"] = 1] = "Less";
        CompareFunction[CompareFunction["Equal"] = 2] = "Equal";
        CompareFunction[CompareFunction["LessEqual"] = 3] = "LessEqual";
        CompareFunction[CompareFunction["Greater"] = 4] = "Greater";
        CompareFunction[CompareFunction["NotEqual"] = 5] = "NotEqual";
        CompareFunction[CompareFunction["GreaterEqual"] = 6] = "GreaterEqual";
        CompareFunction[CompareFunction["Always"] = 7] = "Always";
        CompareFunction[CompareFunction["Off"] = 8] = "Off";
    })(exports.CompareFunction || (exports.CompareFunction = {}));

    exports.CullMode = void 0;
    (function (CullMode) {
        CullMode[CullMode["Off"] = 0] = "Off";
        CullMode[CullMode["Front"] = 1] = "Front";
        CullMode[CullMode["Back"] = 2] = "Back";
    })(exports.CullMode || (exports.CullMode = {}));
    exports.FrontFace = void 0;
    (function (FrontFace) {
        FrontFace[FrontFace["CW"] = 0] = "CW";
        FrontFace[FrontFace["CCW"] = 1] = "CCW";
    })(exports.FrontFace || (exports.FrontFace = {}));

    exports.StencilOperation = void 0;
    (function (StencilOperation) {
        StencilOperation[StencilOperation["Keep"] = 0] = "Keep";
        StencilOperation[StencilOperation["Zero"] = 1] = "Zero";
        StencilOperation[StencilOperation["Replace"] = 2] = "Replace";
        StencilOperation[StencilOperation["IncrementSaturate"] = 3] = "IncrementSaturate";
        StencilOperation[StencilOperation["DecrementSaturate"] = 4] = "DecrementSaturate";
        StencilOperation[StencilOperation["Invert"] = 5] = "Invert";
        StencilOperation[StencilOperation["IncrementWrap"] = 6] = "IncrementWrap";
        StencilOperation[StencilOperation["DecrementWrap"] = 7] = "DecrementWrap";
    })(exports.StencilOperation || (exports.StencilOperation = {}));

    class RenderState {
        ;
        get cull() {
            return this._cull;
        }
        set cull(value) {
            this._cull = value;
        }
        get blend() {
            return this._blend;
        }
        set blend(value) {
            this._blend = value;
        }
        get srcBlend() {
            return this._srcBlend;
        }
        set srcBlend(value) {
            this._srcBlend = value;
        }
        get dstBlend() {
            return this._dstBlend;
        }
        set dstBlend(value) {
            this._dstBlend = value;
        }
        get srcBlendRGB() {
            return this._srcBlendRGB;
        }
        set srcBlendRGB(value) {
            this._srcBlendRGB = value;
        }
        get dstBlendRGB() {
            return this._dstBlendRGB;
        }
        set dstBlendRGB(value) {
            this._dstBlendRGB = value;
        }
        get srcBlendAlpha() {
            return this._srcBlendAlpha;
        }
        set srcBlendAlpha(value) {
            this._srcBlendAlpha = value;
        }
        get dstBlendAlpha() {
            return this._dstBlendAlpha;
        }
        set dstBlendAlpha(value) {
            this._dstBlendAlpha = value;
        }
        get blendEquation() {
            return this._blendEquation;
        }
        set blendEquation(value) {
            this._blendEquation = value;
        }
        get blendEquationRGB() {
            return this._blendEquationRGB;
        }
        set blendEquationRGB(value) {
            this._blendEquationRGB = value;
        }
        get blendEquationAlpha() {
            return this._blendEquationAlpha;
        }
        set blendEquationAlpha(value) {
            this._blendEquationAlpha = value;
        }
        get depthTest() {
            return this._depthTest;
        }
        set depthTest(value) {
            this._depthTest = value;
        }
        get depthWrite() {
            return this._depthWrite;
        }
        set depthWrite(value) {
            this._depthWrite = value;
        }
        get stencilWrite() {
            return this._stencilWrite;
        }
        set stencilWrite(value) {
            this._stencilWrite = value;
        }
        get stencilTest() {
            return this._stencilTest;
        }
        set stencilTest(value) {
            this._stencilTest = value;
        }
        get stencilRef() {
            return this._stencilRef;
        }
        set stencilRef(value) {
            this._stencilRef = value;
        }
        get stencilOp() {
            return this._stencilOp;
        }
        set stencilOp(value) {
            this._stencilOp = value;
        }
        createObj() {
        }
        constructor() {
            this._stencilOp = new Vector3();
            this.createObj();
            this.cull = RenderState.CULL_BACK;
            this.blend = RenderState.BLEND_DISABLE;
            this.srcBlend = RenderState.BLENDPARAM_ONE;
            this.dstBlend = RenderState.BLENDPARAM_ZERO;
            this.srcBlendRGB = RenderState.BLENDPARAM_ONE;
            this.dstBlendRGB = RenderState.BLENDPARAM_ZERO;
            this.srcBlendAlpha = RenderState.BLENDPARAM_ONE;
            this.dstBlendAlpha = RenderState.BLENDPARAM_ZERO;
            this.blendEquation = RenderState.BLENDEQUATION_ADD;
            this.blendEquationRGB = RenderState.BLENDEQUATION_ADD;
            this.blendEquationAlpha = RenderState.BLENDEQUATION_ADD;
            this.depthTest = RenderState.DEPTHTEST_LEQUAL;
            this.depthWrite = true;
            this.stencilRef = 1;
            this.stencilTest = RenderState.STENCILTEST_OFF;
            this.stencilWrite = false;
            this.stencilOp = new Vector3(RenderState.STENCILOP_KEEP, RenderState.STENCILOP_KEEP, RenderState.STENCILOP_REPLACE);
        }
        setNull() {
            this.cull = null;
            this.blend = null;
            this.srcBlend = null;
            this.dstBlend = null;
            this.srcBlendRGB = null;
            this.dstBlendRGB = null;
            this.srcBlendAlpha = null;
            this.dstBlendAlpha = null;
            this.blendEquation = null;
            this.blendEquationRGB = null;
            this.blendEquationAlpha = null;
            this.depthTest = null;
            this.depthWrite = null;
            this.stencilRef = null;
            this.stencilTest = null;
            this.stencilWrite = null;
            this.stencilOp.set(null, null, null);
        }
        cloneTo(dest) {
            dest.cull = this.cull;
            dest.blend = this.blend;
            dest.srcBlend = this.srcBlend;
            dest.dstBlend = this.dstBlend;
            dest.srcBlendRGB = this.srcBlendRGB;
            dest.dstBlendRGB = this.dstBlendRGB;
            dest.srcBlendAlpha = this.srcBlendAlpha;
            dest.dstBlendAlpha = this.dstBlendAlpha;
            dest.blendEquation = this.blendEquation;
            dest.blendEquationRGB = this.blendEquationRGB;
            dest.blendEquationAlpha = this.blendEquationAlpha;
            dest.depthTest = this.depthTest;
            dest.depthWrite = this.depthWrite;
            dest.stencilRef = this.stencilRef;
            dest.stencilTest = this.stencilTest;
            dest.stencilWrite = this.stencilWrite;
            this.stencilOp.cloneTo(dest.stencilOp);
        }
        clone() {
            var dest = new RenderState();
            this.cloneTo(dest);
            return dest;
        }
    }
    RenderState.CULL_NONE = exports.CullMode.Off;
    RenderState.CULL_FRONT = exports.CullMode.Front;
    RenderState.CULL_BACK = exports.CullMode.Back;
    RenderState.BLEND_DISABLE = exports.BlendType.BLEND_DISABLE;
    RenderState.BLEND_ENABLE_ALL = exports.BlendType.BLEND_ENABLE_ALL;
    RenderState.BLEND_ENABLE_SEPERATE = exports.BlendType.BLEND_ENABLE_SEPERATE;
    RenderState.BLENDPARAM_ZERO = exports.BlendFactor.Zero;
    RenderState.BLENDPARAM_ONE = exports.BlendFactor.One;
    RenderState.BLENDPARAM_SRC_COLOR = exports.BlendFactor.SourceColor;
    RenderState.BLENDPARAM_ONE_MINUS_SRC_COLOR = exports.BlendFactor.OneMinusSourceColor;
    RenderState.BLENDPARAM_DST_COLOR = exports.BlendFactor.DestinationColor;
    RenderState.BLENDPARAM_ONE_MINUS_DST_COLOR = exports.BlendFactor.OneMinusDestinationColor;
    RenderState.BLENDPARAM_SRC_ALPHA = exports.BlendFactor.SourceAlpha;
    RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA = exports.BlendFactor.OneMinusSourceAlpha;
    RenderState.BLENDPARAM_DST_ALPHA = exports.BlendFactor.DestinationAlpha;
    RenderState.BLENDPARAM_ONE_MINUS_DST_ALPHA = exports.BlendFactor.OneMinusDestinationAlpha;
    RenderState.BLENDPARAM_SRC_ALPHA_SATURATE = exports.BlendFactor.SourceAlphaSaturate;
    RenderState.BLENDPARAM_BLENDCOLOR = exports.BlendFactor.BlendColor;
    RenderState.BLENDPARAM_BLEND_ONEMINUS_COLOR = exports.BlendFactor.OneMinusBlendColor;
    RenderState.BLENDEQUATION_ADD = exports.BlendEquationSeparate.ADD;
    RenderState.BLENDEQUATION_SUBTRACT = exports.BlendEquationSeparate.SUBTRACT;
    RenderState.BLENDEQUATION_REVERSE_SUBTRACT = exports.BlendEquationSeparate.REVERSE_SUBTRACT;
    RenderState.BLENDEQUATION_MIN = exports.BlendEquationSeparate.MIN;
    RenderState.BLENDEQUATION_MAX = exports.BlendEquationSeparate.MAX;
    RenderState.DEPTHTEST_OFF = exports.CompareFunction.Off;
    RenderState.DEPTHTEST_NEVER = exports.CompareFunction.Never;
    RenderState.DEPTHTEST_LESS = exports.CompareFunction.Less;
    RenderState.DEPTHTEST_EQUAL = exports.CompareFunction.Equal;
    RenderState.DEPTHTEST_LEQUAL = exports.CompareFunction.LessEqual;
    RenderState.DEPTHTEST_GREATER = exports.CompareFunction.Greater;
    RenderState.DEPTHTEST_NOTEQUAL = exports.CompareFunction.NotEqual;
    RenderState.DEPTHTEST_GEQUAL = exports.CompareFunction.GreaterEqual;
    RenderState.DEPTHTEST_ALWAYS = exports.CompareFunction.Always;
    RenderState.STENCILTEST_OFF = exports.CompareFunction.Off;
    RenderState.STENCILTEST_NEVER = exports.CompareFunction.Never;
    RenderState.STENCILTEST_LESS = exports.CompareFunction.Less;
    RenderState.STENCILTEST_EQUAL = exports.CompareFunction.Equal;
    RenderState.STENCILTEST_LEQUAL = exports.CompareFunction.LessEqual;
    RenderState.STENCILTEST_GREATER = exports.CompareFunction.Greater;
    RenderState.STENCILTEST_NOTEQUAL = exports.CompareFunction.NotEqual;
    RenderState.STENCILTEST_GEQUAL = exports.CompareFunction.GreaterEqual;
    RenderState.STENCILTEST_ALWAYS = exports.CompareFunction.Always;
    RenderState.STENCILOP_KEEP = exports.StencilOperation.Keep;
    RenderState.STENCILOP_ZERO = exports.StencilOperation.Zero;
    RenderState.STENCILOP_REPLACE = exports.StencilOperation.Replace;
    RenderState.STENCILOP_INCR = exports.StencilOperation.IncrementSaturate;
    RenderState.STENCILOP_INCR_WRAP = exports.StencilOperation.IncrementWrap;
    RenderState.STENCILOP_DECR = exports.StencilOperation.DecrementSaturate;
    RenderState.STENCILOP_DECR_WRAP = exports.StencilOperation.DecrementWrap;
    RenderState.STENCILOP_INVERT = exports.StencilOperation.Invert;
    RenderState.Default = new RenderState();

    class IncludeFile {
        static splitToWords(str, block) {
            var out = [];
            var c;
            var ofs = -1;
            var word;
            for (var i = 0, n = str.length; i < n; i++) {
                c = str.charAt(i);
                if (" \t=+-*/&%!<>()'\",;".indexOf(c) >= 0) {
                    if (ofs >= 0 && (i - ofs) > 1) {
                        word = str.substr(ofs, i - ofs);
                        out.push(word);
                    }
                    if (c == '"' || c == "'") {
                        var ofs2 = str.indexOf(c, i + 1);
                        if (ofs2 < 0) {
                            throw "Sharder err:" + str;
                        }
                        out.push(str.substr(i + 1, ofs2 - i - 1));
                        i = ofs2;
                        ofs = -1;
                        continue;
                    }
                    if (c == '(' && block && out.length > 0) {
                        word = out[out.length - 1] + ";";
                        if ("vec4;main;".indexOf(word) < 0)
                            block.useFuns += word;
                    }
                    ofs = -1;
                    continue;
                }
                if (ofs < 0)
                    ofs = i;
            }
            if (ofs < n && (n - ofs) > 1) {
                word = str.substr(ofs, n - ofs);
                out.push(word);
            }
            return out;
        }
        constructor(txt) {
            this.codes = {};
            this.funs = {};
            this.curUseID = -1;
            this.funnames = "";
            this.script = txt;
            var begin = 0, ofs, end;
            while (true) {
                begin = txt.indexOf("#begin", begin);
                if (begin < 0)
                    break;
                end = begin + 5;
                while (true) {
                    end = txt.indexOf("#end", end);
                    if (end < 0)
                        break;
                    if (txt.charAt(end + 4) === 'i')
                        end += 5;
                    else
                        break;
                }
                if (end < 0) {
                    throw "add include err,no #end:" + txt;
                }
                ofs = txt.indexOf('\n', begin);
                var words = IncludeFile.splitToWords(txt.substr(begin, ofs - begin), null);
                if (words[1] == 'code') {
                    this.codes[words[2]] = txt.substr(ofs + 1, end - ofs - 1);
                }
                else if (words[1] == 'function') {
                    ofs = txt.indexOf("function", begin);
                    ofs += "function".length;
                    this.funs[words[3]] = txt.substr(ofs + 1, end - ofs - 1);
                    this.funnames += words[3] + ";";
                }
                begin = end + 1;
            }
        }
        getWith(name = null) {
            var r = name ? this.codes[name] : this.script;
            if (!r) {
                throw "get with error:" + name;
            }
            return r;
        }
        getFunsScript(funsdef) {
            var r = "";
            for (var i in this.funs) {
                if (funsdef.indexOf(i + ";") >= 0) {
                    r += this.funs[i];
                }
            }
            return r;
        }
    }

    class ShaderNode {
        constructor(includefiles) {
            this.childs = [];
            this.text = "";
            this.useFuns = "";
            this.z = 0;
            this.includefiles = includefiles;
        }
        setParent(parent) {
            parent.childs.push(this);
            this.z = parent.z + 1;
            this.parent = parent;
        }
        setCondition(condition, type) {
            if (condition) {
                this.conditionType = type;
                condition = condition.replace(/(\s*$)/g, "");
                this.condition = function () {
                    return this[condition];
                };
                this.condition.__condition = condition;
            }
        }
        toscript(def, out) {
            return this._toscript(def, out, ++ShaderNode.__id);
        }
        _toscript(def, out, id) {
            if (this.childs.length < 1 && !this.text)
                return out;
            out.length;
            if (this.condition) {
                var ifdef = !!this.condition.call(def);
                this.conditionType === 2 && (ifdef = !ifdef);
                if (!ifdef && ShaderNode.__noCompileEnable)
                    return out;
            }
            if (this.noCompile || !ShaderNode.__noCompileEnable)
                this.text && out.push(this.text);
            this.childs.length > 0 && this.childs.forEach(function (o, index, arr) {
                o._toscript(def, out, id);
            });
            if (this.includefiles.length > 0 && this.useFuns.length > 0) {
                var funsCode;
                for (var i = 0, n = this.includefiles.length; i < n; i++) {
                    if (this.includefiles[i].curUseID == id) {
                        continue;
                    }
                    funsCode = this.includefiles[i].file.getFunsScript(this.useFuns);
                    if (funsCode.length > 0) {
                        this.includefiles[i].curUseID = id;
                        out[0] = funsCode + out[0];
                    }
                }
            }
            return out;
        }
    }
    ShaderNode.__id = 1;
    ShaderNode.__noCompileEnable = true;

    const _clearCR = new RegExp("\r", "g");
    const _splitToWordExps3 = new RegExp("[ \\t=\\+\\-*/&%!<>!%\(\),;\\|]", "g");
    const CullStateMap = {
        "Back": exports.CullMode.Back,
        "Front": exports.CullMode.Front,
        "Off": exports.CullMode.Off
    };
    const BlendStateMap = {
        "Disable": exports.BlendType.BLEND_DISABLE,
        "All": exports.BlendType.BLEND_ENABLE_ALL,
        "Seperate": exports.BlendType.BLEND_ENABLE_SEPERATE
    };
    const BlendFactorMap = {
        "Zero": exports.BlendFactor.Zero,
        "One": exports.BlendFactor.One,
        "SourceColor": exports.BlendFactor.SourceColor,
        "OneMinusSourceColor": exports.BlendFactor.OneMinusSourceColor,
        "DestinationColor": exports.BlendFactor.DestinationColor,
        "OneMinusDestinationColor": exports.BlendFactor.OneMinusDestinationColor,
        "SourceAlpha": exports.BlendFactor.SourceAlpha,
        "OneMinusSourceAlpha": exports.BlendFactor.OneMinusSourceAlpha,
        "DestinationAlpha": exports.BlendFactor.DestinationAlpha,
        "OneMinusDestinationAlpha": exports.BlendFactor.OneMinusDestinationAlpha,
        "SourceAlphaSaturate": exports.BlendFactor.SourceAlphaSaturate,
        "BlendColor": exports.BlendFactor.BlendColor,
        "OneMinusBlendColor": exports.BlendFactor.OneMinusBlendColor,
    };
    const BlendEquationMap = {
        "Add": exports.BlendEquationSeparate.ADD,
        "Subtract": exports.BlendEquationSeparate.SUBTRACT,
        "Reverse_substract": exports.BlendEquationSeparate.REVERSE_SUBTRACT,
        "Min": exports.BlendEquationSeparate.MIN,
        "Max": exports.BlendEquationSeparate.MAX
    };
    const CompareFunctionMap = {
        "Never": exports.CompareFunction.Never,
        "Less": exports.CompareFunction.Less,
        "Equal": exports.CompareFunction.Equal,
        "LessEqual": exports.CompareFunction.LessEqual,
        "Greater": exports.CompareFunction.Greater,
        "NotEqual": exports.CompareFunction.NotEqual,
        "GreaterEqual": exports.CompareFunction.GreaterEqual,
        "Always": exports.CompareFunction.Always,
        "Off": exports.CompareFunction.Off,
    };
    const StencilOperationMap = {
        "Keep": exports.StencilOperation.Keep,
        "Zero": exports.StencilOperation.Zero,
        "Replace": exports.StencilOperation.Replace,
        "IncrementSaturate": exports.StencilOperation.IncrementSaturate,
        "DecrementSaturate": exports.StencilOperation.DecrementSaturate,
        "Invert": exports.StencilOperation.Invert,
        "IncrementWrap": exports.StencilOperation.IncrementWrap,
        "DecrementWrap": exports.StencilOperation.DecrementWrap,
    };
    class ShaderCompile {
        static addInclude(fileName, txt, allowReplace) {
            if (!txt || txt.length === 0) {
                console.error("shader include file err:" + fileName);
                return null;
            }
            if (!allowReplace && ShaderCompile.includes[fileName]) {
                console.warn("shader include file already exists:" + fileName);
                return ShaderCompile.includes[fileName];
            }
            txt = txt.replace(_clearCR, "");
            let file = new IncludeFile(txt);
            ShaderCompile.includes[fileName] = file;
            return file;
        }
        static compile(vs, ps, basePath) {
            let result = {
                vsNode: new ShaderNode([]),
                psNode: new ShaderNode([]),
                includeNames: new Set(),
                defs: new Set()
            };
            let includes = [];
            vs = vs.replace(_clearCR, "");
            ps = ps.replace(_clearCR, "");
            ShaderCompile._compileToTree(result.vsNode, vs, result.defs, includes, basePath);
            ShaderCompile._compileToTree(result.psNode, ps, result.defs, includes, basePath);
            for (let inc of includes) {
                if (inc.file)
                    result.includeNames.add(inc.name);
                else
                    console.warn(`ShaderCompile missing file ${inc.name}`);
            }
            return result;
        }
        static compileAsync(vs, ps, basePath) {
            let result = {
                vsNode: new ShaderNode([]),
                psNode: new ShaderNode([]),
                includeNames: new Set(),
                defs: new Set()
            };
            let includes = [];
            vs = vs.replace(_clearCR, "");
            ps = ps.replace(_clearCR, "");
            ShaderCompile._compileToTree(result.vsNode, vs, result.defs, includes, basePath);
            ShaderCompile._compileToTree(result.psNode, ps, result.defs, includes, basePath);
            return this._loadIncludesDeep(result, includes, 0);
        }
        static _loadIncludesDeep(result, includes, index) {
            let toLoad;
            let includesCnt = includes.length;
            for (let i = index; i < includesCnt; i++) {
                let inc = includes[i];
                if (inc.file)
                    result.includeNames.add(inc.name);
                else {
                    if (!toLoad)
                        toLoad = [];
                    toLoad.push(inc);
                }
            }
            if (!toLoad)
                return Promise.resolve(result);
            return ILaya.loader.load(toLoad.map(tc => tc.name)).then(files => {
                let cnt = toLoad.length;
                for (let i = 0; i < cnt; i++) {
                    let inc = toLoad[i];
                    let file = files[i];
                    if (!file) {
                        let childs = inc.node.parent.childs;
                        childs.splice(childs.indexOf(inc.node), 1);
                    }
                    else {
                        result.includeNames.add(inc.name);
                        let text = file.getWith(inc.codeName);
                        if (inc.node.condition)
                            inc.node.text = text;
                        else {
                            ShaderCompile._compileToTree(inc.node, text, result.defs, includes, URL.getPath(inc.name));
                            inc.node.text = "";
                        }
                    }
                }
                if (includes.length > includesCnt)
                    return ShaderCompile._loadIncludesDeep(result, includes, includesCnt);
                else
                    return result;
            });
        }
        static _compileToTree(parent, script, defs, includes, basePath) {
            let node, preNode;
            let text, name, fname;
            let ofs, words;
            let i, n, j;
            let lines = script.split("\n");
            for (i = 0; i < lines.length; i++) {
                text = lines[i];
                if (text.length < 1)
                    continue;
                ofs = text.indexOf("//");
                if (ofs === 0)
                    continue;
                if (ofs >= 0)
                    text = text.substr(0, ofs);
                if ((ofs = text.indexOf("#")) < 0) {
                    preNode = parent.childs[parent.childs.length - 1];
                    let includefiles = parent.includefiles;
                    if (preNode && !preNode.name) {
                        includefiles.length > 0 && IncludeFile.splitToWords(text, preNode);
                        preNode.text += "\n" + text;
                        continue;
                    }
                    node = new ShaderNode(includefiles);
                    node.text = text;
                    node.noCompile = true;
                    includefiles.length > 0 && IncludeFile.splitToWords(text, node);
                    node.setParent(parent);
                    continue;
                }
                node = new ShaderNode(parent.includefiles);
                node.text = text;
                node.noCompile = true;
                name = "#";
                for (j = ofs + 1, n = text.length; j < n; j++) {
                    let c = text.charAt(j);
                    if (c === ' ' || c === '\t' || c === '?')
                        break;
                    name += c;
                }
                node.name = name;
                switch (name) {
                    case "#ifdef":
                    case "#ifndef":
                        node.src = text;
                        node.noCompile = text.match(/[!&|()=<>]/) != null;
                        if (!node.noCompile) {
                            words = text.replace(/^\s*/, '').split(/\s+/);
                            node.setCondition(words[1], name === "#ifdef" ? ShaderCompile.IFDEF_YES : ShaderCompile.IFDEF_ELSE);
                            node.text = node.text;
                        }
                        else {
                            console.log("function():Boolean{return " + text.substr(ofs + node.name.length) + "}");
                        }
                        node.setParent(parent);
                        parent = node;
                        words = text.substr(j).split(_splitToWordExps3);
                        for (j = 0; j < words.length; j++) {
                            text = words[j];
                            text.length && defs.add(text);
                        }
                        break;
                    case "#if":
                    case "#elif":
                        node.src = text;
                        node.noCompile = true;
                        if (name == "#elif") {
                            parent = parent.parent;
                            preNode = parent.childs[parent.childs.length - 1];
                            preNode.text = preNode.src;
                            preNode.noCompile = true;
                            preNode.condition = null;
                        }
                        node.setParent(parent);
                        parent = node;
                        words = text.substr(j).split(_splitToWordExps3);
                        for (j = 0; j < words.length; j++) {
                            text = words[j];
                            text.length && text != "defined" && defs.add(text);
                        }
                        break;
                    case "#else":
                        node.src = text;
                        parent = parent.parent;
                        preNode = parent.childs[parent.childs.length - 1];
                        node.noCompile = preNode.noCompile;
                        if (!node.noCompile) {
                            node.condition = preNode.condition;
                            node.conditionType = preNode.conditionType == ShaderCompile.IFDEF_YES ? ShaderCompile.IFDEF_ELSE : ShaderCompile.IFDEF_YES;
                        }
                        node.setParent(parent);
                        parent = node;
                        break;
                    case "#endif":
                        parent = parent.parent;
                        preNode = parent.childs[parent.childs.length - 1];
                        node.noCompile = preNode.noCompile;
                        if (!node.noCompile) {
                            node.text = node.text;
                        }
                        node.setParent(parent);
                        break;
                    case "#include":
                        words = IncludeFile.splitToWords(text, null);
                        let includeName = words[1];
                        let includeFile;
                        if (includeName.startsWith("."))
                            includeName = URL.join(basePath, includeName);
                        else if (includeName.startsWith("/"))
                            includeName = URL.formatURL(includeName.substring(1));
                        else {
                            includeFile = ShaderCompile.includes[includeName];
                            if (!includeFile)
                                includeName = "internal/" + includeName;
                        }
                        includeFile = ShaderCompile.includes[includeName];
                        if (!includeFile && ShaderCompile.loadIncludeFileSync) {
                            ShaderCompile.loadIncludeFileSync(includeName);
                            includeFile = ShaderCompile.includes[includeName];
                        }
                        let codeName = words[2] == 'with' ? words[3] : null;
                        includes.push({ name: includeName, codeName: codeName, node: node, file: includeFile });
                        node.setParent(parent);
                        if ((ofs = words[0].indexOf("?")) < 0) {
                            if (includeFile) {
                                text = includeFile.getWith(codeName);
                                this._compileToTree(node, text, defs, includes, URL.getPath(includeName));
                            }
                            node.text = "";
                        }
                        else {
                            node.setCondition(words[0].substr(ofs + 1), ShaderCompile.IFDEF_YES);
                            if (includeFile)
                                node.text = includeFile.getWith(codeName);
                        }
                        break;
                    case "#import":
                        words = IncludeFile.splitToWords(text, null);
                        fname = words[1];
                        node.includefiles.push({ node: node, file: ShaderCompile.includes[fname], ofs: node.text.length });
                        break;
                    default:
                        node.setParent(parent);
                        break;
                }
            }
        }
        static getRenderState(obj, renderState) {
            if (!obj) {
                return;
            }
            renderState.cull = CullStateMap[obj.cull];
            renderState.blend = BlendStateMap[obj.blend];
            renderState.srcBlend = BlendFactorMap[obj.srcBlend];
            renderState.dstBlend = BlendFactorMap[obj.dstBlend];
            renderState.srcBlendRGB = BlendFactorMap[obj.srcBlendRGB];
            renderState.dstBlendRGB = BlendFactorMap[obj.dstBlendRGB];
            renderState.srcBlendAlpha = BlendFactorMap[obj.srcBlendAlpha];
            renderState.dstBlendAlpha = BlendFactorMap[obj.dstBlendAlpha];
            renderState.blendEquation = BlendEquationMap[obj.blendEquation];
            renderState.blendEquationRGB = BlendEquationMap[obj.blendEquationRGB];
            renderState.blendEquationAlpha = BlendEquationMap[obj.blendEquationAlpha];
            renderState.depthTest = CompareFunctionMap[obj.depthTest];
            renderState.depthWrite = obj.depthWrite;
            renderState.stencilRef = obj.stencilRef;
            renderState.stencilTest = CompareFunctionMap[obj.stencilTest];
            renderState.stencilWrite = obj.stencilWrite;
            let stencilOp = obj.stencilOp;
            let stencilFail = stencilOp ? stencilOp[0] : null;
            let stencilZFail = stencilOp ? stencilOp[1] : null;
            let stencilZPass = stencilOp ? stencilOp[2] : null;
            renderState.stencilOp.x = StencilOperationMap[stencilFail];
            renderState.stencilOp.y = StencilOperationMap[stencilZFail];
            renderState.stencilOp.z = StencilOperationMap[stencilZPass];
            return;
        }
    }
    ShaderCompile.IFDEF_NO = 0;
    ShaderCompile.IFDEF_YES = 1;
    ShaderCompile.IFDEF_ELSE = 2;
    ShaderCompile.IFDEF_PARENT = 3;
    ShaderCompile.includes = {};

    const _DEFAULTELEMENTS = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    const _tempV30 = new Vector3();
    const _tempV31 = new Vector3();
    const _tempV32 = new Vector3();
    class Matrix3x3 {
        static createRotationQuaternion(rotation, out) {
            var rotX = rotation.x;
            var rotY = rotation.y;
            var rotZ = rotation.z;
            var rotW = rotation.w;
            var xx = rotX * rotX;
            var yy = rotY * rotY;
            var zz = rotZ * rotZ;
            var xy = rotX * rotY;
            var zw = rotZ * rotW;
            var zx = rotZ * rotX;
            var yw = rotY * rotW;
            var yz = rotY * rotZ;
            var xw = rotX * rotW;
            var resultE = out.elements;
            resultE[0] = 1.0 - (2.0 * (yy + zz));
            resultE[1] = 2.0 * (xy + zw);
            resultE[2] = 2.0 * (zx - yw);
            resultE[3] = 2.0 * (xy - zw);
            resultE[4] = 1.0 - (2.0 * (zz + xx));
            resultE[5] = 2.0 * (yz + xw);
            resultE[6] = 2.0 * (zx + yw);
            resultE[7] = 2.0 * (yz - xw);
            resultE[8] = 1.0 - (2.0 * (yy + xx));
        }
        static createFromTranslation(trans, out) {
            var e = out.elements;
            e[0] = 1;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = 1;
            e[5] = 0;
            e[6] = trans.x;
            e[7] = trans.y;
            e[8] = 1;
        }
        static createFromRotation(rad, out) {
            var e = out.elements;
            var s = Math.sin(rad), c = Math.cos(rad);
            e[0] = c;
            e[1] = s;
            e[2] = 0;
            e[3] = -s;
            e[4] = c;
            e[5] = 0;
            e[6] = 0;
            e[7] = 0;
            e[8] = 1;
        }
        static createFromScaling(scale, out) {
            var e = out.elements;
            e[0] = scale.x;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = scale.y;
            e[5] = 0;
            e[6] = 0;
            e[7] = 0;
            e[8] = scale.z;
        }
        static createFromMatrix4x4(sou, out) {
            var souE = sou.elements;
            var outE = out.elements;
            outE[0] = souE[0];
            outE[1] = souE[1];
            outE[2] = souE[2];
            outE[3] = souE[4];
            outE[4] = souE[5];
            outE[5] = souE[6];
            outE[6] = souE[8];
            outE[7] = souE[9];
            outE[8] = souE[10];
        }
        static multiply(left, right, out) {
            var l = left.elements;
            var r = right.elements;
            var e = out.elements;
            var l11 = l[0], l12 = l[1], l13 = l[2];
            var l21 = l[3], l22 = l[4], l23 = l[5];
            var l31 = l[6], l32 = l[7], l33 = l[8];
            var r11 = r[0], r12 = r[1], r13 = r[2];
            var r21 = r[3], r22 = r[4], r23 = r[5];
            var r31 = r[6], r32 = r[7], r33 = r[8];
            e[0] = r11 * l11 + r12 * l21 + r13 * l31;
            e[1] = r11 * l12 + r12 * l22 + r13 * r32;
            e[2] = r11 * l13 + r12 * l23 + r13 * l33;
            e[3] = r21 * l11 + r22 * l21 + r23 * l31;
            e[4] = r21 * l12 + r22 * l22 + r23 * l32;
            e[5] = r21 * l13 + r22 * l23 + r23 * l33;
            e[6] = r31 * l11 + r32 * l21 + r33 * l31;
            e[7] = r31 * l12 + r32 * l22 + r33 * l32;
            e[8] = r31 * l13 + r32 * l23 + r33 * l33;
        }
        constructor(createElement = true) {
            createElement && (this.elements = _DEFAULTELEMENTS.slice());
        }
        cloneByArray(destObject) {
            this.elements.set(destObject);
        }
        determinant() {
            var f = this.elements;
            var a00 = f[0], a01 = f[1], a02 = f[2];
            var a10 = f[3], a11 = f[4], a12 = f[5];
            var a20 = f[6], a21 = f[7], a22 = f[8];
            return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
        }
        translate(trans, out) {
            var e = out.elements;
            var f = this.elements;
            var a00 = f[0], a01 = f[1], a02 = f[2];
            var a10 = f[3], a11 = f[4], a12 = f[5];
            var a20 = f[6], a21 = f[7], a22 = f[8];
            var x = trans.x, y = trans.y;
            e[0] = a00;
            e[1] = a01;
            e[2] = a02;
            e[3] = a10;
            e[4] = a11;
            e[5] = a12;
            e[6] = x * a00 + y * a10 + a20;
            e[7] = x * a01 + y * a11 + a21;
            e[8] = x * a02 + y * a12 + a22;
        }
        rotate(rad, out) {
            var e = out.elements;
            var f = this.elements;
            var a00 = f[0], a01 = f[1], a02 = f[2];
            var a10 = f[3], a11 = f[4], a12 = f[5];
            var a20 = f[6], a21 = f[7], a22 = f[8];
            var s = Math.sin(rad);
            var c = Math.cos(rad);
            e[0] = c * a00 + s * a10;
            e[1] = c * a01 + s * a11;
            e[2] = c * a02 + s * a12;
            e[3] = c * a10 - s * a00;
            e[4] = c * a11 - s * a01;
            e[5] = c * a12 - s * a02;
            e[6] = a20;
            e[7] = a21;
            e[8] = a22;
        }
        scale(scale, out) {
            var e = out.elements;
            var f = this.elements;
            var x = scale.x, y = scale.y;
            e[0] = x * f[0];
            e[1] = x * f[1];
            e[2] = x * f[2];
            e[3] = y * f[3];
            e[4] = y * f[4];
            e[5] = y * f[5];
            e[6] = f[6];
            e[7] = f[7];
            e[8] = f[8];
        }
        invert(out) {
            var e = out.elements;
            var f = this.elements;
            var a00 = f[0], a01 = f[1], a02 = f[2];
            var a10 = f[3], a11 = f[4], a12 = f[5];
            var a20 = f[6], a21 = f[7], a22 = f[8];
            var b01 = a22 * a11 - a12 * a21;
            var b11 = -a22 * a10 + a12 * a20;
            var b21 = a21 * a10 - a11 * a20;
            var det = a00 * b01 + a01 * b11 + a02 * b21;
            if (!det) {
                return;
            }
            det = 1.0 / det;
            e[0] = b01 * det;
            e[1] = (-a22 * a01 + a02 * a21) * det;
            e[2] = (a12 * a01 - a02 * a11) * det;
            e[3] = b11 * det;
            e[4] = (a22 * a00 - a02 * a20) * det;
            e[5] = (-a12 * a00 + a02 * a10) * det;
            e[6] = b21 * det;
            e[7] = (-a21 * a00 + a01 * a20) * det;
            e[8] = (a11 * a00 - a01 * a10) * det;
        }
        transpose(out) {
            var e = out.elements;
            var f = this.elements;
            if (out === this) {
                var a01 = f[1], a02 = f[2], a12 = f[5];
                e[1] = f[3];
                e[2] = f[6];
                e[3] = a01;
                e[5] = f[7];
                e[6] = a02;
                e[7] = a12;
            }
            else {
                e[0] = f[0];
                e[1] = f[3];
                e[2] = f[6];
                e[3] = f[1];
                e[4] = f[4];
                e[5] = f[7];
                e[6] = f[2];
                e[7] = f[5];
                e[8] = f[8];
            }
        }
        identity() {
            this.elements.set(_DEFAULTELEMENTS);
        }
        cloneTo(destObject) {
            var s, d;
            s = this.elements;
            d = destObject.elements;
            if (s === d) {
                return;
            }
            d.set(s);
        }
        clone() {
            var dest = new Matrix3x3(false);
            dest.elements = this.elements.slice();
            return dest;
        }
        static lookAt(eye, target, up, out) {
            Vector3.subtract(eye, target, _tempV30);
            Vector3.normalize(_tempV30, _tempV30);
            Vector3.cross(up, _tempV30, _tempV31);
            Vector3.normalize(_tempV31, _tempV31);
            Vector3.cross(_tempV30, _tempV31, _tempV32);
            var v0 = _tempV30;
            var v1 = _tempV31;
            var v2 = _tempV32;
            var me = out.elements;
            me[0] = v1.x;
            me[3] = v1.y;
            me[6] = v1.z;
            me[1] = v2.x;
            me[4] = v2.y;
            me[7] = v2.z;
            me[2] = v0.x;
            me[5] = v0.y;
            me[8] = v0.z;
        }
        static forwardLookAt(eye, target, up, out) {
            var vx = _tempV31;
            var vy = _tempV32;
            var vz = _tempV30;
            target.vsub(eye, vz).normalize();
            up.cross(vz, vx).normalize();
            vz.cross(vx, vy);
            var m = out.elements;
            m[0] = vx.x;
            m[1] = vx.y;
            m[2] = vx.z;
            m[3] = vy.x;
            m[4] = vy.y;
            m[5] = vy.z;
            m[6] = vz.x;
            m[7] = vz.y;
            m[8] = vz.z;
        }
    }
    Matrix3x3.DEFAULT = new Matrix3x3();
    Matrix3x3.Temp = new Matrix3x3();

    const TEMPVector30 = new Vector3();
    const TEMPVector31 = new Vector3();
    const TEMPVector32 = new Vector3();
    const TEMPVector33 = new Vector3();
    const _tempMatrix3x3 = new Matrix3x3();
    class Quaternion {
        static createFromYawPitchRoll(yaw, pitch, roll, out) {
            var halfRoll = roll * 0.5;
            var halfPitch = pitch * 0.5;
            var halfYaw = yaw * 0.5;
            var sinRoll = Math.sin(halfRoll);
            var cosRoll = Math.cos(halfRoll);
            var sinPitch = Math.sin(halfPitch);
            var cosPitch = Math.cos(halfPitch);
            var sinYaw = Math.sin(halfYaw);
            var cosYaw = Math.cos(halfYaw);
            out.x = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);
            out.y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);
            out.z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);
            out.w = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);
        }
        static multiply(left, right, out) {
            var lx = left.x;
            var ly = left.y;
            var lz = left.z;
            var lw = left.w;
            var rx = right.x;
            var ry = right.y;
            var rz = right.z;
            var rw = right.w;
            var a = (ly * rz - lz * ry);
            var b = (lz * rx - lx * rz);
            var c = (lx * ry - ly * rx);
            var d = (lx * rx + ly * ry + lz * rz);
            out.x = (lx * rw + rx * lw) + a;
            out.y = (ly * rw + ry * lw) + b;
            out.z = (lz * rw + rz * lw) + c;
            out.w = lw * rw - d;
        }
        static rotationAxisAngle(axis, rad, out) {
            const normalAxis = Vector3._tempVector3;
            Vector3.normalize(axis, normalAxis);
            rad *= 0.5;
            const s = Math.sin(rad);
            out.x = normalAxis.x * s;
            out.y = normalAxis.y * s;
            out.z = normalAxis.z * s;
            out.w = Math.cos(rad);
        }
        static arcTanAngle(x, y) {
            if (x == 0) {
                if (y == 1)
                    return Math.PI / 2;
                return -Math.PI / 2;
            }
            if (x > 0)
                return Math.atan(y / x);
            if (x < 0) {
                if (y > 0)
                    return Math.atan(y / x) + Math.PI;
                return Math.atan(y / x) - Math.PI;
            }
            return 0;
        }
        static angleTo(from, location, angle) {
            Vector3.subtract(location, from, TEMPVector30);
            Vector3.normalize(TEMPVector30, TEMPVector30);
            angle.x = Math.asin(TEMPVector30.y);
            angle.y = Quaternion.arcTanAngle(-TEMPVector30.z, -TEMPVector30.x);
        }
        static createFromAxisAngle(axis, rad, out) {
            rad = rad * 0.5;
            var s = Math.sin(rad);
            out.x = s * axis.x;
            out.y = s * axis.y;
            out.z = s * axis.z;
            out.w = Math.cos(rad);
        }
        static createFromMatrix4x4(mat, out) {
            var me = mat.elements;
            var sqrt;
            var half;
            var scale = me[0] + me[5] + me[10];
            if (scale > 0.0) {
                sqrt = Math.sqrt(scale + 1.0);
                out.w = sqrt * 0.5;
                sqrt = 0.5 / sqrt;
                out.x = (me[6] - me[9]) * sqrt;
                out.y = (me[8] - me[2]) * sqrt;
                out.z = (me[1] - me[4]) * sqrt;
            }
            else if ((me[0] >= me[5]) && (me[0] >= me[10])) {
                sqrt = Math.sqrt(1.0 + me[0] - me[5] - me[10]);
                half = 0.5 / sqrt;
                out.x = 0.5 * sqrt;
                out.y = (me[1] + me[4]) * half;
                out.z = (me[2] + me[8]) * half;
                out.w = (me[6] - me[9]) * half;
            }
            else if (me[5] > me[10]) {
                sqrt = Math.sqrt(1.0 + me[5] - me[0] - me[10]);
                half = 0.5 / sqrt;
                out.x = (me[4] + me[1]) * half;
                out.y = 0.5 * sqrt;
                out.z = (me[9] + me[6]) * half;
                out.w = (me[8] - me[2]) * half;
            }
            else {
                sqrt = Math.sqrt(1.0 + me[10] - me[0] - me[5]);
                half = 0.5 / sqrt;
                out.x = (me[8] + me[2]) * half;
                out.y = (me[9] + me[6]) * half;
                out.z = 0.5 * sqrt;
                out.w = (me[1] - me[4]) * half;
            }
        }
        static slerp(left, right, t, out) {
            var ax = left.x, ay = left.y, az = left.z, aw = left.w, bx = right.x, by = right.y, bz = right.z, bw = right.w;
            var omega, cosom, sinom, scale0, scale1;
            cosom = ax * bx + ay * by + az * bz + aw * bw;
            if (cosom < 0.0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
            }
            if ((1.0 - cosom) > 0.000001) {
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
            }
            else {
                scale0 = 1.0 - t;
                scale1 = t;
            }
            out.x = scale0 * ax + scale1 * bx;
            out.y = scale0 * ay + scale1 * by;
            out.z = scale0 * az + scale1 * bz;
            out.w = scale0 * aw + scale1 * bw;
            return out;
        }
        static lerp(left, right, amount, out) {
            var inverse = 1.0 - amount;
            if (Quaternion.dot(left, right) >= 0) {
                out.x = (inverse * left.x) + (amount * right.x);
                out.y = (inverse * left.y) + (amount * right.y);
                out.z = (inverse * left.z) + (amount * right.z);
                out.w = (inverse * left.w) + (amount * right.w);
            }
            else {
                out.x = (inverse * left.x) - (amount * right.x);
                out.y = (inverse * left.y) - (amount * right.y);
                out.z = (inverse * left.z) - (amount * right.z);
                out.w = (inverse * left.w) - (amount * right.w);
            }
            out.normalize(out);
        }
        static add(left, right, out) {
            out.x = left.x + right.x;
            out.y = left.y + right.y;
            out.z = left.z + right.z;
            out.w = left.w + right.w;
        }
        static dot(left, right) {
            return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
        }
        constructor(x = 0, y = 0, z = 0, w = 1) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        setValue(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        set(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        }
        scaling(scaling, out) {
            out.x = this.x * scaling;
            out.y = this.y * scaling;
            out.z = this.z * scaling;
            out.w = this.w * scaling;
        }
        normalize(out) {
            var len = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out.x = this.x * len;
                out.y = this.y * len;
                out.z = this.z * len;
                out.w = this.w * len;
            }
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        rotateX(rad, out) {
            rad *= 0.5;
            var bx = Math.sin(rad), bw = Math.cos(rad);
            out.x = this.x * bw + this.w * bx;
            out.y = this.y * bw + this.z * bx;
            out.z = this.z * bw - this.y * bx;
            out.w = this.w * bw - this.x * bx;
        }
        rotateY(rad, out) {
            rad *= 0.5;
            var by = Math.sin(rad), bw = Math.cos(rad);
            out.x = this.x * bw - this.z * by;
            out.y = this.y * bw + this.w * by;
            out.z = this.z * bw + this.x * by;
            out.w = this.w * bw - this.y * by;
        }
        rotateZ(rad, out) {
            rad *= 0.5;
            var bz = Math.sin(rad), bw = Math.cos(rad);
            out.x = this.x * bw + this.y * bz;
            out.y = this.y * bw - this.x * bz;
            out.z = this.z * bw + this.w * bz;
            out.w = this.w * bw - this.z * bz;
        }
        getYawPitchRoll(out) {
            Vector3.transformQuat(Vector3.ForwardRH, this, TEMPVector31);
            Vector3.transformQuat(Vector3.Up, this, TEMPVector32);
            var upe = TEMPVector32;
            Quaternion.angleTo(Vector3.ZERO, TEMPVector31, TEMPVector33);
            var angle = TEMPVector33;
            if (angle.x == Math.PI / 2) {
                angle.y = Quaternion.arcTanAngle(upe.z, upe.x);
                angle.z = 0;
            }
            else if (angle.x == -Math.PI / 2) {
                angle.y = Quaternion.arcTanAngle(-upe.z, -upe.x);
                angle.z = 0;
            }
            else {
                Matrix4x4.createRotationY(-angle.y, Matrix4x4.TEMPMatrix0);
                Matrix4x4.createRotationX(-angle.x, Matrix4x4.TEMPMatrix1);
                Vector3.transformCoordinate(TEMPVector32, Matrix4x4.TEMPMatrix0, TEMPVector32);
                Vector3.transformCoordinate(TEMPVector32, Matrix4x4.TEMPMatrix1, TEMPVector32);
                angle.z = Quaternion.arcTanAngle(upe.y, -upe.x);
            }
            if (angle.y <= -Math.PI)
                angle.y = Math.PI;
            if (angle.z <= -Math.PI)
                angle.z = Math.PI;
            if (angle.y >= Math.PI && angle.z >= Math.PI) {
                angle.y = 0;
                angle.z = 0;
                angle.x = Math.PI - angle.x;
            }
            var oe = out;
            oe.x = angle.y;
            oe.y = angle.x;
            oe.z = angle.z;
        }
        invert(out) {
            var a0 = this.x, a1 = this.y, a2 = this.z, a3 = this.w;
            var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
            var invDot = dot ? 1.0 / dot : 0;
            out.x = -a0 * invDot;
            out.y = -a1 * invDot;
            out.z = -a2 * invDot;
            out.w = a3 * invDot;
        }
        identity() {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 1;
        }
        fromArray(array, offset = 0) {
            this.x = array[offset + 0];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            this.w = array[offset + 3];
        }
        cloneTo(destObject) {
            if (this === destObject) {
                return;
            }
            destObject.x = this.x;
            destObject.y = this.y;
            destObject.z = this.z;
            destObject.w = this.w;
        }
        clone() {
            var dest = new Quaternion();
            this.cloneTo(dest);
            return dest;
        }
        equals(b) {
            return MathUtils3D.nearEqual(this.x, b.x) && MathUtils3D.nearEqual(this.y, b.y) && MathUtils3D.nearEqual(this.z, b.z) && MathUtils3D.nearEqual(this.w, b.w);
        }
        static rotationLookAt(forward, up, out) {
            Quaternion.lookAt(Vector3.ZERO, forward, up, out);
        }
        static lookAt(eye, target, up, out) {
            Matrix3x3.lookAt(eye, target, up, _tempMatrix3x3);
            Quaternion.rotationMatrix(_tempMatrix3x3, out);
        }
        static forwardLookAt(eye, target, up, out) {
            Matrix3x3.forwardLookAt(eye, target, up, _tempMatrix3x3);
            Quaternion.rotationMatrix(_tempMatrix3x3, out);
        }
        lengthSquared() {
            return (this.x * this.x) + (this.y * this.y) + (this.z * this.z) + (this.w * this.w);
        }
        static invert(value, out) {
            var lengthSq = value.lengthSquared();
            if (!MathUtils3D.isZero(lengthSq)) {
                lengthSq = 1.0 / lengthSq;
                out.x = -value.x * lengthSq;
                out.y = -value.y * lengthSq;
                out.z = -value.z * lengthSq;
                out.w = value.w * lengthSq;
            }
        }
        static rotationMatrix(matrix3x3, out) {
            var me = matrix3x3.elements;
            var m11 = me[0];
            var m12 = me[1];
            var m13 = me[2];
            var m21 = me[3];
            var m22 = me[4];
            var m23 = me[5];
            var m31 = me[6];
            var m32 = me[7];
            var m33 = me[8];
            var sqrt, half;
            var scale = m11 + m22 + m33;
            if (scale > 0) {
                sqrt = Math.sqrt(scale + 1);
                out.w = sqrt * 0.5;
                sqrt = 0.5 / sqrt;
                out.x = (m23 - m32) * sqrt;
                out.y = (m31 - m13) * sqrt;
                out.z = (m12 - m21) * sqrt;
            }
            else if ((m11 >= m22) && (m11 >= m33)) {
                sqrt = Math.sqrt(1 + m11 - m22 - m33);
                half = 0.5 / sqrt;
                out.x = 0.5 * sqrt;
                out.y = (m12 + m21) * half;
                out.z = (m13 + m31) * half;
                out.w = (m23 - m32) * half;
            }
            else if (m22 > m33) {
                sqrt = Math.sqrt(1 + m22 - m11 - m33);
                half = 0.5 / sqrt;
                out.x = (m21 + m12) * half;
                out.y = 0.5 * sqrt;
                out.z = (m32 + m23) * half;
                out.w = (m31 - m13) * half;
            }
            else {
                sqrt = Math.sqrt(1 + m33 - m11 - m22);
                half = 0.5 / sqrt;
                out.x = (m31 + m13) * half;
                out.y = (m32 + m23) * half;
                out.z = 0.5 * sqrt;
                out.w = (m12 - m21) * half;
            }
        }
    }
    Quaternion.TEMP = new Quaternion();
    Quaternion.DEFAULT = new Quaternion();
    Quaternion.NAN = new Quaternion(NaN, NaN, NaN, NaN);

    const _tempVector0 = new Vector3();
    const _tempVector1 = new Vector3();
    const _tempVector2 = new Vector3();
    const _tempVector3 = new Vector3();
    const _tempQuaternion = new Quaternion();
    const DEFAULTARRAY = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    class Matrix4x4 {
        static createRotationX(rad, out) {
            var oe = out.elements;
            var s = Math.sin(rad), c = Math.cos(rad);
            oe[1] = oe[2] = oe[3] = oe[4] = oe[7] = oe[8] = oe[11] = oe[12] = oe[13] = oe[14] = 0;
            oe[0] = oe[15] = 1;
            oe[5] = oe[10] = c;
            oe[6] = s;
            oe[9] = -s;
        }
        static createRotationY(rad, out) {
            var oe = out.elements;
            var s = Math.sin(rad), c = Math.cos(rad);
            oe[1] = oe[3] = oe[4] = oe[6] = oe[7] = oe[9] = oe[11] = oe[12] = oe[13] = oe[14] = 0;
            oe[5] = oe[15] = 1;
            oe[0] = oe[10] = c;
            oe[2] = -s;
            oe[8] = s;
        }
        static createRotationZ(rad, out) {
            var oe = out.elements;
            var s = Math.sin(rad), c = Math.cos(rad);
            oe[2] = oe[3] = oe[6] = oe[7] = oe[8] = oe[9] = oe[11] = oe[12] = oe[13] = oe[14] = 0;
            oe[10] = oe[15] = 1;
            oe[0] = oe[5] = c;
            oe[1] = s;
            oe[4] = -s;
        }
        static createRotationYawPitchRoll(yaw, pitch, roll, result) {
            Quaternion.createFromYawPitchRoll(yaw, pitch, roll, _tempQuaternion);
            Matrix4x4.createRotationQuaternion(_tempQuaternion, result);
        }
        static createRotationAxis(axis, angle, result) {
            var x = axis.x;
            var y = axis.y;
            var z = axis.z;
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var xx = x * x;
            var yy = y * y;
            var zz = z * z;
            var xy = x * y;
            var xz = x * z;
            var yz = y * z;
            var resultE = result.elements;
            resultE[3] = resultE[7] = resultE[11] = resultE[12] = resultE[13] = resultE[14] = 0;
            resultE[15] = 1.0;
            resultE[0] = xx + (cos * (1.0 - xx));
            resultE[1] = (xy - (cos * xy)) + (sin * z);
            resultE[2] = (xz - (cos * xz)) - (sin * y);
            resultE[4] = (xy - (cos * xy)) - (sin * z);
            resultE[5] = yy + (cos * (1.0 - yy));
            resultE[6] = (yz - (cos * yz)) + (sin * x);
            resultE[8] = (xz - (cos * xz)) + (sin * y);
            resultE[9] = (yz - (cos * yz)) - (sin * x);
            resultE[10] = zz + (cos * (1.0 - zz));
        }
        static createRotationQuaternion(rotation, result) {
            var resultE = result.elements;
            var rotationX = rotation.x;
            var rotationY = rotation.y;
            var rotationZ = rotation.z;
            var rotationW = rotation.w;
            var xx = rotationX * rotationX;
            var yy = rotationY * rotationY;
            var zz = rotationZ * rotationZ;
            var xy = rotationX * rotationY;
            var zw = rotationZ * rotationW;
            var zx = rotationZ * rotationX;
            var yw = rotationY * rotationW;
            var yz = rotationY * rotationZ;
            var xw = rotationX * rotationW;
            resultE[3] = resultE[7] = resultE[11] = resultE[12] = resultE[13] = resultE[14] = 0;
            resultE[15] = 1.0;
            resultE[0] = 1.0 - (2.0 * (yy + zz));
            resultE[1] = 2.0 * (xy + zw);
            resultE[2] = 2.0 * (zx - yw);
            resultE[4] = 2.0 * (xy - zw);
            resultE[5] = 1.0 - (2.0 * (zz + xx));
            resultE[6] = 2.0 * (yz + xw);
            resultE[8] = 2.0 * (zx + yw);
            resultE[9] = 2.0 * (yz - xw);
            resultE[10] = 1.0 - (2.0 * (yy + xx));
        }
        static createTranslate(trans, out) {
            var oe = out.elements;
            oe[4] = oe[8] = oe[1] = oe[9] = oe[2] = oe[6] = oe[3] = oe[7] = oe[11] = 0;
            oe[0] = oe[5] = oe[10] = oe[15] = 1;
            oe[12] = trans.x;
            oe[13] = trans.y;
            oe[14] = trans.z;
        }
        static createScaling(scale, out) {
            var oe = out.elements;
            oe[0] = scale.x;
            oe[5] = scale.y;
            oe[10] = scale.z;
            oe[1] = oe[4] = oe[8] = oe[12] = oe[9] = oe[13] = oe[2] = oe[6] = oe[14] = oe[3] = oe[7] = oe[11] = 0;
            oe[15] = 1;
        }
        static multiply(left, right, out) {
            var l = right.elements;
            var r = left.elements;
            var e = out.elements;
            var l11 = l[0], l12 = l[1], l13 = l[2], l14 = l[3];
            var l21 = l[4], l22 = l[5], l23 = l[6], l24 = l[7];
            var l31 = l[8], l32 = l[9], l33 = l[10], l34 = l[11];
            var l41 = l[12], l42 = l[13], l43 = l[14], l44 = l[15];
            var r11 = r[0], r12 = r[1], r13 = r[2], r14 = r[3];
            var r21 = r[4], r22 = r[5], r23 = r[6], r24 = r[7];
            var r31 = r[8], r32 = r[9], r33 = r[10], r34 = r[11];
            var r41 = r[12], r42 = r[13], r43 = r[14], r44 = r[15];
            e[0] = (l11 * r11) + (l12 * r21) + (l13 * r31) + (l14 * r41);
            e[1] = (l11 * r12) + (l12 * r22) + (l13 * r32) + (l14 * r42);
            e[2] = (l11 * r13) + (l12 * r23) + (l13 * r33) + (l14 * r43);
            e[3] = (l11 * r14) + (l12 * r24) + (l13 * r34) + (l14 * r44);
            e[4] = (l21 * r11) + (l22 * r21) + (l23 * r31) + (l24 * r41);
            e[5] = (l21 * r12) + (l22 * r22) + (l23 * r32) + (l24 * r42);
            e[6] = (l21 * r13) + (l22 * r23) + (l23 * r33) + (l24 * r43);
            e[7] = (l21 * r14) + (l22 * r24) + (l23 * r34) + (l24 * r44);
            e[8] = (l31 * r11) + (l32 * r21) + (l33 * r31) + (l34 * r41);
            e[9] = (l31 * r12) + (l32 * r22) + (l33 * r32) + (l34 * r42);
            e[10] = (l31 * r13) + (l32 * r23) + (l33 * r33) + (l34 * r43);
            e[11] = (l31 * r14) + (l32 * r24) + (l33 * r34) + (l34 * r44);
            e[12] = (l41 * r11) + (l42 * r21) + (l43 * r31) + (l44 * r41);
            e[13] = (l41 * r12) + (l42 * r22) + (l43 * r32) + (l44 * r42);
            e[14] = (l41 * r13) + (l42 * r23) + (l43 * r33) + (l44 * r43);
            e[15] = (l41 * r14) + (l42 * r24) + (l43 * r34) + (l44 * r44);
        }
        static createFromQuaternion(rotation, out) {
            var e = out.elements;
            var x = rotation.x, y = rotation.y, z = rotation.z, w = rotation.w;
            var x2 = x + x;
            var y2 = y + y;
            var z2 = z + z;
            var xx = x * x2;
            var yx = y * x2;
            var yy = y * y2;
            var zx = z * x2;
            var zy = z * y2;
            var zz = z * z2;
            var wx = w * x2;
            var wy = w * y2;
            var wz = w * z2;
            e[0] = 1 - yy - zz;
            e[1] = yx + wz;
            e[2] = zx - wy;
            e[3] = 0;
            e[4] = yx - wz;
            e[5] = 1 - xx - zz;
            e[6] = zy + wx;
            e[7] = 0;
            e[8] = zx + wy;
            e[9] = zy - wx;
            e[10] = 1 - xx - yy;
            e[11] = 0;
            e[12] = 0;
            e[13] = 0;
            e[14] = 0;
            e[15] = 1;
        }
        static createAffineTransformation(trans, rot, scale, out) {
            var oe = out.elements;
            var x = rot.x, y = rot.y, z = rot.z, w = rot.w, x2 = x + x, y2 = y + y, z2 = z + z;
            var xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2;
            var wx = w * x2, wy = w * y2, wz = w * z2, sx = scale.x, sy = scale.y, sz = scale.z;
            oe[0] = (1 - (yy + zz)) * sx;
            oe[1] = (xy + wz) * sx;
            oe[2] = (xz - wy) * sx;
            oe[3] = 0;
            oe[4] = (xy - wz) * sy;
            oe[5] = (1 - (xx + zz)) * sy;
            oe[6] = (yz + wx) * sy;
            oe[7] = 0;
            oe[8] = (xz + wy) * sz;
            oe[9] = (yz - wx) * sz;
            oe[10] = (1 - (xx + yy)) * sz;
            oe[11] = 0;
            oe[12] = trans.x;
            oe[13] = trans.y;
            oe[14] = trans.z;
            oe[15] = 1;
        }
        static createLookAt(eye, target, up, out) {
            var oE = out.elements;
            var xaxis = _tempVector0;
            var yaxis = _tempVector1;
            var zaxis = _tempVector2;
            Vector3.subtract(eye, target, zaxis);
            Vector3.normalize(zaxis, zaxis);
            Vector3.cross(up, zaxis, xaxis);
            Vector3.normalize(xaxis, xaxis);
            Vector3.cross(zaxis, xaxis, yaxis);
            oE[3] = oE[7] = oE[11] = 0;
            oE[15] = 1;
            oE[0] = xaxis.x;
            oE[4] = xaxis.y;
            oE[8] = xaxis.z;
            oE[1] = yaxis.x;
            oE[5] = yaxis.y;
            oE[9] = yaxis.z;
            oE[2] = zaxis.x;
            oE[6] = zaxis.y;
            oE[10] = zaxis.z;
            oE[12] = -Vector3.dot(xaxis, eye);
            oE[13] = -Vector3.dot(yaxis, eye);
            oE[14] = -Vector3.dot(zaxis, eye);
        }
        static createPerspective(fov, aspect, znear, zfar, out) {
            var yScale = 1.0 / Math.tan(fov * 0.5);
            var xScale = yScale / aspect;
            var halfWidth = znear / xScale;
            var halfHeight = znear / yScale;
            Matrix4x4.createPerspectiveOffCenter(-halfWidth, halfWidth, -halfHeight, halfHeight, znear, zfar, out);
        }
        static createPerspectiveOffCenter(left, right, bottom, top, znear, zfar, out) {
            var oe = out.elements;
            var zRange = zfar / (zfar - znear);
            oe[1] = oe[2] = oe[3] = oe[4] = oe[6] = oe[7] = oe[12] = oe[13] = oe[15] = 0;
            oe[0] = 2.0 * znear / (right - left);
            oe[5] = 2.0 * znear / (top - bottom);
            oe[8] = (left + right) / (right - left);
            oe[9] = (top + bottom) / (top - bottom);
            oe[10] = -zRange;
            oe[11] = -1.0;
            oe[14] = -znear * zRange;
        }
        static createOrthoOffCenter(left, right, bottom, top, znear, zfar, out) {
            var oe = out.elements;
            var zRange = 1.0 / (zfar - znear);
            oe[1] = oe[2] = oe[3] = oe[4] = oe[6] = oe[8] = oe[7] = oe[9] = oe[11] = 0;
            oe[15] = 1;
            oe[0] = 2.0 / (right - left);
            oe[5] = 2.0 / (top - bottom);
            oe[10] = -zRange;
            oe[12] = (left + right) / (left - right);
            oe[13] = (top + bottom) / (bottom - top);
            oe[14] = -znear * zRange;
        }
        constructor(m11 = 1, m12 = 0, m13 = 0, m14 = 0, m21 = 0, m22 = 1, m23 = 0, m24 = 0, m31 = 0, m32 = 0, m33 = 1, m34 = 0, m41 = 0, m42 = 0, m43 = 0, m44 = 1, elements = null) {
            if (arguments.length == 0) {
                this.elements = DEFAULTARRAY.slice();
                return;
            }
            if (arguments.length === 1 && arguments[0] === null)
                return;
            var e = elements ? this.elements = elements : this.elements = new Float32Array(16);
            e[0] = m11;
            e[1] = m12;
            e[2] = m13;
            e[3] = m14;
            e[4] = m21;
            e[5] = m22;
            e[6] = m23;
            e[7] = m24;
            e[8] = m31;
            e[9] = m32;
            e[10] = m33;
            e[11] = m34;
            e[12] = m41;
            e[13] = m42;
            e[14] = m43;
            e[15] = m44;
        }
        getElementByRowColumn(row, column) {
            if (row < 0 || row > 3)
                throw new Error("row for matrices run from 0 to 3, inclusive.");
            if (column < 0 || column > 3)
                throw new Error("column for matrices run from 0 to 3, inclusive.");
            return this.elements[(row * 4) + column];
        }
        setElementByRowColumn(row, column, value) {
            if (row < 0 || row > 3)
                throw new Error("row for matrices run from 0 to 3, inclusive.");
            if (column < 0 || column > 3)
                throw new Error("column for matrices run from 0 to 3, inclusive.");
            this.elements[(row * 4) + column] = value;
        }
        setRotation(rotation) {
            var rotationX = rotation.x;
            var rotationY = rotation.y;
            var rotationZ = rotation.z;
            var rotationW = rotation.w;
            var xx = rotationX * rotationX;
            var yy = rotationY * rotationY;
            var zz = rotationZ * rotationZ;
            var xy = rotationX * rotationY;
            var zw = rotationZ * rotationW;
            var zx = rotationZ * rotationX;
            var yw = rotationY * rotationW;
            var yz = rotationY * rotationZ;
            var xw = rotationX * rotationW;
            var e = this.elements;
            e[0] = 1.0 - (2.0 * (yy + zz));
            e[1] = 2.0 * (xy + zw);
            e[2] = 2.0 * (zx - yw);
            e[4] = 2.0 * (xy - zw);
            e[5] = 1.0 - (2.0 * (zz + xx));
            e[6] = 2.0 * (yz + xw);
            e[8] = 2.0 * (zx + yw);
            e[9] = 2.0 * (yz - xw);
            e[10] = 1.0 - (2.0 * (yy + xx));
        }
        setPosition(position) {
            var e = this.elements;
            e[12] = position.x;
            e[13] = position.y;
            e[14] = position.z;
        }
        equalsOtherMatrix(other) {
            var e = this.elements;
            var oe = other.elements;
            return (MathUtils3D.nearEqual(e[0], oe[0]) && MathUtils3D.nearEqual(e[1], oe[1]) && MathUtils3D.nearEqual(e[2], oe[2]) && MathUtils3D.nearEqual(e[3], oe[3]) && MathUtils3D.nearEqual(e[4], oe[4]) && MathUtils3D.nearEqual(e[5], oe[5]) && MathUtils3D.nearEqual(e[6], oe[6]) && MathUtils3D.nearEqual(e[7], oe[7]) && MathUtils3D.nearEqual(e[8], oe[8]) && MathUtils3D.nearEqual(e[9], oe[9]) && MathUtils3D.nearEqual(e[10], oe[10]) && MathUtils3D.nearEqual(e[11], oe[11]) && MathUtils3D.nearEqual(e[12], oe[12]) && MathUtils3D.nearEqual(e[13], oe[13]) && MathUtils3D.nearEqual(e[14], oe[14]) && MathUtils3D.nearEqual(e[15], oe[15]));
        }
        decomposeTransRotScale(translation, rotation, scale) {
            var rotationMatrix = _tempMatrix4x4$1;
            if (this.decomposeTransRotMatScale(translation, rotationMatrix, scale)) {
                Quaternion.createFromMatrix4x4(rotationMatrix, rotation);
                return true;
            }
            else {
                rotation.identity();
                return false;
            }
        }
        decomposeTransRotMatScale(translation, rotationMatrix, scale) {
            var e = this.elements;
            var te = translation;
            var re = rotationMatrix.elements;
            var se = scale;
            te.x = e[12];
            te.y = e[13];
            te.z = e[14];
            var m11 = e[0], m12 = e[1], m13 = e[2];
            var m21 = e[4], m22 = e[5], m23 = e[6];
            var m31 = e[8], m32 = e[9], m33 = e[10];
            var sX = se.x = Math.sqrt((m11 * m11) + (m12 * m12) + (m13 * m13));
            var sY = se.y = Math.sqrt((m21 * m21) + (m22 * m22) + (m23 * m23));
            var sZ = se.z = Math.sqrt((m31 * m31) + (m32 * m32) + (m33 * m33));
            if (MathUtils3D.isZero(sX) || MathUtils3D.isZero(sY) || MathUtils3D.isZero(sZ)) {
                re[1] = re[2] = re[3] = re[4] = re[6] = re[7] = re[8] = re[9] = re[11] = re[12] = re[13] = re[14] = 0;
                re[0] = re[5] = re[10] = re[15] = 1;
                return false;
            }
            var at = _tempVector0;
            at.x = m31 / sZ;
            at.y = m32 / sZ;
            at.z = m33 / sZ;
            var tempRight = _tempVector1;
            tempRight.x = m11 / sX;
            tempRight.y = m12 / sX;
            tempRight.z = m13 / sX;
            var up = _tempVector2;
            Vector3.cross(at, tempRight, up);
            var right = _tempVector1;
            Vector3.cross(up, at, right);
            re[3] = re[7] = re[11] = re[12] = re[13] = re[14] = 0;
            re[15] = 1;
            re[0] = right.x;
            re[1] = right.y;
            re[2] = right.z;
            re[4] = up.x;
            re[5] = up.y;
            re[6] = up.z;
            re[8] = at.x;
            re[9] = at.y;
            re[10] = at.z;
            ((re[0] * m11 + re[1] * m12 + re[2] * m13) < 0.0) && (se.x = -sX);
            ((re[4] * m21 + re[5] * m22 + re[6] * m23) < 0.0) && (se.y = -sY);
            ((re[8] * m31 + re[9] * m32 + re[10] * m33) < 0.0) && (se.z = -sZ);
            return true;
        }
        decomposeYawPitchRoll(yawPitchRoll) {
            var pitch = Math.asin(-this.elements[9]);
            yawPitchRoll.y = pitch;
            var test = Math.cos(pitch);
            if (test > MathUtils3D.zeroTolerance) {
                yawPitchRoll.z = Math.atan2(this.elements[1], this.elements[5]);
                yawPitchRoll.x = Math.atan2(this.elements[8], this.elements[10]);
            }
            else {
                yawPitchRoll.z = Math.atan2(-this.elements[4], this.elements[0]);
                yawPitchRoll.x = 0.0;
            }
        }
        normalize() {
            var v = this.elements;
            var c = v[0], d = v[1], e = v[2], g = Math.sqrt(c * c + d * d + e * e);
            if (g) {
                if (g == 1)
                    return;
            }
            else {
                v[0] = 0;
                v[1] = 0;
                v[2] = 0;
                return;
            }
            g = 1 / g;
            v[0] = c * g;
            v[1] = d * g;
            v[2] = e * g;
        }
        transpose() {
            var e, t;
            e = this.elements;
            t = e[1];
            e[1] = e[4];
            e[4] = t;
            t = e[2];
            e[2] = e[8];
            e[8] = t;
            t = e[3];
            e[3] = e[12];
            e[12] = t;
            t = e[6];
            e[6] = e[9];
            e[9] = t;
            t = e[7];
            e[7] = e[13];
            e[13] = t;
            t = e[11];
            e[11] = e[14];
            e[14] = t;
            return this;
        }
        invert(out) {
            var ae = this.elements;
            var oe = out.elements;
            var a00 = ae[0], a01 = ae[1], a02 = ae[2], a03 = ae[3], a10 = ae[4], a11 = ae[5], a12 = ae[6], a13 = ae[7], a20 = ae[8], a21 = ae[9], a22 = ae[10], a23 = ae[11], a30 = ae[12], a31 = ae[13], a32 = ae[14], a33 = ae[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            if (Math.abs(det) === 0.0) {
                return;
            }
            det = 1.0 / det;
            oe[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
            oe[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
            oe[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
            oe[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
            oe[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
            oe[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
            oe[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
            oe[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
            oe[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
            oe[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
            oe[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
            oe[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
            oe[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
            oe[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
            oe[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
            oe[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
        }
        static billboard(objectPosition, cameraPosition, cameraUp, cameraForward, mat) {
            Vector3.subtract(objectPosition, cameraPosition, _tempVector0);
            var lengthSq = Vector3.scalarLengthSquared(_tempVector0);
            if (MathUtils3D.isZero(lengthSq)) {
                Vector3.scale(cameraForward, -1, _tempVector1);
                _tempVector1.cloneTo(_tempVector0);
            }
            else {
                Vector3.scale(_tempVector0, 1 / Math.sqrt(lengthSq), _tempVector0);
            }
            Vector3.cross(cameraUp, _tempVector0, _tempVector2);
            Vector3.normalize(_tempVector2, _tempVector2);
            Vector3.cross(_tempVector0, _tempVector2, _tempVector3);
            var crosse = _tempVector2;
            var finale = _tempVector3;
            var diffee = _tempVector0;
            var obpose = objectPosition;
            var mate = mat.elements;
            mate[0] = crosse.x;
            mate[1] = crosse.y;
            mate[2] = crosse.z;
            mate[3] = 0.0;
            mate[4] = finale.x;
            mate[5] = finale.y;
            mate[6] = finale.z;
            mate[7] = 0.0;
            mate[8] = diffee.x;
            mate[9] = diffee.y;
            mate[10] = diffee.z;
            mate[11] = 0.0;
            mate[12] = obpose.x;
            mate[13] = obpose.y;
            mate[14] = obpose.z;
            mate[15] = 1.0;
        }
        identity() {
            this.elements.set(DEFAULTARRAY);
        }
        isIdentity() {
            let delty = function (num0, num1) {
                return Math.abs(num0 - num1) < 1e-7;
            };
            let e = this.elements;
            let defined = Matrix4x4.DEFAULT.elements;
            for (let i = 0, n = e.length; i < n; i++) {
                if (!delty(e[i], defined[i]))
                    return false;
            }
            return true;
        }
        cloneTo(destObject) {
            var s, d;
            s = this.elements;
            d = destObject.elements;
            if (s === d) {
                return;
            }
            destObject.elements.set(this.elements);
        }
        cloneByArray(destObject) {
            this.elements.set(destObject);
        }
        clone() {
            var dest = new Matrix4x4(null);
            dest.elements = this.elements.slice();
            return dest;
        }
        static translation(v3, out) {
            var oe = out.elements;
            oe[0] = oe[5] = oe[10] = oe[15] = 1;
            oe[12] = v3.x;
            oe[13] = v3.y;
            oe[14] = v3.z;
        }
        getTranslationVector(out) {
            var me = this.elements;
            out.x = me[12];
            out.y = me[13];
            out.z = me[14];
        }
        setTranslationVector(translate) {
            var me = this.elements;
            var ve = translate;
            me[12] = ve.x;
            me[13] = ve.y;
            me[14] = ve.z;
        }
        getForward(out) {
            var me = this.elements;
            out.x = -me[8];
            out.y = -me[9];
            out.z = -me[10];
        }
        setForward(forward) {
            var me = this.elements;
            me[8] = -forward.x;
            me[9] = -forward.y;
            me[10] = -forward.z;
        }
        getInvertFront() {
            this.decomposeTransRotScale(_tempVector0, _tempQuaternion, _tempVector1);
            var scale = _tempVector1;
            var isInvert = scale.x < 0;
            (scale.y < 0) && (isInvert = !isInvert);
            (scale.z < 0) && (isInvert = !isInvert);
            return isInvert;
        }
    }
    Matrix4x4.TEMPMatrix0 = new Matrix4x4();
    Matrix4x4.TEMPMatrix1 = new Matrix4x4();
    Matrix4x4.DEFAULT = new Matrix4x4();
    Matrix4x4.DEFAULTINVERT = new Matrix4x4(-1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    Matrix4x4.ZERO = new Matrix4x4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _tempMatrix4x4$1 = new Matrix4x4();

    class Vector2 {
        constructor(x = 0, y = 0) {
            this.x = x;
            this.y = y;
        }
        setValue(x, y) {
            this.x = x;
            this.y = y;
        }
        static scale(a, b, out) {
            out.x = a.x * b;
            out.y = a.y * b;
        }
        static equals(a, b) {
            return MathUtils3D.nearEqual(a.x, b.x) && MathUtils3D.nearEqual(a.y, b.y);
        }
        fromArray(array, offset = 0) {
            this.x = array[offset + 0];
            this.y = array[offset + 1];
        }
        toArray() {
            return [this.x, this.y];
        }
        writeTo(array, offset = 0) {
            array[offset + 0] = this.x;
            array[offset + 1] = this.y;
        }
        cloneTo(destObject) {
            destObject.x = this.x;
            destObject.y = this.y;
        }
        static dot(a, b) {
            return (a.x * b.x) + (a.y * b.y);
        }
        static normalize(s, out) {
            var x = s.x, y = s.y;
            var len = x * x + y * y;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out.x = x * len;
                out.y = y * len;
            }
        }
        static scalarLength(a) {
            var x = a.x, y = a.y;
            return Math.sqrt(x * x + y * y);
        }
        clone() {
            var destVector2 = new Vector2();
            this.cloneTo(destVector2);
            return destVector2;
        }
    }
    Vector2.ZERO = new Vector2(0.0, 0.0);
    Vector2.ONE = new Vector2(1.0, 1.0);
    Vector2.TempVector2 = new Vector2();

    exports.ShaderDataType = void 0;
    (function (ShaderDataType) {
        ShaderDataType[ShaderDataType["None"] = 0] = "None";
        ShaderDataType[ShaderDataType["Int"] = 1] = "Int";
        ShaderDataType[ShaderDataType["Bool"] = 2] = "Bool";
        ShaderDataType[ShaderDataType["Float"] = 3] = "Float";
        ShaderDataType[ShaderDataType["Vector2"] = 4] = "Vector2";
        ShaderDataType[ShaderDataType["Vector3"] = 5] = "Vector3";
        ShaderDataType[ShaderDataType["Vector4"] = 6] = "Vector4";
        ShaderDataType[ShaderDataType["Color"] = 7] = "Color";
        ShaderDataType[ShaderDataType["Matrix4x4"] = 8] = "Matrix4x4";
        ShaderDataType[ShaderDataType["Texture2D"] = 9] = "Texture2D";
        ShaderDataType[ShaderDataType["Texture3D"] = 10] = "Texture3D";
        ShaderDataType[ShaderDataType["TextureCube"] = 11] = "TextureCube";
        ShaderDataType[ShaderDataType["Buffer"] = 12] = "Buffer";
        ShaderDataType[ShaderDataType["Matrix3x3"] = 13] = "Matrix3x3";
        ShaderDataType[ShaderDataType["Texture2DArray"] = 14] = "Texture2DArray";
    })(exports.ShaderDataType || (exports.ShaderDataType = {}));
    function ShaderDataDefaultValue(type) {
        switch (type) {
            case exports.ShaderDataType.Int:
                return 0;
            case exports.ShaderDataType.Bool:
                return false;
            case exports.ShaderDataType.Float:
                return 0;
            case exports.ShaderDataType.Vector2:
                return Vector2.ZERO;
            case exports.ShaderDataType.Vector3:
                return Vector3.ZERO;
            case exports.ShaderDataType.Vector4:
                return Vector4.ZERO;
            case exports.ShaderDataType.Color:
                return Color.BLACK;
            case exports.ShaderDataType.Matrix4x4:
                return Matrix4x4.DEFAULT;
            case exports.ShaderDataType.Matrix3x3:
                return Matrix3x3.DEFAULT;
        }
        return null;
    }
    class ShaderData {
        constructor(ownerResource = null) {
            this._ownerResource = ownerResource;
        }
        _addCheckUBO(key, ubo, uboData) {
            throw new NotImplementedError();
        }
        _releaseUBOData() {
            throw new NotImplementedError();
        }
        getDefineData() {
            throw new NotImplementedError();
        }
        getData() {
            throw new NotImplementedError();
        }
        addDefine(define) {
            throw new NotImplementedError();
        }
        addDefines(define) {
            throw new NotImplementedError();
        }
        removeDefine(define) {
            throw new NotImplementedError();
        }
        hasDefine(define) {
            throw new NotImplementedError();
        }
        clearDefine() {
            throw new NotImplementedError();
        }
        getBool(index) {
            throw new NotImplementedError();
        }
        setBool(index, value) {
            throw new NotImplementedError();
        }
        getInt(index) {
            throw new NotImplementedError();
        }
        setInt(index, value) {
            throw new NotImplementedError();
        }
        getNumber(index) {
            throw new NotImplementedError();
        }
        setNumber(index, value) {
            throw new NotImplementedError();
        }
        getVector2(index) {
            throw new NotImplementedError();
        }
        setVector2(index, value) {
            throw new NotImplementedError();
        }
        getVector3(index) {
            throw new NotImplementedError();
        }
        setVector3(index, value) {
            throw new NotImplementedError();
        }
        getVector(index) {
            throw new NotImplementedError();
        }
        setVector(index, value) {
            throw new NotImplementedError();
        }
        getColor(index) {
            throw new NotImplementedError();
        }
        setColor(index, value) {
            throw new NotImplementedError();
        }
        getMatrix4x4(index) {
            throw new NotImplementedError();
        }
        setMatrix4x4(index, value) {
            throw new NotImplementedError();
        }
        getMatrix3x3(index) {
            throw new NotImplementedError();
        }
        setMatrix3x3(index, value) {
            throw new NotImplementedError();
        }
        getBuffer(index) {
            throw new NotImplementedError();
        }
        setBuffer(index, value) {
            throw new NotImplementedError();
        }
        setTexture(index, value) {
            throw new NotImplementedError();
        }
        getTexture(index) {
            throw new NotImplementedError();
        }
        setUniformBuffer(index, value) {
            throw new NotImplementedError();
        }
        getUniformBuffer(index) {
            throw new NotImplementedError();
        }
        setShaderData(uniformIndex, type, value) {
            switch (type) {
                case exports.ShaderDataType.Int:
                    this.setInt(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Bool:
                    this.setBool(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Float:
                    this.setNumber(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Vector2:
                    this.setVector2(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Vector3:
                    this.setVector3(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Vector4:
                    this.setVector(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Color:
                    this.setColor(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Matrix4x4:
                    this.setMatrix4x4(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Matrix3x3:
                    this.setMatrix3x3(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Texture2D:
                case exports.ShaderDataType.TextureCube:
                    this.setTexture(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Buffer:
                    this.setBuffer(uniformIndex, value);
                    break;
                default:
                    throw new Error(`unknown shader data type: ${type}`);
            }
        }
        getShaderData(uniformIndex, type) {
            switch (type) {
                case exports.ShaderDataType.Int:
                    return this.getInt(uniformIndex);
                case exports.ShaderDataType.Bool:
                    return this.getBool(uniformIndex);
                case exports.ShaderDataType.Float:
                    return this.getNumber(uniformIndex);
                case exports.ShaderDataType.Vector2:
                    return this.getVector2(uniformIndex);
                case exports.ShaderDataType.Vector3:
                    return this.getVector3(uniformIndex);
                case exports.ShaderDataType.Vector4:
                    return this.getVector(uniformIndex);
                case exports.ShaderDataType.Color:
                    return this.getColor(uniformIndex);
                case exports.ShaderDataType.Matrix4x4:
                    return this.getMatrix4x4(uniformIndex);
                case exports.ShaderDataType.Texture2D:
                case exports.ShaderDataType.TextureCube:
                    return this.getTexture(uniformIndex);
                case exports.ShaderDataType.Buffer:
                    return this.getBuffer(uniformIndex);
                case exports.ShaderDataType.Matrix3x3:
                    return this.getMatrix3x3(uniformIndex);
                case exports.ShaderDataType.Matrix4x4:
                    return this.getMatrix4x4(uniformIndex);
                default:
                    throw "unknown shader data type.";
            }
        }
        _setInternalTexture(index, value) {
            throw new NotImplementedError();
        }
        cloneTo(destObject) {
            throw new NotImplementedError();
        }
        _cloneUBO(uboDatas) {
            throw new NotImplementedError();
        }
        clone() {
            throw new NotImplementedError();
        }
        reset() {
            throw new NotImplementedError();
        }
        destroy() {
            throw new NotImplementedError();
        }
    }

    exports.UniformBufferParamsType = void 0;
    (function (UniformBufferParamsType) {
        UniformBufferParamsType[UniformBufferParamsType["Number"] = 0] = "Number";
        UniformBufferParamsType[UniformBufferParamsType["Vector2"] = 1] = "Vector2";
        UniformBufferParamsType[UniformBufferParamsType["Vector3"] = 2] = "Vector3";
        UniformBufferParamsType[UniformBufferParamsType["Vector4"] = 3] = "Vector4";
        UniformBufferParamsType[UniformBufferParamsType["Matrix4x4"] = 4] = "Matrix4x4";
        UniformBufferParamsType[UniformBufferParamsType["Vector4Array"] = 5] = "Vector4Array";
        UniformBufferParamsType[UniformBufferParamsType["MatrixArray"] = 6] = "MatrixArray";
    })(exports.UniformBufferParamsType || (exports.UniformBufferParamsType = {}));
    class UnifromBufferData {
        constructor(uniformParamsStat) {
            this._uniformParamsState = new Map(uniformParamsStat);
            this._createBuffer();
            this._updateFlag = new Vector2();
            this._resetUpdateFlag();
        }
        _createBuffer() {
            var dataPos = 0;
            this._layoutMap = {};
            const elementSize = 4;
            this._uniformParamsState.forEach((key, value) => {
                dataPos += this._addUniformParams(value, key, dataPos);
            });
            this._bytelength = Math.ceil(dataPos / 4) * 4 * elementSize;
            this._buffer = new Float32Array(dataPos);
        }
        _getArraySize(key) {
            let left = key.indexOf("[");
            let right = key.indexOf("]");
            if (left != -1 && right != -1 && left < right) {
                return parseFloat(key.substring(left + 1, right));
            }
            else
                throw key + " is illegal ";
        }
        _addUniformParams(uniformID, value, offset) {
            let size = 0;
            let posAdd = 0;
            let posG = offset % 4;
            let offsetadd;
            switch (value) {
                case exports.UniformBufferParamsType.Number:
                    size = 1;
                    posAdd = 1;
                    break;
                case exports.UniformBufferParamsType.Vector2:
                    size = 2;
                    switch (posG) {
                        case 0:
                        case 2:
                            posAdd = 2;
                            break;
                        case 1:
                        case 3:
                            offset += 1;
                            posAdd = 3;
                            break;
                    }
                    break;
                case exports.UniformBufferParamsType.Vector3:
                    size = 3;
                    posAdd = 3;
                    switch (posG) {
                        case 1:
                        case 2:
                        case 3:
                            offset += (4 - posG);
                            posAdd = (4 - posG) + 3;
                            break;
                    }
                    break;
                case exports.UniformBufferParamsType.Vector4:
                    size = 4;
                    switch (posG) {
                        case 0:
                            posAdd = 4;
                            break;
                        case 1:
                            offset += 3;
                            posAdd = 7;
                            break;
                        case 2:
                            offset += 2;
                            posAdd = 6;
                            break;
                        case 3:
                            offset += 1;
                            posAdd = 5;
                            break;
                    }
                    break;
                case exports.UniformBufferParamsType.Matrix4x4:
                    size = 16;
                    offsetadd = posG ? 4 - posG : posG;
                    offset += offsetadd;
                    posAdd = size + offsetadd;
                    break;
                case exports.UniformBufferParamsType.Vector4Array:
                    size = this._getArraySize(Shader3D.propertyIDToName(uniformID)) * 4;
                    offsetadd = posG ? 4 - posG : posG;
                    offset += offsetadd;
                    posAdd = size + offsetadd;
                    break;
                case exports.UniformBufferParamsType.MatrixArray:
                    size = this._getArraySize(Shader3D.propertyIDToName(uniformID)) * 16;
                    offsetadd = posG ? 4 - posG : posG;
                    offset += offsetadd;
                    posAdd = size + offsetadd;
                    break;
                default:
                    throw "Unifrom Buffer Params Type is illegal ";
            }
            const paramsInfo = new Vector2(offset, size);
            this._layoutMap[uniformID] = paramsInfo;
            return posAdd;
        }
        _getParamsInfo(key) {
            return this._layoutMap[key];
        }
        _setUpdateFlag(min, max) {
            if (min < this._updateFlag.x)
                this._updateFlag.x = min;
            if (max > this._updateFlag.y)
                this._updateFlag.y = max;
        }
        destroy() {
            delete this._buffer;
            this._uniformParamsState.clear();
            this._uniformParamsState = null;
            this._layoutMap = null;
            this._updateFlag = null;
        }
        _resetUpdateFlag() {
            this._updateFlag.setValue(this._buffer.length, 0);
        }
        _has(uniformID) {
            const info = this._getParamsInfo(uniformID);
            return !!info;
        }
        _setData(uniformID, value) {
            let uniformType = this._uniformParamsState.get(uniformID);
            switch (uniformType) {
                case exports.UniformBufferParamsType.Number:
                    this.setNumberbyIndex(uniformID, value);
                    break;
                case exports.UniformBufferParamsType.Vector2:
                    this.setVector2byIndex(uniformID, value);
                    break;
                case exports.UniformBufferParamsType.Vector3:
                    this.setVector3byIndex(uniformID, value);
                    break;
                case exports.UniformBufferParamsType.Vector4:
                    this.setVector4byIndex(uniformID, value);
                    break;
                case exports.UniformBufferParamsType.Matrix4x4:
                    this.setMatrixbyIndex(uniformID, value);
                    break;
                case exports.UniformBufferParamsType.Vector4Array:
                    this.setVector4ArraybyIndex(uniformID, value);
                    break;
                case exports.UniformBufferParamsType.MatrixArray:
                    this.setMatrixArraybyIndex(uniformID, value);
                    break;
            }
        }
        getbyteLength() {
            return this._bytelength;
        }
        setVector4Array(name, value) {
            const uniformID = Shader3D.propertyNameToID(name);
            this.setVector4ArraybyIndex(uniformID, value);
        }
        setVector4ArraybyIndex(uniformID, value) {
            const info = this._getParamsInfo(uniformID);
            if (!info)
                return;
            let pos = info.x;
            let count = info.y / 4;
            for (let i = 0; i < count; i++) {
                let vec = value[i];
                this._buffer[pos++] = vec.x;
                this._buffer[pos++] = vec.y;
                this._buffer[pos++] = vec.z;
                this._buffer[pos++] = vec.w;
            }
            this._setUpdateFlag(info.x, pos);
        }
        setMatrixArray(name, value) {
            const uniformID = Shader3D.propertyNameToID(name);
            this.setMatrixArraybyIndex(uniformID, value);
        }
        setMatrixArraybyIndex(uniformID, value) {
            const info = this._getParamsInfo(uniformID);
            if (!info)
                return;
            let pos = info.x;
            let count = info.y / 4;
            for (let i = 0; i < count; i++) {
                let mat = value[i];
                this._buffer.set(mat.elements, pos);
                pos += 16;
            }
            this._setUpdateFlag(info.x, pos);
        }
        setNumber(name, value) {
            const uniformID = Shader3D.propertyNameToID(name);
            this.setNumberbyIndex(uniformID, value);
        }
        setNumberbyIndex(uniformID, value) {
            const info = this._getParamsInfo(uniformID);
            if (!info)
                return;
            let pos = info.x;
            this._buffer[pos++] = value;
            this._setUpdateFlag(info.x, pos);
        }
        setVector2(name, value) {
            const uniformID = Shader3D.propertyNameToID(name);
            this.setVector2byIndex(uniformID, value);
        }
        setVector2byIndex(uniformID, value) {
            const info = this._getParamsInfo(uniformID);
            if (!info)
                return;
            let pos = info.x;
            this._buffer[pos++] = value.x;
            this._buffer[pos++] = value.y;
            this._setUpdateFlag(info.x, pos);
        }
        setVector3(name, value) {
            const uniformID = Shader3D.propertyNameToID(name);
            this.setVector3byIndex(uniformID, value);
        }
        setVector3byIndex(uniformID, value) {
            const info = this._getParamsInfo(uniformID);
            if (!info)
                return;
            let pos = info.x;
            this._buffer[pos++] = value.x;
            this._buffer[pos++] = value.y;
            this._buffer[pos++] = value.z;
            this._setUpdateFlag(info.x, pos);
        }
        setVector4(name, value) {
            const uniformID = Shader3D.propertyNameToID(name);
            this.setVector4byIndex(uniformID, value);
        }
        setVector4byIndex(uniformID, value) {
            const info = this._getParamsInfo(uniformID);
            if (!info)
                return;
            let pos = info.x;
            this._buffer[pos++] = value.x;
            this._buffer[pos++] = value.y;
            this._buffer[pos++] = value.z;
            this._buffer[pos++] = value.w;
            this._setUpdateFlag(info.x, pos);
        }
        setColor(name, value) {
            const uniformID = Shader3D.propertyNameToID(name);
            this.setColorbyIndex(uniformID, value);
        }
        setColorbyIndex(uniformID, value) {
            const info = this._getParamsInfo(uniformID);
            if (!info)
                return;
            let pos = info.x;
            this._buffer[pos++] = Color.gammaToLinearSpace(value.r);
            this._buffer[pos++] = Color.gammaToLinearSpace(value.g);
            this._buffer[pos++] = Color.gammaToLinearSpace(value.b);
            this._buffer[pos++] = Color.gammaToLinearSpace(value.a);
            this._setUpdateFlag(info.x, pos);
        }
        setMatrix(name, value) {
            const uniformID = Shader3D.propertyNameToID(name);
            this.setMatrixbyIndex(uniformID, value);
        }
        setMatrixbyIndex(uniformID, value) {
            const info = this._getParamsInfo(uniformID);
            if (!info)
                return;
            let pos = info.x;
            this._buffer.set(value.elements, pos);
            pos += 16;
            this._setUpdateFlag(info.x, pos);
        }
        clone() {
            let ubd = new UnifromBufferData(this._uniformParamsState);
            this.cloneTo(ubd);
            return ubd;
        }
        cloneTo(destObject) {
            if (destObject._bytelength == this._bytelength) {
                destObject._buffer = Float32Array.from(this._buffer);
                this._updateFlag.setValue(0, this._buffer.length);
            }
        }
    }

    class ShaderProcessInfo {
    }
    class ShaderCompileDefineBase {
        constructor(owner, name, compiledObj) {
            this._owner = owner;
            this.name = name;
            this._VS = compiledObj.vsNode;
            this._PS = compiledObj.psNode;
            this._defs = compiledObj.defs;
            this._validDefine = LayaGL.unitRenderModuleDataFactory.createDefineDatas();
            for (let k of compiledObj.defs)
                this._validDefine.add(Shader3D.getDefineByName(k));
        }
        withCompile(compileDefine) {
            return null;
        }
    }
    ShaderCompileDefineBase._defineStrings = [];

    class ShaderVariant {
        get shader() {
            return this._shader;
        }
        get subShaderIndex() {
            return this._subShaderIndex;
        }
        get passIndex() {
            return this._passIndex;
        }
        get defineNames() {
            return this._defineNames;
        }
        constructor(shader, subShaderIndex, passIndex, defines) {
            this._subShaderIndex = 0;
            this._passIndex = 0;
            this.setValue(shader, subShaderIndex, passIndex, defines);
        }
        setValue(shader, subShaderIndex, passIndex, defineNames) {
            if (shader) {
                var subShader = shader.getSubShaderAt(subShaderIndex);
                if (subShader) {
                    var pass = subShader._passes[passIndex];
                    if (pass) {
                        var validDefine = pass._validDefine;
                        for (var i = 0, n = defineNames.length; i < n; i++) {
                            var defname = defineNames[i];
                            if (!validDefine.has(Shader3D.getDefineByName(defname)))
                                throw `ShaderVariantInfo:Invalid defineName ${defname} in ${shader._name} subShaderIndex of ${subShaderIndex} passIndex of ${passIndex}.`;
                        }
                    }
                    else {
                        throw `ShaderVariantInfo:Shader don't have passIndex of ${passIndex}.`;
                    }
                }
                else {
                    throw `ShaderVariantInfo:Shader don't have subShaderIndex of ${subShaderIndex}.`;
                }
            }
            else {
                throw `ShaderVariantInfo:Shader can't be null.`;
            }
            this._shader = shader;
            this._subShaderIndex = subShaderIndex;
            this._passIndex = passIndex;
            this._defineNames = defineNames;
        }
        equal(other) {
            if (this._shader !== other._shader || this._subShaderIndex !== other._subShaderIndex || this._passIndex !== other._passIndex)
                return false;
            var defines = this._defineNames;
            var otherDefines = other._defineNames;
            if (defines.length !== otherDefines.length)
                return false;
            for (var i = 0, n = this._defineNames.length; i < n; i++) {
                if (defines[i] !== otherDefines[i])
                    return false;
            }
            return true;
        }
        clone() {
            var dest = new ShaderVariant(this._shader, this._subShaderIndex, this._passIndex, this._defineNames.slice());
            return dest;
        }
    }
    class ShaderVariantCollection {
        constructor(items) {
            this.items = items || {};
        }
        add(shaderPass, defines) {
            let shader = shaderPass._owner._owner;
            let subShaderIndex = shader._subShaders.indexOf(shaderPass._owner);
            let passIndex = shaderPass._owner._passes.indexOf(shaderPass);
            let nodeCommonMap = shaderPass.nodeCommonMap;
            if (!nodeCommonMap)
                return;
            defines = defines.filter((v) => !Shader3D._configDefineValues.has(Shader3D.getDefineByName(v)));
            let col = this.items[shader._name];
            if (!col) {
                col = [];
                this.items[shader._name] = col;
            }
            if (col.some(v => {
                return (v.subShaderIndex === subShaderIndex &&
                    v.passIndex === passIndex &&
                    v.defines.length === defines.length &&
                    v.defines.every((name, index) => name === defines[index]) &&
                    v.nodeCommonMap.length === nodeCommonMap.length &&
                    v.nodeCommonMap.every((name, index) => name === nodeCommonMap[index]));
            }))
                return;
            col.push({
                subShaderIndex: subShaderIndex,
                passIndex: passIndex,
                defines: defines,
                nodeCommonMap: nodeCommonMap.concat()
            });
            console.debug(`Shader variant: ${shader._name}/${subShaderIndex}/${passIndex}/${defines.join(",")}/${nodeCommonMap ? nodeCommonMap.join(",") : ""}`);
        }
        compileAll() {
            let items = this.items;
            for (let shaderName in items) {
                let variants = items[shaderName];
                for (let variant of variants) {
                    let suc = Shader3D.compileShaderByDefineNames(shaderName, variant.subShaderIndex, variant.passIndex, variant.defines, variant.nodeCommonMap);
                    let msg = `${shaderName}/${variant.subShaderIndex}/${variant.passIndex}/${variant.defines.join(",")}/${variant.nodeCommonMap ? variant.nodeCommonMap.join(",") : ""}`;
                    if (suc)
                        console.debug("Warm up", msg);
                    else
                        console.warn("Warm up failed!", msg);
                }
            }
        }
    }
    ShaderVariantCollection.active = new ShaderVariantCollection();

    class ShaderPass extends ShaderCompileDefineBase {
        get pipelineMode() {
            return this._pipelineMode;
        }
        set pipelineMode(value) {
            this._pipelineMode = value;
            this.moduleData.pipelineMode = value;
        }
        set nodeCommonMap(value) {
            this._nodeUniformCommonMap = value;
            this.moduleData.nodeCommonMap = value;
        }
        get nodeCommonMap() {
            return this._nodeUniformCommonMap;
        }
        get statefirst() {
            return this._statefirst;
        }
        set statefirst(value) {
            this._statefirst = value;
            this.moduleData.statefirst = value;
        }
        get renderState() {
            return this.moduleData.renderState;
        }
        constructor(owner, compiledObj) {
            super(owner, null, compiledObj);
            this._statefirst = false;
            this.moduleData = LayaGL.unitRenderModuleDataFactory.createShaderPass(this);
            this.moduleData.validDefine = this._validDefine;
        }
        static createShaderInstance(shaderpass, IS2d, compileDefine) {
            var shader;
            let shaderProcessInfo = new ShaderProcessInfo();
            shaderProcessInfo.is2D = IS2d;
            shaderProcessInfo.vs = shaderpass._VS;
            shaderProcessInfo.ps = shaderpass._PS;
            shaderProcessInfo.attributeMap = shaderpass._owner._attributeMap;
            shaderProcessInfo.uniformMap = shaderpass._owner._uniformMap;
            var defines = ShaderCompileDefineBase._defineStrings;
            defines.length = 0;
            Shader3D._getNamesByDefineData(compileDefine, defines);
            shaderProcessInfo.defineString = defines;
            if (Shader3D.debugMode)
                ShaderVariantCollection.active.add(shaderpass, defines);
            shader = LayaGL.renderDeviceFactory.createShaderInstance(shaderProcessInfo, shaderpass);
            return shader;
        }
        withCompile(compileDefine, IS2d = false) {
            var shader = this.moduleData.getCacheShader(compileDefine);
            if (shader)
                return shader;
            shader = ShaderPass.createShaderInstance(this, IS2d, compileDefine);
            this.moduleData.setCacheShader(compileDefine, shader);
            return shader;
        }
    }
    ShaderPass._debugDefineStrings = [];
    ShaderPass._debugDefineMasks = [];

    class VertexMesh {
        static __init__() {
            VertexMesh.instanceWorldMatrixDeclaration = new VertexDeclaration(64, [new VertexElement(0, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW0),
                new VertexElement(16, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW1),
                new VertexElement(32, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW2),
                new VertexElement(48, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW3)]);
            VertexMesh.instanceSimpleAnimatorDeclaration = new VertexDeclaration(16, [new VertexElement(0, VertexElementFormat.Vector4, VertexMesh.MESH_SIMPLEANIMATOR)]);
            VertexMesh.instanceLightMapScaleOffsetDeclaration = new VertexDeclaration(16, [new VertexElement(0, VertexElementFormat.Vector4, VertexMesh.MESH_LIGHTMAPSCALEOFFSET)]);
        }
        static getVertexDeclaration(vertexFlag, compatible = true) {
            var verDec = VertexMesh._vertexDeclarationMap[vertexFlag + (compatible ? "_0" : "_1")];
            if (!verDec) {
                var subFlags = vertexFlag.split(",");
                var offset = 0;
                var elements = [];
                for (var i = 0, n = subFlags.length; i < n; i++) {
                    var element;
                    switch (subFlags[i]) {
                        case "POSITION":
                            element = new VertexElement(offset, VertexElementFormat.Vector3, VertexMesh.MESH_POSITION0);
                            offset += 12;
                            break;
                        case "NORMAL":
                            element = new VertexElement(offset, VertexElementFormat.Vector3, VertexMesh.MESH_NORMAL0);
                            offset += 12;
                            break;
                        case "COLOR":
                            element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_COLOR0);
                            offset += 16;
                            break;
                        case "UV":
                            element = new VertexElement(offset, VertexElementFormat.Vector2, VertexMesh.MESH_TEXTURECOORDINATE0);
                            offset += 8;
                            break;
                        case "UV1":
                            element = new VertexElement(offset, VertexElementFormat.Vector2, VertexMesh.MESH_TEXTURECOORDINATE1);
                            offset += 8;
                            break;
                        case "BLENDWEIGHT":
                            element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_BLENDWEIGHT0);
                            offset += 16;
                            break;
                        case "BLENDINDICES":
                            if (compatible) {
                                element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_BLENDINDICES0);
                                offset += 16;
                            }
                            else {
                                element = new VertexElement(offset, VertexElementFormat.Byte4, VertexMesh.MESH_BLENDINDICES0);
                                offset += 4;
                            }
                            break;
                        case "TANGENT":
                            element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_TANGENT0);
                            offset += 16;
                            break;
                        case "NORMAL_BYTE":
                            element = new VertexElement(offset, VertexElementFormat.NorByte4, VertexMesh.MESH_NORMAL0);
                            offset += 4;
                            break;
                        default:
                            throw "VertexMesh: unknown vertex flag.";
                    }
                    elements.push(element);
                }
                verDec = new VertexDeclaration(offset, elements);
                VertexMesh._vertexDeclarationMap[vertexFlag + (compatible ? "_0" : "_1")] = verDec;
            }
            return verDec;
        }
    }
    VertexMesh.MESH_POSITION0 = 0;
    VertexMesh.MESH_COLOR0 = 1;
    VertexMesh.MESH_TEXTURECOORDINATE0 = 2;
    VertexMesh.MESH_NORMAL0 = 3;
    VertexMesh.MESH_TANGENT0 = 4;
    VertexMesh.MESH_BLENDINDICES0 = 5;
    VertexMesh.MESH_BLENDWEIGHT0 = 6;
    VertexMesh.MESH_TEXTURECOORDINATE1 = 7;
    VertexMesh.MESH_WORLDMATRIX_ROW0 = 8;
    VertexMesh.MESH_WORLDMATRIX_ROW1 = 9;
    VertexMesh.MESH_WORLDMATRIX_ROW2 = 10;
    VertexMesh.MESH_WORLDMATRIX_ROW3 = 11;
    VertexMesh.MESH_SIMPLEANIMATOR = 12;
    VertexMesh.MESH_LIGHTMAPSCALEOFFSET = 13;
    VertexMesh.MESH_CUSTOME0 = 12;
    VertexMesh.MESH_CUSTOME1 = 13;
    VertexMesh.MESH_CUSTOME2 = 14;
    VertexMesh.MESH_CUSTOME3 = 15;
    VertexMesh._vertexDeclarationMap = {};

    class SubShader {
        static regIncludeBindUnifrom(includeName, uniformMap, defaultValue) {
            let obj = {};
            let data = obj[includeName] = {};
            data["uniformMap"] = uniformMap;
            data["defaultValue"] = defaultValue;
            Object.assign(SubShader.IncludeUniformMap, obj);
        }
        constructor(attributeMap = SubShader.DefaultAttributeMap, uniformMap = {}, uniformDefaultValue = null) {
            this._uniformBufferDataMap = new Map();
            this._flags = {};
            this._passes = [];
            this.moduleData = LayaGL.unitRenderModuleDataFactory.createSubShader();
            this._attributeMap = attributeMap;
            this._uniformMap = uniformMap;
            this._uniformDefaultValue = uniformDefaultValue;
            this._uniformTypeMap = new Map();
            for (const key in uniformMap) {
                if (typeof uniformMap[key] == "object") {
                    let block = (uniformMap[key]);
                    let blockUniformMap = new Map();
                    for (const uniformName in block) {
                        let uniformType = ShaderDataTypeToUniformBufferType(block[uniformName]);
                        blockUniformMap.set(uniformName, uniformType);
                        this._uniformTypeMap.set(uniformName, block[uniformName]);
                    }
                    let blockUniformIndexMap = new Map();
                    blockUniformMap.forEach((value, key) => {
                        blockUniformIndexMap.set(Shader3D.propertyNameToID(key), value);
                    });
                    let blockData = new UnifromBufferData(blockUniformIndexMap);
                    this._uniformBufferDataMap.set(key, blockData);
                }
                else {
                    let unifromType = uniformMap[key];
                    this._uniformTypeMap.set(key, unifromType);
                    if (unifromType == exports.ShaderDataType.Texture2D || unifromType == exports.ShaderDataType.TextureCube || unifromType == exports.ShaderDataType.Texture3D || unifromType == exports.ShaderDataType.Texture2DArray) {
                        let textureGammaDefine = Shader3D.getDefineByName(`Gamma_${key}`);
                        let uniformIndex = Shader3D.propertyNameToID(key);
                        LayaGL.renderEngine.addTexGammaDefine(uniformIndex, textureGammaDefine);
                    }
                }
            }
        }
        addShaderPass(vs, ps, pipelineMode = "Forward") {
            return this._addShaderPass(ShaderCompile.compile(vs, ps), pipelineMode);
        }
        _addShaderPass(compiledObj, pipelineMode = "Forward") {
            var shaderPass = new ShaderPass(this, compiledObj);
            shaderPass.pipelineMode = pipelineMode;
            this._passes.push(shaderPass);
            this.moduleData.addShaderPass(shaderPass.moduleData);
            this._addIncludeUniform(compiledObj.includeNames);
            return shaderPass;
        }
        _addIncludeUniform(includemap) {
            for (let ele of includemap) {
                if (SubShader.IncludeUniformMap[ele]) {
                    let includeBindInfo = SubShader.IncludeUniformMap[ele];
                    let bindtypeMap = includeBindInfo["uniformMap"];
                    let bindDefaultValue = includeBindInfo["defaultValue"];
                    for (var i in bindtypeMap) {
                        if (!this._uniformTypeMap.has(i)) {
                            this._uniformTypeMap.set(i, bindtypeMap[i]);
                            this._uniformMap[i] = bindtypeMap[i];
                        }
                    }
                    for (var i in bindDefaultValue) {
                        if (!this._uniformDefaultValue[i]) {
                            this._uniformDefaultValue[i] = bindDefaultValue[i];
                        }
                    }
                }
            }
        }
    }
    SubShader.IncludeUniformMap = {};
    SubShader.DefaultAttributeMap = {
        'a_Position': [VertexMesh.MESH_POSITION0, exports.ShaderDataType.Vector4],
        'a_Normal': [VertexMesh.MESH_NORMAL0, exports.ShaderDataType.Vector3],
        'a_Tangent0': [VertexMesh.MESH_TANGENT0, exports.ShaderDataType.Vector4],
        'a_Texcoord0': [VertexMesh.MESH_TEXTURECOORDINATE0, exports.ShaderDataType.Vector2],
        'a_Texcoord1': [VertexMesh.MESH_TEXTURECOORDINATE1, exports.ShaderDataType.Vector2],
        'a_Color': [VertexMesh.MESH_COLOR0, exports.ShaderDataType.Vector4],
        'a_BoneWeights': [VertexMesh.MESH_BLENDWEIGHT0, exports.ShaderDataType.Vector4],
        'a_BoneIndices': [VertexMesh.MESH_BLENDINDICES0, exports.ShaderDataType.Vector4],
        'a_WorldMat': [VertexMesh.MESH_WORLDMATRIX_ROW0, exports.ShaderDataType.Matrix4x4],
        'a_SimpleTextureParams': [VertexMesh.MESH_SIMPLEANIMATOR, exports.ShaderDataType.Vector4],
        'a_LightmapScaleOffset': [VertexMesh.MESH_LIGHTMAPSCALEOFFSET, exports.ShaderDataType.Vector4]
    };
    function ShaderDataTypeToUniformBufferType(shaderDataType) {
        switch (shaderDataType) {
            case exports.ShaderDataType.Float:
                return exports.UniformBufferParamsType.Number;
            case exports.ShaderDataType.Vector2:
                return exports.UniformBufferParamsType.Vector2;
            case exports.ShaderDataType.Vector3:
                return exports.UniformBufferParamsType.Vector3;
            case exports.ShaderDataType.Vector4:
            case exports.ShaderDataType.Color:
                return exports.UniformBufferParamsType.Vector4;
            case exports.ShaderDataType.Matrix4x4:
                return exports.UniformBufferParamsType.Matrix4x4;
            default:
                throw "ShaderDataType can not be in UniformBuffer.";
        }
    }

    exports.ShaderFeatureType = void 0;
    (function (ShaderFeatureType) {
        ShaderFeatureType[ShaderFeatureType["DEFAULT"] = 0] = "DEFAULT";
        ShaderFeatureType[ShaderFeatureType["D3"] = 1] = "D3";
        ShaderFeatureType[ShaderFeatureType["D2"] = 2] = "D2";
        ShaderFeatureType[ShaderFeatureType["PostProcess"] = 3] = "PostProcess";
        ShaderFeatureType[ShaderFeatureType["Sky"] = 4] = "Sky";
        ShaderFeatureType[ShaderFeatureType["Effect"] = 5] = "Effect";
    })(exports.ShaderFeatureType || (exports.ShaderFeatureType = {}));
    class Shader3D {
        static init() {
            Shader3D._configDefineValues = LayaGL.unitRenderModuleDataFactory.createDefineDatas();
            Shader3D.SHADERDEFINE_BLITSCREEN_INVERTY = Shader3D.getDefineByName("BLITSCREEN_INVERTY");
            Shader3D.SHADERDEFINE_REMAP_POSITIONZ = Shader3D.getDefineByName("REMAP_Z");
            Shader3D.SHADERDEFINE_LOD_TEXTURE_SAMPLE = Shader3D.getDefineByName("LOD_TEXTURE_SAMPLE");
            Shader3D.SHADERDEFINE_BREAK_TEXTURE_SAMPLE = Shader3D.getDefineByName("BREAK_TEXTURE_SAMPLE");
            if (LayaGL.renderEngine._remapZ)
                Shader3D._configDefineValues.add(Shader3D.SHADERDEFINE_REMAP_POSITIONZ);
            if (LayaGL.renderEngine._screenInvertY && false)
                Shader3D._configDefineValues.add(Shader3D.SHADERDEFINE_BLITSCREEN_INVERTY);
            if (LayaGL.renderEngine._lodTextureSample)
                Shader3D._configDefineValues.add(Shader3D.SHADERDEFINE_LOD_TEXTURE_SAMPLE);
            if (LayaGL.renderEngine._breakTextureSample)
                Shader3D._configDefineValues.add(Shader3D.SHADERDEFINE_BREAK_TEXTURE_SAMPLE);
            Shader3D._compileDefineDatas = LayaGL.unitRenderModuleDataFactory.createDefineDatas();
        }
        static _getNamesByDefineData(defineData, out) {
            LayaGL.renderEngine.getNamesByDefineData(defineData, out);
            return out;
        }
        static getDefineByName(name) {
            return LayaGL.renderEngine.getDefineByName(name);
        }
        static propertyNameToID(name) {
            return LayaGL.renderEngine.propertyNameToID(name);
        }
        static propertyIDToName(id) {
            return LayaGL.renderEngine.propertyIDToName(id);
        }
        static addInclude(fileName, txt) {
            ShaderCompile.addInclude(fileName, txt);
        }
        static compileShaderByDefineNames(shaderName, subShaderIndex, passIndex, defineNames, nodeCommonMap) {
            var shader = Shader3D.find(shaderName);
            if (shader) {
                var subShader = shader.getSubShaderAt(subShaderIndex);
                if (subShader) {
                    var pass = subShader._passes[passIndex];
                    pass.nodeCommonMap = nodeCommonMap;
                    if (pass) {
                        var compileDefineDatas = Shader3D._compileDefineDatas;
                        Shader3D._configDefineValues.cloneTo(compileDefineDatas);
                        for (let n of defineNames)
                            compileDefineDatas.add(Shader3D.getDefineByName(n));
                        pass.withCompile(compileDefineDatas);
                        return true;
                    }
                }
            }
            return false;
        }
        static add(name, enableInstancing = false, supportReflectionProbe = false) {
            return Shader3D._preCompileShader[name] = new Shader3D(name, enableInstancing, supportReflectionProbe);
        }
        static find(name) {
            return Shader3D._preCompileShader[name];
        }
        static parse(data, basePath) {
            var _a;
            if (!data.name)
                console.warn("shader name is empty", data);
            if (!data.uniformMap)
                console.warn(`${data.name}: uniformMap is empty`);
            let shader = Shader3D.add(data.name, data.enableInstancing, data.supportReflectionProbe);
            shader._surportVolumetricGI = data.surportVolumetricGI;
            let subshader = new SubShader(data.attributeMap ? data.attributeMap : SubShader.DefaultAttributeMap, data.uniformMap, data.defaultValue);
            shader.addSubShader(subshader);
            let passDataArray = data.shaderPass;
            for (var i in passDataArray) {
                let passData = passDataArray[i];
                if (!passData.VS) {
                    console.warn(`${data.name}: VS of pass ${i} is empty`);
                    continue;
                }
                if (!passData.FS) {
                    console.warn(`${data.name}: FS of pass ${i} is empty`);
                    continue;
                }
                let shaderPass = subshader._addShaderPass(ShaderCompile.compile(passData.VS, passData.FS, basePath), passData.pipeline);
                shaderPass.statefirst = (_a = passData.statefirst) !== null && _a !== void 0 ? _a : false;
                ShaderCompile.getRenderState(passData.renderState, shaderPass.renderState);
            }
            return shader;
        }
        get name() {
            return this._name;
        }
        constructor(name, enableInstancing, supportReflectionProbe) {
            this._enableInstancing = false;
            this._supportReflectionProbe = false;
            this._surportVolumetricGI = false;
            this._subShaders = [];
            this._name = name;
            this._enableInstancing = enableInstancing;
            this._supportReflectionProbe = supportReflectionProbe;
        }
        addSubShader(subShader) {
            this._subShaders.push(subShader);
            subShader._owner = this;
            subShader.moduleData.enableInstance = this._enableInstancing;
        }
        getSubShaderAt(index) {
            return this._subShaders[index];
        }
    }
    Shader3D.PERIOD_CUSTOM = 0;
    Shader3D.PERIOD_MATERIAL = 1;
    Shader3D.PERIOD_SPRITE = 2;
    Shader3D.PERIOD_CAMERA = 3;
    Shader3D.PERIOD_SCENE = 4;
    Shader3D._propertyNameMap = {};
    Shader3D._propertyNameCounter = 0;
    Shader3D._preCompileShader = {};
    Shader3D.debugMode = false;

    class Bezier {
        constructor() {
            this._controlPoints = [new Point(), new Point(), new Point()];
            this._calFun = this.getPoint2;
        }
        _switchPoint(x, y) {
            var tPoint = this._controlPoints.shift();
            tPoint.setTo(x, y);
            this._controlPoints.push(tPoint);
        }
        getPoint2(t, rst) {
            var p1 = this._controlPoints[0];
            var p2 = this._controlPoints[1];
            var p3 = this._controlPoints[2];
            var lineX = Math.pow((1 - t), 2) * p1.x + 2 * t * (1 - t) * p2.x + Math.pow(t, 2) * p3.x;
            var lineY = Math.pow((1 - t), 2) * p1.y + 2 * t * (1 - t) * p2.y + Math.pow(t, 2) * p3.y;
            rst.push(lineX, lineY);
        }
        getPoint3(t, rst) {
            var p1 = this._controlPoints[0];
            var p2 = this._controlPoints[1];
            var p3 = this._controlPoints[2];
            var p4 = this._controlPoints[3];
            var lineX = Math.pow((1 - t), 3) * p1.x + 3 * p2.x * t * (1 - t) * (1 - t) + 3 * p3.x * t * t * (1 - t) + p4.x * Math.pow(t, 3);
            var lineY = Math.pow((1 - t), 3) * p1.y + 3 * p2.y * t * (1 - t) * (1 - t) + 3 * p3.y * t * t * (1 - t) + p4.y * Math.pow(t, 3);
            rst.push(lineX, lineY);
        }
        insertPoints(count, rst) {
            var i;
            count = count > 0 ? count : 5;
            var dLen;
            dLen = 1 / count;
            for (i = 0; i <= 1; i += dLen) {
                this._calFun(i, rst);
            }
        }
        getBezierPoints(pList, inSertCount = 5, count = 2) {
            var i, len;
            len = pList.length;
            if (len < (count + 1) * 2)
                return [];
            var rst = [];
            switch (count) {
                case 2:
                    this._calFun = this.getPoint2;
                    break;
                case 3:
                    this._calFun = this.getPoint3;
                    break;
                default:
                    return [];
            }
            while (this._controlPoints.length <= count) {
                this._controlPoints.push(Point.create());
            }
            for (i = 0; i < count * 2; i += 2) {
                this._switchPoint(pList[i], pList[i + 1]);
            }
            for (i = count * 2; i < len; i += 2) {
                this._switchPoint(pList[i], pList[i + 1]);
                if ((i / 2) % count == 0)
                    this.insertPoints(inSertCount, rst);
            }
            return rst;
        }
    }
    Bezier.I = new Bezier();

    class RenderStateContext {
        static __init__() {
        }
        static setDepthTest(value) {
            LayaGL.renderEngine._GLRenderState.setDepthTest(value);
        }
        static setDepthMask(value) {
            LayaGL.renderEngine._GLRenderState.setDepthMask(value);
        }
        static setDepthFunc(value) {
            LayaGL.renderEngine._GLRenderState.setDepthFunc(value);
        }
        static setStencilTest(value) {
            LayaGL.renderEngine._GLRenderState.setStencilTest(value);
        }
        static setStencilMask(value) {
            LayaGL.renderEngine._GLRenderState.setStencilMask(value);
        }
        static setStencilFunc(fun, ref) {
            LayaGL.renderEngine._GLRenderState.setStencilFunc(fun, ref);
        }
        static setstencilOp(fail, zfail, zpass) {
            LayaGL.renderEngine._GLRenderState.setstencilOp(fail, zfail, zpass);
        }
        static setBlend(value) {
            LayaGL.renderEngine._GLRenderState.setBlend(value);
        }
        static setBlendEquation(blendEquation) {
            LayaGL.renderEngine._GLRenderState.setBlendEquation(blendEquation);
        }
        static setBlendEquationSeparate(blendEquationRGB, blendEquationAlpha) {
            LayaGL.renderEngine._GLRenderState.setBlendEquationSeparate(blendEquationRGB, blendEquationAlpha);
        }
        static setBlendFunc(sFactor, dFactor) {
            LayaGL.renderEngine._GLRenderState.setBlendFunc(sFactor, dFactor);
        }
        static setBlendFuncSeperate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
            LayaGL.renderEngine._GLRenderState.setBlendFuncSeperate(srcRGB, dstRGB, srcAlpha, dstAlpha);
        }
        static setCullFace(value) {
            LayaGL.renderEngine._GLRenderState.setCullFace(value);
        }
        static setFrontFace(value) {
            LayaGL.renderEngine._GLRenderState.setFrontFace(value);
        }
    }
    RenderStateContext.stencilFuncArray = new Array(2);
    RenderStateContext.blendEquationSeparateArray = new Array(2);
    RenderStateContext.blenfunArray = new Array(2);
    RenderStateContext.blendFuncSeperateArray = new Array(4);
    RenderStateContext.stencilOpArray = new Array(3);

    class BlendMode {
        static _init_() {
            BlendMode.fns = [
                BlendMode.BlendNormal,
                BlendMode.BlendAdd,
                BlendMode.BlendMultiply,
                BlendMode.BlendScreen,
                BlendMode.BlendOverlay,
                BlendMode.BlendLight,
                BlendMode.BlendMask,
                BlendMode.BlendDestinationOut,
                BlendMode.BlendAddOld,
                BlendMode.BlendSourceAlpha,
            ];
            BlendMode.targetFns = [
                BlendMode.BlendNormalTarget,
                BlendMode.BlendAddTarget,
                BlendMode.BlendMultiplyTarget,
                BlendMode.BlendScreenTarget,
                BlendMode.BlendOverlayTarget,
                BlendMode.BlendLightTarget,
                BlendMode.BlendMask,
                BlendMode.BlendDestinationOut,
                BlendMode.BlendAddTargetOld,
                BlendMode.BlendSourceAlpha
            ];
        }
        static BlendNormal() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.OneMinusSourceAlpha);
        }
        static BlendAddOld() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.DestinationAlpha);
        }
        static BlendAdd() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.One);
        }
        static BlendMultiply() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.DestinationColor, exports.BlendFactor.OneMinusSourceAlpha);
        }
        static BlendScreen() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.One);
        }
        static BlendOverlay() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.OneMinusSourceAlpha);
        }
        static BlendLight() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.One);
        }
        static BlendNormalTarget() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.OneMinusSourceAlpha);
        }
        static BlendAddTargetOld() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.DestinationAlpha);
        }
        static BlendAddTarget() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.One);
        }
        static BlendMultiplyTarget() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.DestinationColor, exports.BlendFactor.OneMinusSourceAlpha);
        }
        static BlendScreenTarget() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.One);
        }
        static BlendOverlayTarget() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.OneMinusSourceColor);
        }
        static BlendLightTarget() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.One);
        }
        static BlendMask() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.Zero, exports.BlendFactor.SourceAlpha);
        }
        static BlendDestinationOut() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.Zero, exports.BlendFactor.Zero);
        }
        static BlendSourceAlpha() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.SourceAlpha, exports.BlendFactor.OneMinusSourceAlpha);
        }
    }
    BlendMode.activeBlendFunction = null;
    BlendMode.NAMES = [
        "normal",
        "add",
        "multiply",
        "screen",
        "overlay",
        "light",
        "mask",
        "destination-out",
        "add_old"
    ];
    BlendMode.TOINT = {
        "normal": 0,
        "add": 1,
        "multiply": 2,
        "screen": 3,
        "overlay": 4,
        "light": 5,
        "mask": 6,
        "destination-out": 7,
        "lighter": 1,
        "lighter_old": 8,
        "add_old": 8
    };
    BlendMode.NORMAL = "normal";
    BlendMode.MASK = "mask";
    BlendMode.LIGHTER = "lighter";

    const _COLOR_MAP = { "purple": "#800080", "orange": "#ffa500", "white": '#FFFFFF', "red": '#FF0000', "green": '#00FF00', "blue": '#0000FF', "black": '#000000', "yellow": '#FFFF00', 'gray': '#808080' };
    class ColorUtils {
        constructor(value) {
            this.arrColor = [];
            if (!ColorUtils._DEFAULT)
                ColorUtils._initDefault();
            if (value == null || value == 'none') {
                this.strColor = "#00000000";
                this.numColor = 0;
                this.arrColor = [0, 0, 0, 0];
                return;
            }
            let color;
            if (typeof (value) == 'string') {
                color = Utils.fromStringColor(value);
                this.strColor = value;
            }
            else {
                color = value;
                this.strColor = Utils.toHexColor(color);
            }
            if (this.strColor.indexOf("rgba") >= 0 || this.strColor.length === 9) {
                this.arrColor = [((0xFF000000 & color) >>> 24) / 255, ((0xFF0000 & color) >> 16) / 255, ((0xFF00 & color) >> 8) / 255, (0xFF & color) / 255];
                this.numColor = (0xff000000 & color) >>> 24 | (color & 0xff0000) >> 8 | (color & 0x00ff00) << 8 | ((color & 0xff) << 24);
            }
            else {
                this.arrColor = [((0xFF0000 & color) >> 16) / 255, ((0xFF00 & color) >> 8) / 255, (0xFF & color) / 255, 1];
                this.numColor = 0xff000000 | (color & 0xff0000) >> 16 | (color & 0x00ff00) | (color & 0xff) << 16;
            }
        }
        static _initDefault() {
            ColorUtils._DEFAULT = {};
            for (var i in _COLOR_MAP)
                ColorUtils._SAVE[i] = ColorUtils._DEFAULT[i] = new ColorUtils(_COLOR_MAP[i]);
            return ColorUtils._DEFAULT;
        }
        static _initSaveMap() {
            ColorUtils._SAVE_SIZE = 0;
            ColorUtils._SAVE = Object.assign({}, ColorUtils._DEFAULT);
        }
        static create(value) {
            let key = value + "";
            let color = ColorUtils._SAVE[key];
            if (color != null)
                return color;
            if (ColorUtils._SAVE_SIZE > 500)
                ColorUtils._initSaveMap();
            ColorUtils._SAVE_SIZE++;
            return ColorUtils._SAVE[key] = new ColorUtils(value);
        }
    }
    ColorUtils._SAVE = {};
    ColorUtils._SAVE_SIZE = 0;

    class DrawStyle {
        static _Defaultinit() {
            DrawStyle.DEFAULT = new DrawStyle("#000000");
        }
        static create(value) {
            if (value) {
                var color = (value instanceof ColorUtils) ? value : ColorUtils.create(value);
                return color._drawStyle || (color._drawStyle = new DrawStyle(value));
            }
            return DrawStyle.DEFAULT;
        }
        constructor(value) {
            this.setValue(value);
        }
        setValue(value) {
            if (value) {
                this._color = (value instanceof ColorUtils) ? value : ColorUtils.create(value);
            }
            else
                this._color = ColorUtils.create("#000000");
        }
        reset() {
            this._color = ColorUtils.create("#000000");
        }
        toInt() {
            return this._color.numColor;
        }
        equal(value) {
            if (typeof (value) == 'string')
                return this._color.strColor === value;
            if (value instanceof ColorUtils)
                return this._color.numColor === value.numColor;
            return false;
        }
        toColorStr() {
            return this._color.strColor;
        }
    }

    class Path {
        constructor() {
            this._lastOriX = 0;
            this._lastOriY = 0;
            this.paths = [];
            this._curPath = null;
        }
        beginPath(convex) {
            this.paths.length = 1;
            this._curPath = this.paths[0] = new renderPath();
            this._curPath.convex = convex;
        }
        closePath() {
            this._curPath.loop = true;
        }
        newPath() {
            this._curPath = new renderPath();
            this.paths.push(this._curPath);
        }
        addPoint(pointX, pointY) {
            this._curPath.path.push(pointX, pointY);
        }
        push(points, convex) {
            if (!this._curPath) {
                this._curPath = new renderPath();
                this.paths.push(this._curPath);
            }
            else if (this._curPath.path.length > 0) {
                this._curPath = new renderPath();
                this.paths.push(this._curPath);
            }
            var rp = this._curPath;
            rp.path = points.slice();
            rp.convex = convex;
        }
        reset() {
            this.paths.length = 0;
        }
    }
    class renderPath {
        constructor() {
            this.path = [];
            this.loop = false;
            this.convex = false;
        }
    }

    class SaveBase {
        constructor() {
        }
        static _createArray() {
            var value = [];
            value._length = 0;
            return value;
        }
        static _init() {
            var namemap = SaveBase._namemap = {};
            namemap[SaveBase.TYPE_ALPHA] = "ALPHA";
            namemap[SaveBase.TYPE_FILESTYLE] = "fillStyle";
            namemap[SaveBase.TYPE_FONT] = "font";
            namemap[SaveBase.TYPE_LINEWIDTH] = "lineWidth";
            namemap[SaveBase.TYPE_STROKESTYLE] = "strokeStyle";
            namemap[SaveBase.TYPE_ENABLEMERGE] = "_mergeID";
            namemap[SaveBase.TYPE_MARK] = namemap[SaveBase.TYPE_TRANSFORM] = namemap[SaveBase.TYPE_TRANSLATE] = [];
            namemap[SaveBase.TYPE_TEXTBASELINE] = "textBaseline";
            namemap[SaveBase.TYPE_TEXTALIGN] = "textAlign";
            namemap[SaveBase.TYPE_GLOBALCOMPOSITEOPERATION] = "_nBlendType";
            namemap[SaveBase.TYPE_SHADER] = "shader";
            namemap[SaveBase.TYPE_FILTERS] = "filters";
            namemap[SaveBase.TYPE_COLORFILTER] = '_colorFiler';
            return namemap;
        }
        isSaveMark() { return false; }
        restore(context) {
            this._dataObj[this._valueName] = this._value;
            SaveBase.POOL[SaveBase.POOL._length++] = this;
            this._newSubmit && (context.stopMerge = true);
        }
        static save(context, type, dataObj, newSubmit) {
            if ((context._saveMark._saveuse & type) !== type) {
                context._saveMark._saveuse |= type;
                var cache = SaveBase.POOL;
                var o = cache._length > 0 ? cache[--cache._length] : (new SaveBase());
                o._value = dataObj[o._valueName = SaveBase._namemap[type]];
                o._dataObj = dataObj;
                o._newSubmit = newSubmit;
                var _save = context._save;
                _save[_save._length++] = o;
            }
        }
    }
    SaveBase.TYPE_ALPHA = 0x1;
    SaveBase.TYPE_FILESTYLE = 0x2;
    SaveBase.TYPE_FONT = 0x8;
    SaveBase.TYPE_LINEWIDTH = 0x100;
    SaveBase.TYPE_STROKESTYLE = 0x200;
    SaveBase.TYPE_MARK = 0x400;
    SaveBase.TYPE_TRANSFORM = 0x800;
    SaveBase.TYPE_TRANSLATE = 0x1000;
    SaveBase.TYPE_ENABLEMERGE = 0x2000;
    SaveBase.TYPE_TEXTBASELINE = 0x4000;
    SaveBase.TYPE_TEXTALIGN = 0x8000;
    SaveBase.TYPE_GLOBALCOMPOSITEOPERATION = 0x10000;
    SaveBase.TYPE_CLIPRECT = 0x20000;
    SaveBase.TYPE_CLIPRECT_STENCIL = 0x40000;
    SaveBase.TYPE_IBVB = 0x80000;
    SaveBase.TYPE_SHADER = 0x100000;
    SaveBase.TYPE_FILTERS = 0x200000;
    SaveBase.TYPE_FILTERS_TYPE = 0x400000;
    SaveBase.TYPE_COLORFILTER = 0x800000;
    SaveBase.POOL = SaveBase._createArray();
    SaveBase._namemap = SaveBase._init();

    class SaveClipRect {
        constructor() {
            this._globalClipMatrix = new Matrix();
            this._clipInfoID = -1;
            this._clipRect = new Rectangle();
        }
        isSaveMark() { return false; }
        restore(context) {
            this._globalClipMatrix.copyTo(context._globalClipMatrix);
            this._clipRect.clone(context._clipRect);
            context._clipInfoID = this._clipInfoID;
            SaveClipRect.POOL[SaveClipRect.POOL._length++] = this;
        }
        static save(context) {
            if ((context._saveMark._saveuse & SaveBase.TYPE_CLIPRECT) == SaveBase.TYPE_CLIPRECT)
                return;
            context._saveMark._saveuse |= SaveBase.TYPE_CLIPRECT;
            var cache = SaveClipRect.POOL;
            var o = cache._length > 0 ? cache[--cache._length] : (new SaveClipRect());
            context._globalClipMatrix.copyTo(o._globalClipMatrix);
            context._clipRect.clone(o._clipRect);
            o._clipInfoID = context._clipInfoID;
            var _save = context._save;
            _save[_save._length++] = o;
        }
    }
    SaveClipRect.POOL = SaveBase._createArray();

    class SaveMark {
        constructor() {
            this._saveuse = 0;
        }
        isSaveMark() {
            return true;
        }
        restore(context) {
            context._saveMark = this._preSaveMark;
            SaveMark.POOL[SaveMark.POOL._length++] = this;
        }
        static Create(context) {
            var no = SaveMark.POOL;
            var o = no._length > 0 ? no[--no._length] : (new SaveMark());
            o._saveuse = 0;
            o._preSaveMark = context._saveMark;
            context._saveMark = o;
            return o;
        }
    }
    SaveMark.POOL = SaveBase._createArray();

    class SaveTransform {
        constructor() {
            this._matrix = new Matrix();
        }
        isSaveMark() { return false; }
        restore(context) {
            context._curMat = this._savematrix;
            SaveTransform.POOL[SaveTransform.POOL._length++] = this;
        }
        static save(context) {
            var _saveMark = context._saveMark;
            if ((_saveMark._saveuse & SaveBase.TYPE_TRANSFORM) === SaveBase.TYPE_TRANSFORM)
                return;
            _saveMark._saveuse |= SaveBase.TYPE_TRANSFORM;
            var no = SaveTransform.POOL;
            var o = no._length > 0 ? no[--no._length] : (new SaveTransform());
            o._savematrix = context._curMat;
            context._curMat = context._curMat.copyTo(o._matrix);
            var _save = context._save;
            _save[_save._length++] = o;
        }
    }
    SaveTransform.POOL = SaveBase._createArray();

    class SaveTranslate {
        constructor() {
            this._mat = new Matrix();
        }
        isSaveMark() { return false; }
        restore(context) {
            this._mat.copyTo(context._curMat);
            SaveTranslate.POOL[SaveTranslate.POOL._length++] = this;
        }
        static save(context) {
            var no = SaveTranslate.POOL;
            var o = no._length > 0 ? no[--no._length] : (new SaveTranslate());
            context._curMat.copyTo(o._mat);
            var _save = context._save;
            _save[_save._length++] = o;
        }
    }
    SaveTranslate.POOL = SaveBase._createArray();

    var prime_ps = "#define SHADER_NAME PrimitiveFS2D\r\nprecision mediump float;\r\n\r\n#include \"Sprite2DFrag.glsl\";\r\n\r\nvoid main(){\r\n\tclip();\r\n\tgl_FragColor = getGlColor(v_color);\r\n\tgl_FragColor.rgb*=gl_FragColor.a;\r\n}";

    var prime_vs = "#define SHADER_NAME PrimitiveVS2D\r\n#include \"Sprite2DVertex.glsl\";\r\n\r\n\r\n#ifdef WORLDMAT\r\n\tuniform mat4 mmat;\r\n#endif\r\n\r\nvoid main(){\r\n\tvec4 pos;\r\n\t//先计算位置，再做裁剪\r\n\tgetPosition(pos);\r\n\tvertexInfo info;\r\n\tgetVertexInfo(info);\r\n\t\r\n\t//Update \r\n\tv_color = info.color;\r\n\tv_cliped = info.cliped;\r\n\t\r\n\tgl_Position = pos;\r\n}";

    var texture_ps = "#define SHADER_NAME TextureFS2D\r\n//texture和fillrect使用的。\r\n#if defined(GL_FRAGMENT_PRECISION_HIGH) // 原来的写法会被我们自己的解析流程处理，而我们的解析是不认内置宏的，导致被删掉，所以改成 if defined 了\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n\r\n#include \"Sprite2DFrag.glsl\";\r\n\r\nvoid main()\r\n{\r\n    clip();\r\n    vec4 color = getSpriteTextureColor();\r\n    setglColor(color);\r\n}\r\n";

    var texture_vs = "#define SHADER_NAME TextureVS2D\r\n#include \"Sprite2DVertex.glsl\";\r\n\r\nvoid main() {\r\n\tvec4 pos;\r\n\t//先计算位置，再做裁剪\r\n\tgetPosition(pos);\r\n\tvertexInfo info;\r\n\tgetVertexInfo(info);\r\n\r\n\tv_cliped = info.cliped;\r\n\tv_texcoordAlpha = info.texcoordAlpha;\r\n\tv_useTex = info.useTex;\r\n\tv_color = info.color;\r\n\r\n\tgl_Position = pos;\r\n\r\n}\r\n";

    var Sprite2DFrag = "vec3 gammaToLinear(in vec3 value)\r\n{\r\n    return pow((value + 0.055) / 1.055, vec3(2.4));\r\n}\r\n\r\nvec4 gammaToLinear(in vec4 value)\r\n{\r\n    return vec4(gammaToLinear(value.rgb), value.a);\r\n}\r\n\r\nvec3 linearToGamma(in vec3 value)\r\n{\r\n    return vec3(mix(pow(value.rgb, vec3(0.41666)) * 1.055 - vec3(0.055), value.rgb * 12.92, vec3(lessThanEqual(value.rgb, vec3(0.0031308)))));\r\n\r\n    // return pow(value, vec3(1.0 / 2.2));\r\n    // return pow(value, vec3(0.455));\r\n}\r\n\r\nvec4 linearToGamma(in vec4 value)\r\n{\r\n    return vec4(linearToGamma(value.rgb), value.a);\r\n}\r\n\r\nvec4 transspaceColor(vec4 color)\r\n{\r\n     \r\n #ifndef GAMMATEXTURE\r\n     //是linear数据\r\n     #ifdef GAMMASPACE\r\n         color.xyz = linearToGamma(color.xyz);    \r\n     #endif\r\n #else\r\n     //gamma数据\r\n     #ifndef GAMMASPACE\r\n         color.xyz = gammaToLinear(color.xyz);\r\n     #endif\r\n #endif\r\n     return color;\r\n }\r\n\r\n#if defined(PRIMITIVEMESH)\r\n    varying vec4 v_color;\r\n    varying vec2 v_cliped;\r\n  \r\n\r\n    vec4 getGlColor(vec4 color){\r\n        #ifdef GAMMASPACE\r\n            return color;\r\n        #else\r\n            return gammaToLinear(color);\r\n        #endif\r\n    }\r\n\r\n#elif defined(TEXTUREVS)\r\n    varying vec2 v_cliped;\r\n    varying vec4 v_texcoordAlpha;\r\n    varying vec4 v_color;\r\n    varying float v_useTex;\r\n    \r\n    //uniform\r\n    uniform sampler2D u_spriteTexture;\r\n\r\n    #ifdef BLUR_FILTER\r\n        uniform vec4 u_strength_sig2_2sig2_gauss1; // TODO模糊的过程中会导致变暗变亮\r\n        uniform vec2 u_blurInfo;\r\n        #define PI 3.141593\r\n    #endif\r\n\r\n    #ifdef COLOR_FILTER\r\n        uniform vec4 u_colorAlpha;\r\n        uniform mat4 u_colorMat;\r\n    #endif\r\n\r\n    #ifdef GLOW_FILTER\r\n        uniform vec4 u_color;\r\n        uniform vec4 u_blurInfo1;\r\n        uniform vec4 u_blurInfo2;\r\n    #endif\r\n\r\n    #ifdef COLOR_ADD\r\n        uniform vec4 u_colorAdd;\r\n    #endif\r\n\r\n    #ifdef FILLTEXTURE\r\n        uniform vec4 u_TexRange; // startu,startv,urange, vrange\r\n    #endif\r\n\r\n\r\n    #ifdef BLUR_FILTER\r\n        float getGaussian(float x, float y)\r\n        {\r\n            return u_strength_sig2_2sig2_gauss1.w * exp(-(x * x + y * y) / u_strength_sig2_2sig2_gauss1.z);\r\n        }\r\n\r\n        vec4 blur()\r\n        {\r\n            const float blurw = 9.0;\r\n            vec4 vec4Color = vec4(0.0, 0.0, 0.0, 0.0);\r\n            vec2 halfsz = vec2(blurw, blurw) / 2.0 / u_blurInfo;\r\n            vec2 startpos = v_texcoordAlpha.xy - halfsz;\r\n            vec2 ctexcoord = startpos;\r\n            vec2 step = 1.0 / u_blurInfo; //每个像素\r\n\r\n            for (float y = 0.0; y <= blurw; ++y)\r\n            {\r\n                ctexcoord.x = startpos.x;\r\n                for (float x = 0.0; x <= blurw; ++x)\r\n                {\r\n                    // TODO 纹理坐标的固定偏移应该在vs中处理\r\n                    vec4Color +=transspaceColor(texture2D(u_spriteTexture, ctexcoord) * getGaussian(x - blurw / 2.0, y - blurw / 2.0));\r\n                    ctexcoord.x += step.x;\r\n                }\r\n                ctexcoord.y += step.y;\r\n            }\r\n            // vec4Color.w=1.0;  这个会导致丢失alpha。以后有时间再找模糊会导致透明的问题\r\n            return vec4Color;\r\n        }\r\n    #endif\r\n\r\n    vec4 getSpriteTextureColor(){\r\n        #ifdef FILLTEXTURE\r\n            vec4 color = texture2D(u_spriteTexture, fract(v_texcoordAlpha.xy) * u_TexRange.zw + u_TexRange.xy);\r\n        #else\r\n            vec4 color = texture2D(u_spriteTexture, v_texcoordAlpha.xy);\r\n        #endif\r\n        return transspaceColor(color);\r\n    }\r\n\r\n    void setglColor(in vec4 color){\r\n        if (v_useTex <= 0.)\r\n            color = vec4(1., 1., 1., 1.);\r\n\r\n        color.a *= v_color.w;\r\n        // color.rgb*=v_color.w;\r\n        vec4 transColor = v_color;\r\n        #ifndef GAMMASPACE\r\n            transColor = gammaToLinear(v_color);\r\n        #endif\r\n        color.rgb *= transColor.rgb;\r\n        gl_FragColor = color;\r\n\r\n        #ifdef COLOR_ADD\r\n            gl_FragColor = vec4(u_colorAdd.rgb, u_colorAdd.a * gl_FragColor.a);\r\n            gl_FragColor.xyz *= u_colorAdd.a;\r\n        #endif\r\n\r\n        #ifdef BLUR_FILTER\r\n            gl_FragColor = blur();\r\n            gl_FragColor.w *= v_color.w;\r\n        #endif\r\n\r\n        #ifdef COLOR_FILTER\r\n            mat4 alphaMat = u_colorMat;\r\n\r\n            alphaMat[0][3] *= gl_FragColor.a;\r\n            alphaMat[1][3] *= gl_FragColor.a;\r\n            alphaMat[2][3] *= gl_FragColor.a;\r\n\r\n            gl_FragColor = gl_FragColor * alphaMat;\r\n            gl_FragColor += u_colorAlpha / 255.0 * gl_FragColor.a;\r\n        #endif\r\n\r\n        #ifdef GLOW_FILTER\r\n            const float c_IterationTime = 10.0;\r\n            float floatIterationTotalTime = c_IterationTime * c_IterationTime;\r\n            vec4 vec4Color = vec4(0.0, 0.0, 0.0, 0.0);\r\n            vec2 vec2FilterDir = vec2(-u_blurInfo1.z / u_blurInfo2.x, -u_blurInfo1.w / u_blurInfo2.y);\r\n            vec2 vec2FilterOff = vec2(u_blurInfo1.x / u_blurInfo2.x / c_IterationTime * 2.0, u_blurInfo1.y / u_blurInfo2.y / c_IterationTime * 2.0);\r\n            float maxNum = u_blurInfo1.x * u_blurInfo1.y;\r\n            vec2 vec2Off = vec2(0.0, 0.0);\r\n            float floatOff = c_IterationTime / 2.0;\r\n            for (float i = 0.0; i <= c_IterationTime; ++i){\r\n                for (float j = 0.0; j <= c_IterationTime; ++j){\r\n                    vec2Off = vec2(vec2FilterOff.x * (i - floatOff), vec2FilterOff.y * (j - floatOff));\r\n                    vec4Color += transspaceColor(texture2D(u_spriteTexture, v_texcoordAlpha.xy + vec2FilterDir + vec2Off))  ;\r\n                }\r\n            }\r\n            vec4Color /= floatIterationTotalTime;\r\n            gl_FragColor = vec4(u_color.rgb, vec4Color.a * u_blurInfo2.z);\r\n            gl_FragColor.rgb *= gl_FragColor.a;\r\n        #endif\r\n    }\r\n#endif\r\n\r\n\r\n\r\nvoid clip(){\r\n    if(v_cliped.x<0.) discard;\r\n    if(v_cliped.x>1.) discard;\r\n    if(v_cliped.y<0.) discard;\r\n    if(v_cliped.y>1.) discard;\r\n}";

    var Sprite2DShaderInfo = "\r\n#if defined(PRIMITIVEMESH)\r\n    struct vertexInfo {\r\n        vec4 color;\r\n        vec2 cliped;\r\n    };\r\n#elif defined(TEXTUREVS)\r\n   struct vertexInfo {\r\n        vec4 color;\r\n        vec2 cliped;\r\n        vec4 texcoordAlpha;\r\n        float useTex;\r\n    };\r\n#endif";

    var Sprite2DVertex = "#include \"Sprite2DShaderInfo.glsl\";\r\nuniform vec4 u_clipMatDir;\r\nuniform vec2 u_clipMatPos;// 这个是全局的，不用再应用矩阵了。\r\nuniform vec2 u_size;\r\nuniform float u_VertAlpha;\r\nvarying vec2 v_cliped;\r\n#ifdef WORLDMAT\r\n    uniform mat4 u_mmat;\r\n    vec4 transedPos;\r\n#endif\r\nvarying vec4 v_color;\r\n\r\n\r\n#if defined(PRIMITIVEMESH)\r\n    // attribute vec4 a_position;\r\n    // attribute vec4 a_attribColor;\r\n\r\n    void getVertexInfo(inout vertexInfo info){\r\n        info.color = a_attribColor;\r\n        info.color.a*=u_VertAlpha;\r\n        float clipw = length(u_clipMatDir.xy);\r\n        float cliph = length(u_clipMatDir.zw);\r\n        #ifdef WORLDMAT\r\n            vec2 clippos = transedPos.xy - u_clipMatPos.xy;\r\n        #else\r\n        vec2 clippos = a_position.xy - u_clipMatPos.xy;\t//pos已经应用矩阵了，为了减的有意义，clip的位置也要缩放\r\n        #endif\r\n\r\n        if(clipw>20000. && cliph>20000.)\r\n            info.cliped = vec2(0.5,0.5);\r\n        else {\r\n            //clipdir是带缩放的方向，由于上面clippos是在缩放后的空间计算的，所以需要把方向先normalize一下\r\n            info.cliped =vec2( dot(clippos,u_clipMatDir.xy)/clipw/clipw, dot(clippos,u_clipMatDir.zw)/cliph/cliph);\r\n        }\r\n    }\r\n\r\n    void getPosition(inout vec4 pos){\r\n        pos = vec4(a_position.xy,0.,1.);\r\n        #ifdef WORLDMAT\r\n            pos = u_mmat*pos;\r\n            transedPos=pos;\r\n            pos = vec4((pos.x/u_size.x-0.5)*2.0,(0.5-pos.y/u_size.y)*2.0,pos.z,1.0);\r\n        #else\r\n            pos = vec4((a_position.x/u_size.x-0.5)*2.0,(0.5-a_position.y/u_size.y)*2.0,a_position.z,1.0);\r\n        #endif\r\n    }\r\n\r\n#elif defined(TEXTUREVS)\r\n\t//texture和fillrect使用的。\r\n    // attribute vec4 a_posuv;\r\n    // attribute vec4 a_attribColor;\r\n    // attribute vec4 a_attribFlags;\r\n    #ifdef MVP3D\r\n        uniform mat4 u_MvpMatrix;\r\n    #endif\r\n\r\n    varying vec4 v_texcoordAlpha;\r\n    varying float v_useTex;\r\n\r\n    void getVertexInfo(inout vertexInfo info){\r\n       \t//texcoordAlpha\r\n        info.texcoordAlpha.xy = a_posuv.zw;\r\n        //color\r\n        info.color = a_attribColor;\r\n        info.color.a*=u_VertAlpha;\r\n\t    info.color.xyz*= info.color.w;//反正后面也要预乘\r\n        //useTex\r\n        info.useTex = a_attribFlags.r;\r\n\r\n        //clip\r\n    \tfloat clipw = length(u_clipMatDir.xy);\r\n    \tfloat cliph = length(u_clipMatDir.zw);\r\n\t    vec2 clpos = u_clipMatPos.xy;\r\n        #ifdef WORLDMAT\r\n            vec2 clippos = transedPos.xy - clpos;\r\n        #else\r\n        vec2 clippos = a_posuv.xy - clpos;\t//pos已经应用矩阵了，为了减的有意义，clip的位置也要缩放\r\n        #endif\r\n        if(clipw>20000. && cliph>20000.)\r\n            info.cliped = vec2(0.5,0.5);\r\n        else {\r\n            //转成0到1之间。/clipw/clipw 表示clippos与normalize之后的clip朝向点积之后，再除以clipw\r\n            info.cliped = vec2( dot(clippos,u_clipMatDir.xy)/clipw/clipw, dot(clippos,u_clipMatDir.zw)/cliph/cliph);\r\n        }\r\n    }\r\n\r\n    void getPosition(inout vec4 glPosition){\r\n        vec4 pos = vec4(a_posuv.xy,0.,1.);\r\n        #ifdef WORLDMAT\r\n            pos= u_mmat * pos;\r\n            transedPos=pos;//vec4(pos.x,pos.y,0.0,1.0);\r\n        #endif\r\n        vec4 pos1 = vec4((pos.x/u_size.x-0.5)*2.0,(0.5-pos.y/u_size.y)*2.0,0.,1.0);\r\n        #ifdef MVP3D\r\n            glPosition = u_MvpMatrix * pos1;\r\n        #else\r\n            glPosition = pos1;\r\n        #endif\r\n        \r\n        #ifdef INVERTY\r\n            glPosition.y = -glPosition.y;\r\n        #endif\r\n    }\r\n\r\n#endif";

    class Shader2D {
        destroy() {
        }
        static __init__() {
            Shader3D.addInclude("Sprite2DFrag.glsl", Sprite2DFrag);
            Shader3D.addInclude("Sprite2DVertex.glsl", Sprite2DVertex);
            Shader3D.addInclude("Sprite2DShaderInfo.glsl", Sprite2DShaderInfo);
            Shader2D.textureShader = Shader3D.add("Sprite2DTexture", false, false);
            Shader2D.textureShader.shaderType = exports.ShaderFeatureType.D2;
            let subShader = new SubShader(Shader2D.textureAttribute, {}, {});
            Shader2D.textureShader.addSubShader(subShader);
            subShader.addShaderPass(texture_vs, texture_ps);
            Shader2D.primitiveShader = Shader3D.add("Sprite2DPrimitive", false, false);
            Shader2D.primitiveShader.shaderType = exports.ShaderFeatureType.D2;
            subShader = new SubShader(Shader2D.primitiveAttribute, {}, {});
            Shader2D.primitiveShader.addSubShader(subShader);
            subShader.addShaderPass(prime_vs, prime_ps);
        }
    }
    Shader2D.primitiveAttribute = {
        'a_position': [0, exports.ShaderDataType.Vector4],
        'a_attribColor': [1, exports.ShaderDataType.Vector4],
    };
    Shader2D.textureAttribute = {
        'a_posuv': [0, exports.ShaderDataType.Vector4],
        'a_attribColor': [1, exports.ShaderDataType.Vector4],
        'a_attribFlags': [2, exports.ShaderDataType.Vector4]
    };

    class ShaderDefines2D {
        static __init__() {
            ShaderDefines2D.TEXTURE2D = Shader3D.getDefineByName("TEXTURE2D");
            ShaderDefines2D.PRIMITIVE = Shader3D.getDefineByName("PRIMITIVE");
            ShaderDefines2D.FILTERGLOW = Shader3D.getDefineByName("GLOW_FILTER");
            ShaderDefines2D.FILTERBLUR = Shader3D.getDefineByName("BLUR_FILTER");
            ShaderDefines2D.FILTERCOLOR = Shader3D.getDefineByName("COLOR_FILTER");
            ShaderDefines2D.COLORADD = Shader3D.getDefineByName("COLOR_ADD");
            ShaderDefines2D.WORLDMAT = Shader3D.getDefineByName("WORLDMAT");
            ShaderDefines2D.FILLTEXTURE = Shader3D.getDefineByName("FILLTEXTURE");
            ShaderDefines2D.MVP3D = Shader3D.getDefineByName('MVP3D');
            ShaderDefines2D.GAMMASPACE = Shader3D.getDefineByName('GAMMASPACE');
            ShaderDefines2D.INVERTY = Shader3D.getDefineByName('INVERTY');
            ShaderDefines2D.GAMMATEXTURE = Shader3D.getDefineByName('GAMMATEXTURE');
            ShaderDefines2D.TEXTURESHADER = Shader3D.getDefineByName("TEXTUREVS");
            ShaderDefines2D.PRIMITIVESHADER = Shader3D.getDefineByName("PRIMITIVEMESH");
            ShaderDefines2D.initSprite2DCommandEncoder();
        }
        static initSprite2DCommandEncoder() {
            ShaderDefines2D.UNIFORM_MMAT = Shader3D.propertyNameToID("u_mmat");
            ShaderDefines2D.UNIFORM_CLIPMATDIR = Shader3D.propertyNameToID("u_clipMatDir");
            ShaderDefines2D.UNIFORM_CLIPMATPOS = Shader3D.propertyNameToID("u_clipMatPos");
            ShaderDefines2D.UNIFORM_MMAT2 = Shader3D.propertyNameToID("u_mmat2");
            ShaderDefines2D.UNIFORM_SIZE = Shader3D.propertyNameToID("u_size");
            ShaderDefines2D.UNIFORM_VERTALPHA = Shader3D.propertyNameToID("u_VertAlpha");
            ShaderDefines2D.UNIFORM_MVPMatrix = Shader3D.propertyNameToID("u_MvpMatrix");
            ShaderDefines2D.UNIFORM_SPRITETEXTURE = Shader3D.propertyNameToID("u_spriteTexture");
            ShaderDefines2D.UNIFORM_STRENGTH_SIG2_2SIG2_GAUSS1 = Shader3D.propertyNameToID("u_strength_sig2_2sig2_gauss1");
            ShaderDefines2D.UNIFORM_BLURINFO = Shader3D.propertyNameToID("u_blurInfo");
            ShaderDefines2D.UNIFORM_COLORALPHA = Shader3D.propertyNameToID("u_colorAlpha");
            ShaderDefines2D.UNIFORM_COLORMAT = Shader3D.propertyNameToID("u_colorMat");
            ShaderDefines2D.UNIFORM_COLOR = Shader3D.propertyNameToID("u_color");
            ShaderDefines2D.UNIFORM_BLURINFO1 = Shader3D.propertyNameToID("u_blurInfo1");
            ShaderDefines2D.UNIFORM_BLURINFO2 = Shader3D.propertyNameToID("u_blurInfo2");
            ShaderDefines2D.UNIFORM_COLORADD = Shader3D.propertyNameToID("u_colorAdd");
            ShaderDefines2D.UNIFORM_TEXRANGE = Shader3D.propertyNameToID("u_TexRange");
            const commandUniform = LayaGL.renderDeviceFactory.createGlobalUniformMap("Sprite2D");
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_MMAT, "u_mmat", exports.ShaderDataType.Matrix4x4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_CLIPMATDIR, "u_clipMatDir", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_CLIPMATPOS, "u_clipMatPos", exports.ShaderDataType.Vector2);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_MMAT2, "u_mmat2", exports.ShaderDataType.Matrix4x4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_SIZE, "u_size", exports.ShaderDataType.Vector2);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_VERTALPHA, "u_VertAlpha", exports.ShaderDataType.Float);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_MVPMatrix, "u_MvpMatrix", exports.ShaderDataType.Matrix4x4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_SPRITETEXTURE, "u_spriteTexture", exports.ShaderDataType.Texture2D);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_STRENGTH_SIG2_2SIG2_GAUSS1, "u_strength_sig2_2sig2_gauss1", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_BLURINFO, "u_blurInfo", exports.ShaderDataType.Vector2);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_COLORALPHA, "u_colorAlpha", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_COLORMAT, "u_colorMat", exports.ShaderDataType.Matrix4x4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_COLOR, "u_color", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_BLURINFO1, "u_blurInfo1", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_BLURINFO2, "u_blurInfo2", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_COLORADD, "u_colorAdd", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_TEXRANGE, "u_TexRange", exports.ShaderDataType.Vector4);
        }
    }

    exports.RenderSpriteData = void 0;
    (function (RenderSpriteData) {
        RenderSpriteData[RenderSpriteData["Zero"] = 0] = "Zero";
        RenderSpriteData[RenderSpriteData["Texture2D"] = 1] = "Texture2D";
        RenderSpriteData[RenderSpriteData["Primitive"] = 2] = "Primitive";
    })(exports.RenderSpriteData || (exports.RenderSpriteData = {}));
    class Value2D {
        constructor(mainID) {
            this._needRelease = false;
            this.mainID = exports.RenderSpriteData.Zero;
            this.ref = 1;
            this._cacheID = 0;
            this.mainID = mainID;
            Value2D.prototype.initialize.call(this);
        }
        initialize() {
            let mainID = this.mainID;
            this.shaderData = this.shaderData || LayaGL.renderDeviceFactory.createShaderData(null);
            if (this.mainID == exports.RenderSpriteData.Texture2D) {
                this.shaderData.addDefine(ShaderDefines2D.TEXTURESHADER);
            }
            if (this.mainID == exports.RenderSpriteData.Primitive) {
                this.shaderData.addDefine(ShaderDefines2D.PRIMITIVESHADER);
            }
            this.textureHost = null;
            this.clipMatDir = new Vector4(Const.MAX_CLIP_SIZE, 0, 0, Const.MAX_CLIP_SIZE);
            this.clipMatPos = new Vector2();
            this._cacheID = mainID;
            let cache = Value2D._cache[this._cacheID];
            if (mainID > 0 && !cache) {
                cache = Value2D._cache[this._cacheID] = [];
                cache._length = 0;
            }
            this.shaderData.setBool(Shader3D.DEPTH_WRITE, false);
            this.shaderData.setInt(Shader3D.DEPTH_TEST, RenderState.DEPTHTEST_OFF);
            this.shaderData.setInt(Shader3D.BLEND, RenderState.BLEND_ENABLE_ALL);
            this.shaderData.setInt(Shader3D.BLEND_EQUATION, RenderState.BLENDEQUATION_ADD);
            this.shaderData.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ONE);
            this.shaderData.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
            this.shaderData.setNumber(ShaderDefines2D.UNIFORM_VERTALPHA, 1.0);
            this.shaderData.setInt(Shader3D.CULL, RenderState.CULL_NONE);
        }
        reinit() {
            this.initialize();
        }
        static _initone(type, classT) {
            Value2D._compileDefine = LayaGL.unitRenderModuleDataFactory.createDefineDatas();
            Value2D._typeClass[type] = classT;
            Value2D._cache[type] = [];
            Value2D._cache[type]._length = 0;
        }
        static create(mainType) {
            var types = Value2D._cache[mainType] ? Value2D._cache[mainType] : [];
            if (types._length) {
                let sv = types[--types._length];
                sv.reinit();
                return sv;
            }
            else
                return new Value2D._typeClass[mainType]();
        }
        set size(value) {
            this.shaderData.setVector2(ShaderDefines2D.UNIFORM_SIZE, value);
        }
        get size() {
            return this.shaderData.getVector2(ShaderDefines2D.UNIFORM_SIZE);
        }
        set vertAlpha(value) {
            this.shaderData.setNumber(ShaderDefines2D.UNIFORM_VERTALPHA, value);
        }
        get vertAlpha() {
            return this.shaderData.getNumber(ShaderDefines2D.UNIFORM_VERTALPHA);
        }
        set mmat(value) {
            this.shaderData.setMatrix4x4(ShaderDefines2D.UNIFORM_MMAT, value);
        }
        get mmat() {
            return this.shaderData.getMatrix4x4(ShaderDefines2D.UNIFORM_MMAT);
        }
        set u_MvpMatrix(value) {
            this.shaderData.setMatrix4x4(ShaderDefines2D.UNIFORM_MVPMatrix, value);
        }
        get u_MvpMatrix() {
            return this.shaderData.getMatrix4x4(ShaderDefines2D.UNIFORM_MVPMatrix);
        }
        get textureHost() {
            return this._textureHost;
        }
        set textureHost(value) {
            this._textureHost = value;
            let textrueReadGamma = false;
            if (this.textureHost) {
                if (this.textureHost instanceof BaseTexture) {
                    textrueReadGamma = this.textureHost.gammaCorrection != 1;
                }
                else if (this.textureHost instanceof Texture && this.textureHost.bitmap) {
                    textrueReadGamma = this.textureHost.bitmap.gammaCorrection != 1;
                }
            }
            if (textrueReadGamma) {
                this.shaderData.addDefine(ShaderDefines2D.GAMMATEXTURE);
            }
            else {
                this.shaderData.removeDefine(ShaderDefines2D.GAMMATEXTURE);
            }
            let tex;
            if (value instanceof Texture) {
                tex = value.bitmap;
            }
            else {
                tex = value;
            }
            this.shaderData.setTexture(ShaderDefines2D.UNIFORM_SPRITETEXTURE, tex);
        }
        set color(value) {
            value && this.shaderData.setVector(ShaderDefines2D.UNIFORM_COLOR, value);
        }
        get color() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_COLOR);
        }
        set colorAdd(value) {
            this.shaderData.setVector(ShaderDefines2D.UNIFORM_COLORADD, value);
        }
        get colorAdd() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_COLORADD);
        }
        set clipMatDir(value) {
            this.shaderData.setVector(ShaderDefines2D.UNIFORM_CLIPMATDIR, value);
        }
        get clipMatDir() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_CLIPMATDIR);
        }
        set clipMatPos(value) {
            this.shaderData.setVector2(ShaderDefines2D.UNIFORM_CLIPMATPOS, value);
        }
        get clipMatPos() {
            return this.shaderData.getVector2(ShaderDefines2D.UNIFORM_CLIPMATPOS);
        }
        upload(material, shaderData) {
        }
        setFilter(value) {
            if (!value)
                return;
            this.shaderData.addDefine(value.typeDefine);
        }
        clear() {
            if (this.shaderData) {
                this.shaderData.clearDefine();
            }
            this.textureHost = null;
        }
        blendNormal() {
            this.shaderData.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_SRC_ALPHA);
            this.shaderData.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
        }
        blendPremulAlpha() {
            this.shaderData.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ONE);
            this.shaderData.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
        }
        blendAdd() {
            this.shaderData.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ONE);
            this.shaderData.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE);
        }
        blendMask() {
            this.shaderData.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ZERO);
            this.shaderData.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_SRC_ALPHA);
        }
        release() {
            if ((--this.ref) < 1) {
                let cache = Value2D._cache[this._cacheID];
                cache && (cache[cache._length++] = this);
                this.clear();
                this.filters = null;
                this.ref = 1;
            }
        }
    }
    Value2D._cache = [];
    Value2D._typeClass = [];
    class Value2DManager {
    }

    const minAngle = 15 * Math.PI / 180;
    const precision = 1e-13;
    const tempData = new Array(256);
    const tempIndexs = new Array(4);
    const vec2 = new Vector2();
    class BasePoly {
        static _checkMinAngle(p1x, p1y, p2x, p2y, p3x, p3y) {
            const v1x = p2x - p1x;
            const v1y = p2y - p1y;
            const v2x = p3x - p2x;
            const v2y = p3y - p2y;
            const dot = v1x * v2x + v1y * v2y;
            const len1 = Math.sqrt(v1x * v1x + v1y * v1y);
            const len2 = Math.sqrt(v2x * v2x + v2y * v2y);
            const cosAngle = dot / (len1 * len2);
            const angle = Math.acos(Math.abs(cosAngle));
            return Math.abs(angle) < minAngle;
        }
        static createLine2(p, indices, lineWidth, indexBase, outVertex, loop) {
            if (p.length < 4)
                return null;
            let offset = indexBase;
            var points = tempData.length > (p.length + 2) ? tempData : new Array(p.length + 2);
            points[0] = p[0];
            points[1] = p[1];
            var newlen = 2;
            var i = 0;
            var length = p.length;
            for (i = 2; i < length; i += 2) {
                if (Math.abs(p[i] - p[i - 2]) + Math.abs(p[i + 1] - p[i - 1]) > 0.01) {
                    points[newlen++] = p[i];
                    points[newlen++] = p[i + 1];
                }
            }
            let delta = Math.abs(p[0] - points[newlen - 2]) + Math.abs(p[1] - points[newlen - 1]);
            if (loop && delta > 0) {
                if (delta > precision) {
                    points[newlen++] = p[0];
                    points[newlen++] = p[1];
                }
                else {
                    points[newlen - 2] = p[0];
                    points[newlen - 1] = p[1];
                }
            }
            var result = outVertex;
            length = newlen / 2;
            var w = lineWidth / 2;
            var p1x, p1y, p2x, p2y, p3x, p3y;
            p1x = points[0];
            p1y = points[1];
            p2x = points[2];
            p2y = points[3];
            this.getNormal(p1x, p1y, p2x, p2y, w, vec2);
            result.push(p1x - vec2.x, p1y - vec2.y, p1x + vec2.x, p1y + vec2.y);
            for (i = 1; i < length - 1; i++) {
                p1x = points[(i - 1) * 2];
                p1y = points[(i - 1) * 2 + 1];
                p2x = points[(i) * 2];
                p2y = points[(i) * 2 + 1];
                p3x = points[(i + 1) * 2];
                p3y = points[(i + 1) * 2 + 1];
                indices.push(indexBase + 0, indexBase + 1, indexBase + 3, indexBase + 3, indexBase + 2, indexBase + 0);
                indexBase += 2;
                indexBase += this._setMiddleVertexs(p1x, p1y, p2x, p2y, p3x, p3y, w, result, vec2, indices, indexBase);
            }
            p1x = points[newlen - 4];
            p1y = points[newlen - 3];
            p2x = points[newlen - 2];
            p2y = points[newlen - 1];
            this.getNormal(p1x, p1y, p2x, p2y, w, vec2);
            result.push(p2x - vec2.x, p2y - vec2.y, p2x + vec2.x, p2y + vec2.y);
            indices.push(indexBase + 0, indexBase + 1, indexBase + 3, indexBase + 3, indexBase + 2, indexBase + 0);
            if (p2x == points[0] && p2y == points[1]) {
                p3x = points[2];
                p3y = points[3];
                let last = result.length / 2;
                indexBase += 4;
                tempIndexs[0] = offset + last - 2;
                tempIndexs[1] = offset + last - 1;
                tempIndexs[2] = offset;
                tempIndexs[3] = offset + 1;
                this._setMiddleVertexs(p1x, p1y, p2x, p2y, p3x, p3y, w, result, vec2, indices, indexBase, tempIndexs);
            }
            return result;
        }
        static _setMiddleVertexs(x1, y1, x2, y2, x3, y3, w, vertexs, out, indices, indexBase, edgeIndexArray = null) {
            this.getNormal(x1, y1, x2, y2, w, out);
            let perpx = out.x;
            let perpy = out.y;
            this.getNormal(x2, y2, x3, y3, w, out);
            let perp2x = out.x;
            let perp2y = out.y;
            if (this._checkMinAngle(x1, y1, x2, y2, x3, y3)) {
                if (!edgeIndexArray) {
                    vertexs.push(x2 - perpx, y2 - perpy, x2 + perpx, y2 + perpy);
                    vertexs.push(x2 - perp2x, y2 - perp2y, x2 + perp2x, y2 + perp2y);
                    indices.push(indexBase + 0, indexBase + 1, indexBase + 3, indexBase + 3, indexBase + 2, indexBase + 0);
                }
                else {
                    indices.push(edgeIndexArray[0], edgeIndexArray[1], edgeIndexArray[3], edgeIndexArray[3], edgeIndexArray[2], edgeIndexArray[0]);
                }
                return 2;
            }
            let a1 = (-perpy + y1) - (-perpy + y2);
            let b1 = (-perpx + x2) - (-perpx + x1);
            let c1 = (-perpx + x1) * (-perpy + y2) - (-perpx + x2) * (-perpy + y1);
            let a2 = (-perp2y + y3) - (-perp2y + y2);
            let b2 = (-perp2x + x2) - (-perp2x + x3);
            let c2 = (-perp2x + x3) * (-perp2y + y2) - (-perp2x + x2) * (-perp2y + y3);
            let denom = a1 * b2 - a2 * b1;
            denom = a1 * b2 - a2 * b1;
            if (Math.abs(denom) < 0.1) {
                denom += 10.1;
                vertexs.push(x2 - perpx, y2 - perpy, x2 + perpx, y2 + perpy);
                return 0;
            }
            let px = (b1 * c2 - b2 * c1) / denom;
            let py = (a2 * c1 - a1 * c2) / denom;
            if (!edgeIndexArray) {
                vertexs.push(x2 - perpx, y2 - perpy, x2 + perpx, y2 + perpy);
                if (denom > 0) {
                    vertexs.push(px, py, x2, y2);
                    indices.push(indexBase + 0, indexBase + 2, indexBase + 4);
                    indices.push(indexBase + 4, indexBase + 3, indexBase + 0);
                }
                else {
                    vertexs.push(x2 - (px - x2), y2 - (py - y2), x2, y2);
                    indices.push(indexBase + 1, indexBase + 2, indexBase + 5);
                    indices.push(indexBase + 5, indexBase + 3, indexBase + 1);
                }
                vertexs.push(x2 - perp2x, y2 - perp2y, x2 + perp2x, y2 + perp2y);
            }
            else {
                if (denom > 0) {
                    vertexs.push(px, py, x2, y2);
                    indices.push(edgeIndexArray[0], indexBase + 0, edgeIndexArray[2]);
                    indices.push(edgeIndexArray[2], indexBase + 1, edgeIndexArray[0]);
                }
                else {
                    vertexs.push(x2 - (px - x2), y2 - (py - y2), x2, y2);
                    indices.push(edgeIndexArray[1], indexBase + 0, edgeIndexArray[3]);
                    indices.push(edgeIndexArray[3], indexBase + 1, edgeIndexArray[1]);
                }
            }
            return 4;
        }
        static getNormal(x1, y1, x2, y2, w, out) {
            if (!out) {
                out = new Vector2();
            }
            let perpx = y2 - y1;
            let perpy = x1 - x2;
            let dist = Math.sqrt(perpx * perpx + perpy * perpy);
            out.x = perpx / dist * w;
            out.y = perpy / dist * w;
            return out;
        }
        static createLineTriangle(path, color, width, loop, outvb, vbstride, outib) {
            var points = path.slice();
            var ptlen = points.length;
            var p1x = points[0], p1y = points[1];
            var p2x = points[2], p2y = points[2];
            var len = 0;
            var rp = 0;
            var dx = 0, dy = 0;
            var pointnum = ptlen / 2;
            if (pointnum <= 1)
                return;
            if (pointnum == 2) {
                return;
            }
            var tmpData = new Array(pointnum * 4);
            var realPtNum = 0;
            var ci = 0;
            for (var i = 0; i < pointnum - 1; i++) {
                p1x = points[ci++], p1y = points[ci++];
                p2x = points[ci++], p2y = points[ci++];
                dx = p2x - p1x, dy = p2y - p1y;
                if (dx != 0 && dy != 0) {
                    len = Math.sqrt(dx * dx + dy * dy);
                    if (len > 1e-3) {
                        rp = realPtNum * 4;
                        tmpData[rp] = p1x;
                        tmpData[rp + 1] = p1y;
                        tmpData[rp + 2] = dx / len;
                        tmpData[rp + 3] = dy / len;
                        realPtNum++;
                    }
                }
            }
            if (loop) {
                p1x = points[ptlen - 2], p1y = points[ptlen - 1];
                p2x = points[0], p2y = points[1];
                dx = p2x - p1x, dy = p2y - p1y;
                if (dx != 0 && dy != 0) {
                    len = Math.sqrt(dx * dx + dy * dy);
                    if (len > 1e-3) {
                        rp = realPtNum * 4;
                        tmpData[rp] = p1x;
                        tmpData[rp + 1] = p1y;
                        tmpData[rp + 2] = dx / len;
                        tmpData[rp + 3] = dy / len;
                        realPtNum++;
                    }
                }
            }
            else {
                rp = realPtNum * 4;
                tmpData[rp] = p1x;
                tmpData[rp + 1] = p1y;
                tmpData[rp + 2] = dx / len;
                tmpData[rp + 3] = dy / len;
                realPtNum++;
            }
            ci = 0;
            for (i = 0; i < pointnum; i++) {
                p1x = points[ci], p1y = points[ci + 1];
                p2x = points[ci + 2], p2y = points[ci + 3];
            }
        }
    }

    class EarcutNode {
        constructor(i, x, y) {
            this.i = i;
            this.x = x;
            this.y = y;
            this.prev = null;
            this.next = null;
            this.z = null;
            this.prevZ = null;
            this.nextZ = null;
            this.steiner = false;
        }
    }

    class Earcut {
        static earcut(data, holeIndices, dim) {
            dim = dim || 2;
            var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = Earcut.linkedList(data, 0, outerLen, dim, true), triangles = [];
            if (!outerNode)
                return triangles;
            var minX, minY, maxX, maxY, x, y, invSize;
            if (hasHoles)
                outerNode = Earcut.eliminateHoles(data, holeIndices, outerNode, dim);
            if (data.length > 80 * dim) {
                minX = maxX = data[0];
                minY = maxY = data[1];
                for (var i = dim; i < outerLen; i += dim) {
                    x = data[i];
                    y = data[i + 1];
                    if (x < minX)
                        minX = x;
                    if (y < minY)
                        minY = y;
                    if (x > maxX)
                        maxX = x;
                    if (y > maxY)
                        maxY = y;
                }
                invSize = Math.max(maxX - minX, maxY - minY);
                invSize = invSize !== 0 ? 1 / invSize : 0;
            }
            Earcut.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
            return triangles;
        }
        static linkedList(data, start, end, dim, clockwise) {
            var i, last;
            if (clockwise === (Earcut.signedArea(data, start, end, dim) > 0)) {
                for (i = start; i < end; i += dim)
                    last = Earcut.insertNode(i, data[i], data[i + 1], last);
            }
            else {
                for (i = end - dim; i >= start; i -= dim)
                    last = Earcut.insertNode(i, data[i], data[i + 1], last);
            }
            if (last && Earcut.equals(last, last.next)) {
                Earcut.removeNode(last);
                last = last.next;
            }
            return last;
        }
        static filterPoints(start, end) {
            if (!start)
                return start;
            if (!end)
                end = start;
            var p = start, again;
            do {
                again = false;
                if (!p.steiner && (Earcut.equals(p, p.next) || Earcut.area(p.prev, p, p.next) === 0)) {
                    Earcut.removeNode(p);
                    p = end = p.prev;
                    if (p === p.next)
                        break;
                    again = true;
                }
                else {
                    p = p.next;
                }
            } while (again || p !== end);
            return end;
        }
        static earcutLinked(ear, triangles, dim, minX, minY, invSize, pass = null) {
            if (!ear)
                return;
            if (!pass && invSize)
                Earcut.indexCurve(ear, minX, minY, invSize);
            var stop = ear, prev, next;
            while (ear.prev !== ear.next) {
                prev = ear.prev;
                next = ear.next;
                if (invSize ? Earcut.isEarHashed(ear, minX, minY, invSize) : Earcut.isEar(ear)) {
                    triangles.push(prev.i / dim);
                    triangles.push(ear.i / dim);
                    triangles.push(next.i / dim);
                    Earcut.removeNode(ear);
                    ear = next.next;
                    stop = next.next;
                    continue;
                }
                ear = next;
                if (ear === stop) {
                    if (!pass) {
                        Earcut.earcutLinked(Earcut.filterPoints(ear, null), triangles, dim, minX, minY, invSize, 1);
                    }
                    else if (pass === 1) {
                        ear = Earcut.cureLocalIntersections(ear, triangles, dim);
                        Earcut.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                    }
                    else if (pass === 2) {
                        Earcut.splitEarcut(ear, triangles, dim, minX, minY, invSize);
                    }
                    break;
                }
            }
        }
        static isEar(ear) {
            var a = ear.prev, b = ear, c = ear.next;
            if (Earcut.area(a, b, c) >= 0)
                return false;
            var p = ear.next.next;
            while (p !== ear.prev) {
                if (Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                    Earcut.area(p.prev, p, p.next) >= 0)
                    return false;
                p = p.next;
            }
            return true;
        }
        static isEarHashed(ear, minX, minY, invSize) {
            var a = ear.prev, b = ear, c = ear.next;
            if (Earcut.area(a, b, c) >= 0)
                return false;
            var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
            var minZ = Earcut.zOrder(minTX, minTY, minX, minY, invSize), maxZ = Earcut.zOrder(maxTX, maxTY, minX, minY, invSize);
            var p = ear.nextZ;
            while (p && p.z <= maxZ) {
                if (p !== ear.prev && p !== ear.next &&
                    Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                    Earcut.area(p.prev, p, p.next) >= 0)
                    return false;
                p = p.nextZ;
            }
            p = ear.prevZ;
            while (p && p.z >= minZ) {
                if (p !== ear.prev && p !== ear.next &&
                    Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                    Earcut.area(p.prev, p, p.next) >= 0)
                    return false;
                p = p.prevZ;
            }
            return true;
        }
        static cureLocalIntersections(start, triangles, dim) {
            var p = start;
            do {
                var a = p.prev, b = p.next.next;
                if (!Earcut.equals(a, b) && Earcut.intersects(a, p, p.next, b) && Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a)) {
                    triangles.push(a.i / dim);
                    triangles.push(p.i / dim);
                    triangles.push(b.i / dim);
                    Earcut.removeNode(p);
                    Earcut.removeNode(p.next);
                    p = start = b;
                }
                p = p.next;
            } while (p !== start);
            return p;
        }
        static splitEarcut(start, triangles, dim, minX, minY, invSize) {
            var a = start;
            do {
                var b = a.next.next;
                while (b !== a.prev) {
                    if (a.i !== b.i && Earcut.isValidDiagonal(a, b)) {
                        var c = Earcut.splitPolygon(a, b);
                        a = Earcut.filterPoints(a, a.next);
                        c = Earcut.filterPoints(c, c.next);
                        Earcut.earcutLinked(a, triangles, dim, minX, minY, invSize);
                        Earcut.earcutLinked(c, triangles, dim, minX, minY, invSize);
                        return;
                    }
                    b = b.next;
                }
                a = a.next;
            } while (a !== start);
        }
        static eliminateHoles(data, holeIndices, outerNode, dim) {
            var queue = [], i, len, start, end, list;
            for (i = 0, len = holeIndices.length; i < len; i++) {
                start = holeIndices[i] * dim;
                end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                list = Earcut.linkedList(data, start, end, dim, false);
                if (list === list.next)
                    list.steiner = true;
                queue.push(Earcut.getLeftmost(list));
            }
            queue.sort(Earcut.compareX);
            for (i = 0; i < queue.length; i++) {
                Earcut.eliminateHole(queue[i], outerNode);
                outerNode = Earcut.filterPoints(outerNode, outerNode.next);
            }
            return outerNode;
        }
        static compareX(a, b) {
            return a.x - b.x;
        }
        static eliminateHole(hole, outerNode) {
            outerNode = Earcut.findHoleBridge(hole, outerNode);
            if (outerNode) {
                var b = Earcut.splitPolygon(outerNode, hole);
                Earcut.filterPoints(b, b.next);
            }
        }
        static findHoleBridge(hole, outerNode) {
            var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
            do {
                if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                    var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                    if (x <= hx && x > qx) {
                        qx = x;
                        if (x === hx) {
                            if (hy === p.y)
                                return p;
                            if (hy === p.next.y)
                                return p.next;
                        }
                        m = p.x < p.next.x ? p : p.next;
                    }
                }
                p = p.next;
            } while (p !== outerNode);
            if (!m)
                return null;
            if (hx === qx)
                return m.prev;
            var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
            p = m.next;
            while (p !== stop) {
                if (hx >= p.x && p.x >= mx && hx !== p.x &&
                    Earcut.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                    tan = Math.abs(hy - p.y) / (hx - p.x);
                    if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && Earcut.locallyInside(p, hole)) {
                        m = p;
                        tanMin = tan;
                    }
                }
                p = p.next;
            }
            return m;
        }
        static indexCurve(start, minX, minY, invSize) {
            var p = start;
            do {
                if (p.z === null)
                    p.z = Earcut.zOrder(p.x, p.y, minX, minY, invSize);
                p.prevZ = p.prev;
                p.nextZ = p.next;
                p = p.next;
            } while (p !== start);
            p.prevZ.nextZ = null;
            p.prevZ = null;
            Earcut.sortLinked(p);
        }
        static sortLinked(list) {
            var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
            do {
                p = list;
                list = null;
                tail = null;
                numMerges = 0;
                while (p) {
                    numMerges++;
                    q = p;
                    pSize = 0;
                    for (i = 0; i < inSize; i++) {
                        pSize++;
                        q = q.nextZ;
                        if (!q)
                            break;
                    }
                    qSize = inSize;
                    while (pSize > 0 || (qSize > 0 && q)) {
                        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                            e = p;
                            p = p.nextZ;
                            pSize--;
                        }
                        else {
                            e = q;
                            q = q.nextZ;
                            qSize--;
                        }
                        if (tail)
                            tail.nextZ = e;
                        else
                            list = e;
                        e.prevZ = tail;
                        tail = e;
                    }
                    p = q;
                }
                tail.nextZ = null;
                inSize *= 2;
            } while (numMerges > 1);
            return list;
        }
        static zOrder(x, y, minX, minY, invSize) {
            x = 32767 * (x - minX) * invSize;
            y = 32767 * (y - minY) * invSize;
            x = (x | (x << 8)) & 0x00FF00FF;
            x = (x | (x << 4)) & 0x0F0F0F0F;
            x = (x | (x << 2)) & 0x33333333;
            x = (x | (x << 1)) & 0x55555555;
            y = (y | (y << 8)) & 0x00FF00FF;
            y = (y | (y << 4)) & 0x0F0F0F0F;
            y = (y | (y << 2)) & 0x33333333;
            y = (y | (y << 1)) & 0x55555555;
            return x | (y << 1);
        }
        static getLeftmost(start) {
            var p = start, leftmost = start;
            do {
                if (p.x < leftmost.x)
                    leftmost = p;
                p = p.next;
            } while (p !== start);
            return leftmost;
        }
        static pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
            return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
                (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
                (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
        }
        static isValidDiagonal(a, b) {
            return a.next.i !== b.i && a.prev.i !== b.i && !Earcut.intersectsPolygon(a, b) &&
                Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a) && Earcut.middleInside(a, b);
        }
        static area(p, q, r) {
            return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
        }
        static equals(p1, p2) {
            return p1.x === p2.x && p1.y === p2.y;
        }
        static intersects(p1, q1, p2, q2) {
            if ((Earcut.equals(p1, q1) && Earcut.equals(p2, q2)) ||
                (Earcut.equals(p1, q2) && Earcut.equals(p2, q1)))
                return true;
            return Earcut.area(p1, q1, p2) > 0 !== Earcut.area(p1, q1, q2) > 0 &&
                Earcut.area(p2, q2, p1) > 0 !== Earcut.area(p2, q2, q1) > 0;
        }
        static intersectsPolygon(a, b) {
            var p = a;
            do {
                if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                    Earcut.intersects(p, p.next, a, b))
                    return true;
                p = p.next;
            } while (p !== a);
            return false;
        }
        static locallyInside(a, b) {
            return Earcut.area(a.prev, a, a.next) < 0 ?
                Earcut.area(a, b, a.next) >= 0 && Earcut.area(a, a.prev, b) >= 0 :
                Earcut.area(a, b, a.prev) < 0 || Earcut.area(a, a.next, b) < 0;
        }
        static middleInside(a, b) {
            var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
            do {
                if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                    (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                    inside = !inside;
                p = p.next;
            } while (p !== a);
            return inside;
        }
        static splitPolygon(a, b) {
            var a2 = new EarcutNode(a.i, a.x, a.y), b2 = new EarcutNode(b.i, b.x, b.y), an = a.next, bp = b.prev;
            a.next = b;
            b.prev = a;
            a2.next = an;
            an.prev = a2;
            b2.next = a2;
            a2.prev = b2;
            bp.next = b2;
            b2.prev = bp;
            return b2;
        }
        static insertNode(i, x, y, last) {
            var p = new EarcutNode(i, x, y);
            if (!last) {
                p.prev = p;
                p.next = p;
            }
            else {
                p.next = last.next;
                p.prev = last;
                last.next.prev = p;
                last.next = p;
            }
            return p;
        }
        static removeNode(p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            if (p.prevZ)
                p.prevZ.nextZ = p.nextZ;
            if (p.nextZ)
                p.nextZ.prevZ = p.prevZ;
        }
        static signedArea(data, start, end, dim) {
            var sum = 0;
            for (var i = start, j = end - dim; i < end; i += dim) {
                sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
                j = i;
            }
            return sum;
        }
    }

    class SubmitKey {
        constructor() {
            this.clear();
        }
        clear() {
            this.submitType = -1;
            this.blendShader = this.other = 0;
        }
    }

    class SubmitBase {
        constructor() {
            this.clipInfoID = -1;
            this.blendType = -1;
            this._id = 0;
            this._renderType = 0;
            this._key = new SubmitKey();
            this._startIdx = 0;
            this._numEle = 0;
            this._colorFiler = null;
            this.shaderValue = null;
            this._id = ++SubmitBase.ID;
        }
        static create(context, mesh, sv) {
            var o = new SubmitBase();
            o._mesh = mesh;
            o._key.clear();
            o._key.submitType = SubmitBase.KEY_DRAWTEXTURE;
            o._startIdx = mesh.indexNum * Const.INDEX_BYTES;
            o._numEle = 0;
            var blendType = context._nBlendType;
            o._key.blendShader = blendType;
            o.shaderValue = sv;
            o.material = context._material;
            o._colorFiler = context._colorFiler;
            return o;
        }
    }
    SubmitBase.KEY_ONCE = -1;
    SubmitBase.KEY_FILLRECT = 1;
    SubmitBase.KEY_DRAWTEXTURE = 2;
    SubmitBase.KEY_VG = 3;
    SubmitBase.KEY_TRIANGLES = 4;
    SubmitBase.ID = 1;
    SubmitBase.RENDERBASE = new SubmitBase();

    class RenderInfo {
    }
    RenderInfo.loopStTm = 0;
    RenderInfo.loopCount = 0;

    class CharSubmitCache {
        constructor(ctx) {
            this._data = [];
            this._ndata = 0;
            this._clipid = -1;
            this._clipMatrix = new Matrix();
            this._enable = false;
            this._clipid = ctx._clipInfoID;
            ctx._globalClipMatrix.copyTo(this._clipMatrix);
        }
        clear() {
            this._tex = null;
            this._imgId = -1;
            this._ndata = 0;
            this._enable = false;
            this._colorFiler = null;
        }
        destroy() {
            this.clear();
            this._data.length = 0;
            this._data = null;
        }
        add(ctx, tex, imgid, pos, uv, color) {
            if (this._ndata > 0 && (this._tex != tex || this._imgId != imgid ||
                (this._clipid >= 0 && this._clipid != ctx._clipInfoID))) {
                this.submit(ctx);
            }
            this._clipid = ctx._clipInfoID;
            ctx._globalClipMatrix.copyTo(this._clipMatrix);
            this._tex = tex;
            this._imgId = imgid;
            this._colorFiler = ctx._colorFiler;
            this._data[this._ndata] = pos;
            this._data[this._ndata + 1] = uv;
            this._data[this._ndata + 2] = color;
            this._ndata += 3;
        }
        getPos() {
            if (CharSubmitCache.__nPosPool == 0)
                return new Array(8);
            return CharSubmitCache.__posPool[--CharSubmitCache.__nPosPool];
        }
        enable(value, ctx) {
            if (value === this._enable)
                return;
            this._enable = value;
            this._enable || this.submit(ctx);
        }
        submit(ctx) {
            var n = this._ndata;
            if (!n)
                return;
            ctx.drawLeftData();
            let shaderValue = Value2D.create(exports.RenderSpriteData.Texture2D);
            ctx.fillShaderValue(shaderValue);
            shaderValue.textureHost = this._tex;
            let _mesh = ctx._mesh = ctx._meshQuatTex;
            let submit = ctx._curSubmit = SubmitBase.create(ctx, _mesh, shaderValue);
            submit._key.other = this._imgId;
            submit._colorFiler = this._colorFiler;
            var cm = shaderValue.clipMatDir;
            let clipInfo = this._clipMatrix;
            cm.x = clipInfo.a;
            cm.y = clipInfo.b;
            cm.z = clipInfo.c;
            cm.w = clipInfo.d;
            shaderValue.clipMatDir = cm;
            var cmp = shaderValue.clipMatPos;
            cmp.x = clipInfo.tx;
            cmp.y = clipInfo.ty;
            shaderValue.clipMatPos = cmp;
            submit.clipInfoID = this._clipid;
            for (var i = 0; i < n; i += 3) {
                _mesh.addQuad(this._data[i], this._data[i + 1], this._data[i + 2], true);
                CharSubmitCache.__posPool[CharSubmitCache.__nPosPool++] = this._data[i];
            }
            this._ndata = 0;
            if (RenderInfo.loopCount % 100 == 0)
                this._data.length = 0;
            ctx.drawLeftData();
        }
    }
    CharSubmitCache.__posPool = [];
    CharSubmitCache.__nPosPool = 0;

    class CharRenderInfo {
        constructor() {
            this.isRandomTouch = true;
            this.char = '';
            this.deleted = false;
            this.uv = new Array(8);
            this.pos = 0;
            this.orix = 0;
            this.oriy = 0;
            this.touchTick = 0;
            this.isSpace = false;
        }
        touch() {
            var curLoop = RenderInfo.loopCount;
            if (this.touchTick != curLoop) {
                this.texture.touchRect(this, curLoop);
                this.touchTick = curLoop;
            }
        }
    }

    var pixelBBX = [0, 0, 0, 0];
    const tmpRI = new CharRenderInfo();
    class MeasureFont {
        constructor(charRender) {
            this.charRender = charRender;
        }
        getFontSizeInfo(font, size) {
            let fontstr = 'bold ' + size + 'px ' + font;
            pixelBBX[0] = size / 2;
            pixelBBX[1] = size / 2;
            pixelBBX[2] = size;
            pixelBBX[3] = size;
            var orix = 16;
            var oriy = 16;
            var marginr = 16;
            var marginb = 16;
            this.charRender.scale(1, 1);
            tmpRI.height = size;
            this.charRender.fontsz = size;
            var bmpdt = this.charRender.getCharBmp('g', fontstr, 0, 'red', null, tmpRI, orix, oriy, marginr, marginb);
            this.bmpData32 = new Uint32Array(bmpdt.data.buffer);
            this.updateBbx(bmpdt, pixelBBX, false);
            bmpdt = this.charRender.getCharBmp('有', fontstr, 0, 'red', null, tmpRI, oriy, oriy, marginr, marginb);
            this.bmpData32 = new Uint32Array(bmpdt.data.buffer);
            if (pixelBBX[2] < orix + tmpRI.width)
                pixelBBX[2] = orix + tmpRI.width;
            this.updateBbx(bmpdt, pixelBBX, false);
            var xoff = Math.max(orix - pixelBBX[0], 0);
            var yoff = Math.max(oriy - pixelBBX[1], 0);
            var bbxw = pixelBBX[2] - pixelBBX[0];
            var bbxh = pixelBBX[3] - pixelBBX[1];
            var sizeinfo = xoff << 24 | yoff << 16 | bbxw << 8 | bbxh;
            return sizeinfo;
        }
        checkBmpLine(data, l, sx, ex) {
            if (this.bmpData32.buffer != data.data.buffer) {
                this.bmpData32 = new Uint32Array(data.data.buffer);
            }
            var stpos = data.width * l + sx;
            for (var x = sx; x < ex; x++) {
                if (this.bmpData32[stpos++] != 0)
                    return true;
            }
            return false;
        }
        updateBbx(data, curbbx, onlyH = false) {
            var w = data.width;
            var h = data.height;
            var x = 0;
            var sy = curbbx[1];
            var ey = 0;
            var y = sy;
            if (this.checkBmpLine(data, sy, 0, w)) {
                while (true) {
                    y = (sy + ey) / 2 | 0;
                    if (y + 1 >= sy) {
                        curbbx[1] = y;
                        break;
                    }
                    if (this.checkBmpLine(data, y, 0, w)) {
                        sy = y;
                    }
                    else {
                        ey = y;
                    }
                }
            }
            if (curbbx[3] > h)
                curbbx[3] = h;
            else {
                y = sy = curbbx[3];
                ey = h;
                if (this.checkBmpLine(data, sy, 0, w)) {
                    while (true) {
                        y = (sy + ey) / 2 | 0;
                        if (y - 1 <= sy) {
                            curbbx[3] = y;
                            break;
                        }
                        if (this.checkBmpLine(data, y, 0, w)) {
                            sy = y;
                        }
                        else {
                            ey = y;
                        }
                    }
                }
            }
            if (onlyH)
                return;
            var minx = curbbx[0];
            var stpos = w * curbbx[1];
            for (y = curbbx[1]; y < curbbx[3]; y++) {
                for (x = 0; x < minx; x++) {
                    if (this.bmpData32[stpos + x] != 0) {
                        minx = x;
                        break;
                    }
                }
                stpos += w;
            }
            curbbx[0] = minx;
            var maxx = curbbx[2];
            stpos = w * curbbx[1];
            for (y = curbbx[1]; y < curbbx[3]; y++) {
                for (x = maxx; x < w; x++) {
                    if (this.bmpData32[stpos + x] != 0) {
                        maxx = x;
                        break;
                    }
                }
                stpos += w;
            }
            curbbx[2] = maxx;
        }
    }

    class AtlasGrid {
        constructor(width = 0, height = 0, id = 0) {
            this.atlasID = 0;
            this._width = 0;
            this._height = 0;
            this._texCount = 0;
            this._rowInfo = null;
            this._cells = null;
            this._used = 0;
            this._cells = null;
            this._rowInfo = null;
            this.atlasID = id;
            this._init(width, height);
        }
        addRect(type, width, height, pt) {
            if (!this._get(width, height, pt))
                return false;
            this._fill(pt.x, pt.y, width, height, type);
            this._texCount++;
            return true;
        }
        _release() {
            this._cells = null;
            this._rowInfo = null;
        }
        _init(width, height) {
            this._width = width;
            this._height = height;
            this._release();
            if (this._width == 0)
                return false;
            this._cells = new Uint8Array(this._width * this._height * 3);
            this._rowInfo = new Uint8Array(this._height);
            this._used = 0;
            this._clear();
            return true;
        }
        _get(width, height, pt) {
            if (width > this._width || height > this._height) {
                return false;
            }
            var rx = -1;
            var ry = -1;
            var nWidth = this._width;
            var nHeight = this._height;
            var pCellBox = this._cells;
            for (var y = 0; y < nHeight; y++) {
                if (this._rowInfo[y] < width)
                    continue;
                for (var x = 0; x < nWidth;) {
                    var tm = (y * nWidth + x) * 3;
                    if (pCellBox[tm] != 0 || pCellBox[tm + 1] < width || pCellBox[tm + 2] < height) {
                        x += pCellBox[tm + 1];
                        continue;
                    }
                    rx = x;
                    ry = y;
                    for (var xx = 0; xx < width; xx++) {
                        if (pCellBox[3 * xx + tm + 2] < height) {
                            rx = -1;
                            break;
                        }
                    }
                    if (rx < 0) {
                        x += pCellBox[tm + 1];
                        continue;
                    }
                    pt.x = rx;
                    pt.y = ry;
                    return true;
                }
            }
            return false;
        }
        _fill(x, y, w, h, type) {
            var nWidth = this._width;
            var nHeghit = this._height;
            this._check((x + w) <= nWidth && (y + h) <= nHeghit);
            for (var yy = y; yy < (h + y); ++yy) {
                this._check(this._rowInfo[yy] >= w);
                this._rowInfo[yy] -= w;
                for (var xx = 0; xx < w; xx++) {
                    var tm = (x + yy * nWidth + xx) * 3;
                    this._check(this._cells[tm] == 0);
                    this._cells[tm] = type;
                    this._cells[tm + 1] = w;
                    this._cells[tm + 2] = h;
                }
            }
            if (x > 0) {
                for (yy = 0; yy < h; ++yy) {
                    var s = 0;
                    for (xx = x - 1; xx >= 0; --xx, ++s) {
                        if (this._cells[((y + yy) * nWidth + xx) * 3] != 0)
                            break;
                    }
                    for (xx = s; xx > 0; --xx) {
                        this._cells[((y + yy) * nWidth + x - xx) * 3 + 1] = xx;
                        this._check(xx > 0);
                    }
                }
            }
            if (y > 0) {
                for (xx = x; xx < (x + w); ++xx) {
                    s = 0;
                    for (yy = y - 1; yy >= 0; --yy, s++) {
                        if (this._cells[(xx + yy * nWidth) * 3] != 0)
                            break;
                    }
                    for (yy = s; yy > 0; --yy) {
                        this._cells[(xx + (y - yy) * nWidth) * 3 + 2] = yy;
                        this._check(yy > 0);
                    }
                }
            }
            this._used += (w * h) / (this._width * this._height);
        }
        _check(ret) {
            if (ret == false) {
                console.log("xtexMerger 错误啦");
            }
        }
        _clear() {
            this._texCount = 0;
            for (var y = 0; y < this._height; y++) {
                this._rowInfo[y] = this._width;
            }
            for (var i = 0; i < this._height; i++) {
                for (var j = 0; j < this._width; j++) {
                    var tm = (i * this._width + j) * 3;
                    this._cells[tm] = 0;
                    this._cells[tm + 1] = this._width - j;
                    this._cells[tm + 2] = this._width - i;
                }
            }
        }
    }

    exports.WrapMode = void 0;
    (function (WrapMode) {
        WrapMode[WrapMode["Repeat"] = 0] = "Repeat";
        WrapMode[WrapMode["Clamp"] = 1] = "Clamp";
        WrapMode[WrapMode["Mirrored"] = 2] = "Mirrored";
    })(exports.WrapMode || (exports.WrapMode = {}));

    class TextTexture extends Texture2D {
        constructor(textureW = TextRender.atlasWidth, textureH = TextRender.atlasWidth) {
            super(textureW, textureH, exports.TextureFormat.R8G8B8A8, false, false, true, true);
            this._discardTm = 0;
            this.genID = 0;
            this.curUsedCovRate = 0;
            this.curUsedCovRateAtlas = 0;
            this.lastTouchTm = 0;
            this.ri = null;
            this.setPixelsData(null, true, false);
            this.lock = true;
            this.filterMode = exports.FilterMode.Bilinear;
            this.wrapModeU = exports.WrapMode.Clamp;
            this.wrapModeV = exports.WrapMode.Clamp;
            if (TextRender.debugUV) {
                this.fillWhite();
            }
        }
        addChar(data, x, y, uv = null) {
            if (TextRender.isWan1Wan) {
                return this.addCharCanvas(data, x, y, uv);
            }
            var dt = data.data;
            if (data.data instanceof Uint8ClampedArray)
                dt = new Uint8Array(dt.buffer);
            LayaGL.textureContext.setTextureSubPixelsData(this._texture, dt, 0, false, x, y, data.width, data.height, true, false);
            var u0;
            var v0;
            var u1;
            var v1;
            u0 = x / this.width;
            v0 = y / this.height;
            u1 = (x + data.width) / this.width;
            v1 = (y + data.height) / this.height;
            uv = uv || new Array(8);
            uv[0] = u0, uv[1] = v0;
            uv[2] = u1, uv[3] = v0;
            uv[4] = u1, uv[5] = v1;
            uv[6] = u0, uv[7] = v1;
            return uv;
        }
        addCharCanvas(canv, x, y, uv = null) {
            LayaGL.textureContext.setTextureSubImageData(this._texture, canv, x, y, true, false);
            var u0;
            var v0;
            var u1;
            var v1;
            if (LayaEnv.isConch) {
                u0 = x / this.width;
                v0 = y / this.height;
                u1 = (x + canv.width) / this.width;
                v1 = (y + canv.height) / this.height;
            }
            else {
                u0 = (x + 1) / this.width;
                v0 = (y + 1) / this.height;
                u1 = (x + canv.width - 1) / this.width;
                v1 = (y + canv.height - 1) / this.height;
            }
            uv = uv || new Array(8);
            uv[0] = u0, uv[1] = v0;
            uv[2] = u1, uv[3] = v0;
            uv[4] = u1, uv[5] = v1;
            uv[6] = u0, uv[7] = v1;
            return uv;
        }
        fillWhite() {
            var dt = new Uint8Array(this.width * this.height * 4);
            dt.fill(0xff);
            LayaGL.textureContext.setTextureImageData(this._getSource(), dt, true, false);
        }
        discard() {
            ILaya.stage.setGlobalRepaint();
            this.destroy();
            return;
        }
        static getTextTexture(w, h) {
            return new TextTexture(w, h);
        }
        static clean() {
            var curtm = RenderInfo.loopStTm;
            if (TextTexture.cleanTm === 0)
                TextTexture.cleanTm = curtm;
            if (curtm - TextTexture.cleanTm >= TextRender.checkCleanTextureDt) {
                for (let i = 0; i < TextTexture.poolLen; i++) {
                    var p = TextTexture.pool[i];
                    if (curtm - p._discardTm >= TextRender.destroyUnusedTextureDt) {
                        p.destroy();
                        TextTexture.pool[i] = TextTexture.pool[TextTexture.poolLen - 1];
                        TextTexture.poolLen--;
                        i--;
                    }
                }
                TextTexture.cleanTm = curtm;
            }
        }
        touchTexture() {
            let frame = RenderInfo.loopCount;
            if (this.lastTouchTm != frame) {
                this.curUsedCovRate = 0;
                this.curUsedCovRateAtlas = 0;
                this.lastTouchTm = frame;
            }
        }
        touchRect(ri, frame) {
            if (this.lastTouchTm != frame) {
                this.curUsedCovRate = 0;
                this.curUsedCovRateAtlas = 0;
                this.lastTouchTm = frame;
            }
            var texw2 = TextRender.atlasWidth * TextRender.atlasWidth;
            var gridw2 = TextAtlas.atlasGridW * TextAtlas.atlasGridW;
            this.curUsedCovRate += (ri.bmpWidth * ri.bmpHeight) / texw2;
            this.curUsedCovRateAtlas += (Math.ceil(ri.bmpWidth / TextAtlas.atlasGridW) * Math.ceil(ri.bmpHeight / TextAtlas.atlasGridW)) / (texw2 / gridw2);
        }
    }
    TextTexture.pool = new Array(10);
    TextTexture.poolLen = 0;
    TextTexture.cleanTm = 0;
    TextTexture.EVENT_REUSE = 'texture_recycling';

    class TextAtlas {
        constructor() {
            this.texWidth = 1024;
            this.texHeight = 1024;
            this.texture = null;
            this.charMaps = {};
            this.texHeight = this.texWidth = TextRender.atlasWidth;
            this.texture = TextTexture.getTextTexture(this.texWidth, this.texHeight);
            if (this.texWidth / TextAtlas.atlasGridW > 256) {
                TextAtlas.atlasGridW = Math.ceil(this.texWidth / 256);
            }
            this.atlasgrid = new AtlasGrid(this.texWidth / TextAtlas.atlasGridW, this.texHeight / TextAtlas.atlasGridW, this.texture.id);
        }
        setProtecteDist(d) {
        }
        getAEmpty(w, h, pt) {
            var find = this.atlasgrid.addRect(1, Math.ceil(w / TextAtlas.atlasGridW), Math.ceil(h / TextAtlas.atlasGridW), pt);
            if (find) {
                pt.x *= TextAtlas.atlasGridW;
                pt.y *= TextAtlas.atlasGridW;
            }
            return find;
        }
        get usedRate() {
            return this.atlasgrid._used;
        }
        destroy() {
            for (var k in this.charMaps) {
                var ri = this.charMaps[k];
                ri.deleted = true;
            }
            this.texture.discard();
        }
        printDebugInfo() {
        }
    }
    TextAtlas.atlasGridW = 16;

    class FontInfo {
        static parse(font) {
            if (font === _lastFont) {
                return _lastFontInfo;
            }
            let r = FontInfo._cache[font];
            if (!r) {
                r = FontInfo._cache[font] = new FontInfo(font);
            }
            _lastFont = font;
            _lastFontInfo = r;
            return r;
        }
        constructor(font) {
            this._family = "Arial";
            this._size = 14;
            this._italic = false;
            this._bold = false;
            this.setFont(font || "14px Arial");
        }
        setFont(value) {
            this._font = value;
            var words = value.split(' ');
            var l = words.length;
            if (l < 2) {
                if (l == 1) {
                    if (words[0].indexOf('px') > 0) {
                        this._size = parseInt(words[0]);
                    }
                }
                return;
            }
            var szpos = -1;
            for (let i = 0; i < l; i++) {
                if (words[i].indexOf('px') > 0 || words[i].indexOf('pt') > 0) {
                    szpos = i;
                    this._size = parseInt(words[i]);
                    if (this._size <= 0) {
                        console.debug('font parse error:' + value);
                        this._size = 14;
                    }
                    break;
                }
            }
            var fpos = szpos + 1;
            var familys = words[fpos];
            fpos++;
            for (; fpos < l; fpos++) {
                familys += ' ' + words[fpos];
            }
            this._family = (familys.split(','))[0];
            this._italic = words.indexOf('italic') >= 0;
            this._bold = words.indexOf('bold') >= 0;
        }
    }
    FontInfo._cache = {};
    var _lastFont = '';
    var _lastFontInfo;

    class WordText$1 {
        constructor() {
            this.pagecharsCtx = null;
            this.width = -1;
            this.pageChars = [];
            this.scalex = 1;
            this.scaley = 1;
        }
        setText(txt) {
            this.text = txt;
            if (this._nativeObj)
                this._nativeObj._text = txt;
            else
                this.width = -1;
            this.cleanCache();
        }
        toString() {
            return this.text;
        }
        get length() {
            return this.text ? this.text.length : 0;
        }
        cleanCache() {
            if (this._nativeObj) {
                this._nativeObj.cleanCache();
                return;
            }
            let chars = this.pageChars;
            if (chars.length > 0) {
                for (var i in chars) {
                    let p = chars[i];
                    if (!p)
                        continue;
                    let tex = p.tex;
                    let words = p.words;
                    if (words && words.length == 1 && tex && tex.ri) {
                        tex.destroy();
                    }
                }
                this.pageChars = [];
            }
            this.scalex = 1;
            this.scaley = 1;
        }
        get splitRender() {
            return this._splitRender;
        }
        set splitRender(value) {
            this._splitRender = value;
            if (this._nativeObj)
                this._nativeObj.splitRender = value;
        }
    }

    class ICharRender {
        constructor() {
            this.fontsz = 16;
        }
        getWidth(font, str) { return 0; }
        scale(sx, sy) { }
        get canvasWidth() { return 0; }
        set canvasWidth(w) { }
        getCharBmp(char, font, lineWidth, colStr, strokeColStr, size, margin_left, margin_top, margin_right, margin_bottom, rect = null) {
            return null;
        }
    }

    class CharRender_Canvas extends ICharRender {
        constructor(maxw, maxh, scalefont = true, useImageData = true, showdbg = false) {
            super();
            this.ctx = null;
            this.lastScaleX = 1.0;
            this.lastScaleY = 1.0;
            this.maxTexW = 0;
            this.maxTexH = 0;
            this.scaleFontSize = true;
            this.showDbgInfo = false;
            this.supportImageData = true;
            this.maxTexW = maxw;
            this.maxTexH = maxh;
            this.scaleFontSize = scalefont;
            this.supportImageData = useImageData;
            this.showDbgInfo = showdbg;
            if (!CharRender_Canvas.canvas) {
                CharRender_Canvas.canvas = Browser.createElement('canvas');
                CharRender_Canvas.canvas.width = 1024;
                CharRender_Canvas.canvas.height = 512;
                CharRender_Canvas.canvas.style.left = "-10000px";
                CharRender_Canvas.canvas.style.position = "absolute";
                window.document.body.appendChild(CharRender_Canvas.canvas);
                this.ctx = CharRender_Canvas.canvas.getContext('2d', { willReadFrequently: true });
            }
        }
        get canvasWidth() {
            return CharRender_Canvas.canvas.width;
        }
        set canvasWidth(w) {
            if (CharRender_Canvas.canvas.width == w)
                return;
            CharRender_Canvas.canvas.width = w;
            if (w > 2048) {
                console.warn("画文字设置的宽度太大，超过2048了");
            }
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.scale(this.lastScaleX, this.lastScaleY);
        }
        getWidth(font, str) {
            if (!this.ctx)
                return 0;
            if (this.ctx._lastFont != font) {
                this.ctx.font = font;
                this.ctx._lastFont = font;
            }
            return this.ctx.measureText(str).width;
        }
        scale(sx, sy) {
            if (!this.supportImageData) {
                this.lastScaleX = sx;
                this.lastScaleY = sy;
                return;
            }
            if (this.lastScaleX != sx || this.lastScaleY != sy) {
                this.ctx.setTransform(sx, 0, 0, sy, 0, 0);
                this.lastScaleX = sx;
                this.lastScaleY = sy;
            }
        }
        getCharBmp(char, font, lineWidth, colStr, strokeColStr, cri, margin_left, margin_top, margin_right, margin_bottom, rect = null) {
            if (!this.supportImageData)
                return this.getCharCanvas(char, font, lineWidth, colStr, strokeColStr, cri, margin_left, margin_top, margin_right, margin_bottom);
            var ctx = this.ctx;
            var sz = this.fontsz;
            if (ctx.font != font) {
                ctx.font = font;
                ctx._lastFont = font;
            }
            cri.width = ctx.measureText(char).width;
            var w = cri.width * this.lastScaleX;
            var h = cri.height * this.lastScaleY;
            w += (margin_left + margin_right) * this.lastScaleX;
            h += (margin_top + margin_bottom) * this.lastScaleY;
            w = Math.ceil(w);
            h = Math.ceil(h);
            w = Math.min(w, CharRender_Canvas.canvas.width);
            h = Math.min(h, CharRender_Canvas.canvas.height);
            var clearW = w + lineWidth * 2 + 1;
            var clearH = h + lineWidth * 2 + 1;
            if (rect) {
                clearW = Math.max(clearW, rect[0] + rect[2] + 1);
                clearH = Math.max(clearH, rect[1] + rect[3] + 1);
            }
            ctx.clearRect(0, 0, clearW / this.lastScaleX + 1, clearH / this.lastScaleY + 1);
            ctx.save();
            ctx.textBaseline = "middle";
            if (lineWidth > 0) {
                ctx.lineJoin = "round";
                ctx.strokeStyle = strokeColStr;
                ctx.lineWidth = lineWidth;
                ctx.strokeText(char, margin_left, margin_top + sz / 2);
            }
            if (colStr) {
                ctx.fillStyle = colStr;
                ctx.fillText(char, margin_left, margin_top + sz / 2);
            }
            if (this.showDbgInfo) {
                ctx.strokeStyle = '#ff0000';
                ctx.strokeRect(1, 1, w - 2, h - 2);
                ctx.strokeStyle = '#00ff00';
                ctx.strokeRect(margin_left, margin_top, cri.width, cri.height);
            }
            if (rect) {
                if (rect[2] <= 0)
                    rect[2] = Math.ceil(-rect[2] + (cri.width + lineWidth * 2) * this.lastScaleX);
                if (rect[2] <= 0)
                    rect[2] = 1;
            }
            var imgdt = rect ? (ctx.getImageData(rect[0], rect[1], rect[2], rect[3] + 1)) : (ctx.getImageData(0, 0, w, h + 1));
            ctx.restore();
            cri.bmpWidth = imgdt.width;
            cri.bmpHeight = imgdt.height;
            return imgdt;
        }
        getCharCanvas(char, font, lineWidth, colStr, strokeColStr, cri, margin_left, margin_top, margin_right, margin_bottom) {
            var ctx = this.ctx;
            if (ctx.font != font) {
                ctx.font = font;
                ctx._lastFont = font;
            }
            if (Browser.window.isIOSHighPerformanceModePlus) {
                ctx.font = font;
            }
            cri.width = ctx.measureText(char).width;
            var w = cri.width * this.lastScaleX;
            var h = cri.height * this.lastScaleY;
            w += (margin_left + margin_right) * this.lastScaleX;
            h += ((margin_top + margin_bottom) * this.lastScaleY + 1);
            w = Math.min(w, this.maxTexW);
            h = Math.min(h, this.maxTexH);
            CharRender_Canvas.canvas.width = Math.min(w + 1, this.maxTexW);
            CharRender_Canvas.canvas.height = Math.min(h + 1, this.maxTexH);
            ctx.font = font;
            ctx.clearRect(0, 0, w + 1 + lineWidth, h + 1 + lineWidth);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.save();
            if (this.scaleFontSize) {
                ctx.scale(this.lastScaleX, this.lastScaleY);
            }
            ctx.translate(margin_left, margin_top);
            ctx.textAlign = "left";
            var sz = this.fontsz;
            ctx.textBaseline = "middle";
            if (lineWidth > 0) {
                ctx.lineJoin = "round";
                ctx.strokeStyle = strokeColStr;
                ctx.fillStyle = colStr;
                ctx.lineWidth = lineWidth;
                if (ctx.fillAndStrokeText) {
                    ctx.fillAndStrokeText(char, 0, sz / 2);
                }
                else {
                    ctx.strokeText(char, 0, sz / 2);
                    ctx.fillText(char, 0, sz / 2);
                }
            }
            else if (colStr) {
                ctx.fillStyle = colStr;
                ctx.fillText(char, 0, sz / 2);
            }
            if (this.showDbgInfo) {
                ctx.strokeStyle = '#ff0000';
                ctx.strokeRect(0, 0, w, h);
                ctx.strokeStyle = '#00ff00';
                ctx.strokeRect(0, 0, cri.width, cri.height);
            }
            ctx.restore();
            cri.bmpWidth = CharRender_Canvas.canvas.width;
            cri.bmpHeight = CharRender_Canvas.canvas.height;
            return CharRender_Canvas.canvas;
        }
    }
    CharRender_Canvas.canvas = null;

    class TextRender extends EventDispatcher {
        constructor() {
            super();
            this.fontSizeInfo = {};
            this.mapFont = {};
            this.fontID = 0;
            this.fontScaleX = 1.0;
            this.fontScaleY = 1.0;
            this._curStrPos = 0;
            this.textAtlases = [];
            this.isoTextures = [];
            this.lastFont = null;
            this.fontSizeW = 0;
            this.fontSizeH = 0;
            this.fontSizeOffX = 0;
            this.fontSizeOffY = 0;
            this.renderPerChar = true;
            this._fontMeasure = null;
            var bugIOS = false;
            var miniadp = ILaya.Laya['MiniAdpter'];
            if (miniadp && miniadp.systemInfo && miniadp.systemInfo.system) {
                bugIOS = miniadp.systemInfo.system.toLowerCase() === 'ios 10.1.1';
            }
            if ((ILaya.Browser.onMiniGame ||
                ILaya.Browser.onTTMiniGame ||
                ILaya.Browser.onBLMiniGame ||
                ILaya.Browser.onAlipayMiniGame ||
                ILaya.Browser.onTBMiniGame) &&
                !bugIOS)
                TextRender.isWan1Wan = true;
            this.charRender = new CharRender_Canvas(2048, 2048, TextRender.scaleFontWithCtx, !TextRender.isWan1Wan, false);
            TextRender.textRenderInst = this;
            ILaya.Laya['textRender'] = this;
        }
        set fontMeasure(m) {
            this._fontMeasure = m;
        }
        get fontMeasure() {
            return this._fontMeasure;
        }
        _wan1wansz(font, size) {
            let fontstr = 'bold ' + size + 'px ' + font;
            let fontSizeW = this.charRender.getWidth(fontstr, '有') * 1.5;
            let fontSizeH = size * 1.5;
            var szinfo = fontSizeW << 8 | fontSizeH;
            this.fontSizeInfo[font] = szinfo;
            return szinfo;
        }
        getFontSizeInfo(font) {
            var finfo = this.fontSizeInfo[font];
            if (!finfo) {
                if (TextRender.isWan1Wan) {
                    finfo = this._wan1wansz(font, TextRender.standardFontSize);
                }
                else {
                    finfo = this._fontMeasure.getFontSizeInfo(font, TextRender.standardFontSize);
                }
                this.fontSizeInfo[font] = finfo;
            }
            return finfo;
        }
        setFont(font) {
            if (this.lastFont == font)
                return;
            this.lastFont = font;
            var fontsz = this.getFontSizeInfo(font._family);
            var offx = fontsz >> 24;
            var offy = (fontsz >> 16) & 0xff;
            var fw = (fontsz >> 8) & 0xff;
            var fh = fontsz & 0xff;
            var k = font._size / TextRender.standardFontSize;
            this.fontSizeOffX = Math.ceil(offx * k);
            this.fontSizeOffY = Math.ceil(offy * k);
            this.fontSizeW = Math.ceil(fw * k);
            this.fontSizeH = Math.ceil(fh * k);
            if (font._font.indexOf('italic') >= 0) {
                this.fontStr = font._font.replace('italic', '');
            }
            else {
                this.fontStr = font._font;
            }
        }
        getNextChar(str) {
            var len = str.length;
            var start = this._curStrPos;
            if (!str.substring)
                return null;
            if (start >= len)
                return null;
            var i = start;
            var state = 0;
            for (; i < len; i++) {
                var c = str.charCodeAt(i);
                if ((c >>> 11) == 0x1b) {
                    if (state == 1)
                        break;
                    state = 1;
                    i++;
                }
                else if (c === 0xfe0e || c === 0xfe0f) ;
                else if (c == 0x200d) {
                    state = 2;
                }
                else {
                    if (state == 0)
                        state = 1;
                    else if (state == 1)
                        break;
                    else ;
                }
            }
            this._curStrPos = i;
            return str.substring(start, i);
        }
        filltext(ctx, data, x, y, fontStr, color, strokeColor, lineWidth, textAlign) {
            if (data.length <= 0)
                return;
            var font = FontInfo.parse(fontStr);
            var nTextAlign = 0;
            switch (textAlign) {
                case 'center':
                    nTextAlign = Const.ENUM_TEXTALIGN_CENTER;
                    break;
                case 'right':
                    nTextAlign = Const.ENUM_TEXTALIGN_RIGHT;
                    break;
            }
            this._fast_filltext(ctx, data, x, y, font, color, strokeColor, lineWidth, nTextAlign);
        }
        _fast_filltext(ctx, data, x, y, font, color, strokeColor, lineWidth, textAlign) {
            if (data && !(data.length >= 1))
                return;
            if (lineWidth < 0)
                lineWidth = 0;
            this.setFont(font);
            this.fontScaleX = this.fontScaleY = 1.0;
            if (TextRender.scaleFontWithCtx) {
                let sx = ctx.getMatScaleX();
                let sy = ctx.getMatScaleY();
                if (sx < 1e-4 || sy < 1e-1)
                    return;
                if (sx > 1)
                    this.fontScaleX = Math.min(TextRender.maxFontScale, sx);
                if (sy > 1)
                    this.fontScaleY = Math.min(TextRender.maxFontScale, sy);
            }
            font._italic && (ctx._italicDeg = 13);
            let wt = data;
            let isWT = data instanceof WordText$1;
            let str = data && data.toString();
            let sameTexData = isWT ? wt.pageChars : [];
            let strWidth = 0;
            if (isWT) {
                str = wt.text;
                strWidth = wt.width;
                if (strWidth < 0) {
                    strWidth = wt.width = this.charRender.getWidth(this.fontStr, str);
                }
            }
            else {
                strWidth = str ? this.charRender.getWidth(this.fontStr, str) : 0;
            }
            switch (textAlign) {
                case Const.ENUM_TEXTALIGN_CENTER:
                    x -= strWidth / 2;
                    break;
                case Const.ENUM_TEXTALIGN_RIGHT:
                    x -= strWidth;
                    break;
            }
            if (isWT) {
                if (this.hasFreedText(sameTexData) || wt.pagecharsCtx != ctx) {
                    sameTexData = wt.pageChars = [];
                }
            }
            let splitTex = this.renderPerChar = (!isWT) || TextRender.forceSplitRender || (isWT && wt.splitRender);
            if (!sameTexData || sameTexData.length < 1) {
                if (isWT) {
                    wt.scalex = this.fontScaleX;
                    wt.scaley = this.fontScaleY;
                }
                if (splitTex) {
                    let stx = 0;
                    let sty = 0;
                    this._curStrPos = 0;
                    let curstr;
                    while (true) {
                        curstr = this.getNextChar(str);
                        if (!curstr)
                            break;
                        let ri = this.getCharRenderInfo(curstr, font, color, strokeColor, lineWidth, false);
                        if (!ri) {
                            break;
                        }
                        if (ri.isSpace) ;
                        else {
                            var add = sameTexData[ri.texture.id];
                            if (!add) {
                                var o1 = { texgen: ri.texture.genID, tex: ri.texture, words: new Array() };
                                sameTexData[ri.texture.id] = o1;
                                add = o1.words;
                            }
                            else {
                                add = add.words;
                            }
                            add.push({ ri: ri, x: stx, y: sty, w: ri.bmpWidth / this.fontScaleX, h: ri.bmpHeight / this.fontScaleY });
                            stx += ri.width;
                        }
                    }
                }
                else {
                    let margin = (font._size / 3 | 0);
                    let isotex = TextRender.noAtlas || (strWidth + margin + margin) * this.fontScaleX > TextRender.atlasWidth;
                    let ri = this.getCharRenderInfo(str, font, color, strokeColor, lineWidth, isotex);
                    sameTexData[0] = { texgen: ri.texture.genID, tex: ri.texture, words: [{ ri: ri, x: 0, y: 0, w: ri.bmpWidth / this.fontScaleX, h: ri.bmpHeight / this.fontScaleY }] };
                }
                isWT && (wt.pagecharsCtx = ctx);
            }
            this._drawResortedWords(ctx, x, y, sameTexData);
            ctx._italicDeg = 0;
        }
        _drawResortedWords(ctx, startx, starty, samePagesData) {
            var isLastRender = ctx._charSubmitCache ? ctx._charSubmitCache._enable : false;
            var mat = ctx._curMat;
            for (var id in samePagesData) {
                var dt = samePagesData[id];
                if (!dt)
                    continue;
                var pri = dt.words;
                if (!pri)
                    continue;
                var count = pri.length;
                if (count <= 0)
                    continue;
                var tex = samePagesData[id].tex;
                for (var j = 0; j < count; j++) {
                    var riSaved = pri[j];
                    var ri = riSaved.ri;
                    if (ri.isSpace)
                        continue;
                    ctx.touchRes(ri);
                    ctx.drawTexAlign = true;
                    ctx._inner_drawTexture(tex, tex.id, startx + riSaved.x - ri.orix, starty + riSaved.y - ri.oriy, riSaved.w, riSaved.h, mat, ri.uv, 1.0, isLastRender, 0xffffffff);
                }
            }
        }
        hasFreedText(txts) {
            for (let i in txts) {
                var pri = txts[i];
                if (!pri)
                    continue;
                var tex = pri.tex;
                if (tex && (tex.destroyed || tex.genID != pri.texgen)) {
                    return true;
                }
            }
            return false;
        }
        getCharRenderInfo(str, font, color, strokeColor, lineWidth, isoTexture = false) {
            var fid = this.mapFont[font._family];
            if (fid == undefined) {
                this.mapFont[font._family] = fid = this.fontID++;
            }
            var key = str + '_' + fid + '_' + font._size + '_' + color;
            if (lineWidth > 0)
                key += '_' + strokeColor + lineWidth;
            if (font._bold)
                key += 'P';
            if (this.fontScaleX != 1 || this.fontScaleY != 1) {
                key += (this.fontScaleX * 20 | 0) + '_' + (this.fontScaleY * 20 | 0);
            }
            var i = 0;
            var sz = this.textAtlases.length;
            var ri;
            var atlas;
            if (!isoTexture) {
                for (i = 0; i < sz; i++) {
                    atlas = this.textAtlases[i];
                    ri = atlas.charMaps[key];
                    if (ri) {
                        ri.touch();
                        return ri;
                    }
                }
            }
            ri = new CharRenderInfo();
            this.charRender.scale(this.fontScaleX, this.fontScaleY);
            ri.char = str;
            ri.height = font._size;
            var margin = (font._size / 3 | 0);
            var imgdt = null;
            if (!lineWidth) {
                lineWidth = 0;
            }
            var w1 = Math.ceil((this.charRender.getWidth(this.fontStr, str) + 2 * lineWidth) * this.fontScaleX);
            let needCanvW = w1 + margin * 2 * this.fontScaleX;
            if (needCanvW > this.charRender.canvasWidth) {
                this.charRender.canvasWidth = needCanvW;
            }
            if (isoTexture) {
                this.charRender.fontsz = font._size;
                imgdt = this.charRender.getCharBmp(str, this.fontStr, lineWidth, color, strokeColor, ri, margin, margin, margin, margin, null);
                if (imgdt) {
                    var tex = TextTexture.getTextTexture(imgdt.width, imgdt.height);
                    tex.addChar(imgdt, 0, 0, ri.uv);
                    ri.texture = tex;
                    ri.orix = margin;
                    ri.oriy = margin;
                    tex.ri = ri;
                    this.isoTextures.push(tex);
                }
            }
            else {
                var len = str.length;
                var lineExt = lineWidth * 1;
                var fw = Math.ceil((this.fontSizeW + lineExt * 2) * this.fontScaleX);
                var fh = Math.ceil((this.fontSizeH + lineExt * 2) * this.fontScaleY);
                TextRender.imgdtRect[0] = ((margin - this.fontSizeOffX - lineExt) * this.fontScaleX) | 0;
                TextRender.imgdtRect[1] = ((margin - this.fontSizeOffY - lineExt) * this.fontScaleY) | 0;
                if (this.renderPerChar || len == 1) {
                    TextRender.imgdtRect[2] = Math.max(w1, fw);
                    TextRender.imgdtRect[3] = Math.max(w1, fh);
                }
                else {
                    TextRender.imgdtRect[2] = -(this.fontSizeOffX * this.fontScaleX);
                    TextRender.imgdtRect[3] = fh;
                }
                this.charRender.fontsz = font._size;
                imgdt = this.charRender.getCharBmp(str, this.fontStr, lineWidth, color, strokeColor, ri, margin, margin, margin, margin, TextRender.imgdtRect);
                if (imgdt) {
                    atlas = this.addBmpData(imgdt, ri);
                    if (TextRender.isWan1Wan) {
                        ri.orix = margin;
                        ri.oriy = margin;
                    }
                    else {
                        ri.orix = (this.fontSizeOffX + lineExt);
                        ri.oriy = (this.fontSizeOffY + lineExt);
                    }
                    atlas.charMaps[key] = ri;
                }
            }
            return ri;
        }
        addBmpData(data, ri) {
            var w = data.width;
            var h = data.height;
            var sz = this.textAtlases.length;
            var atlas;
            var find = false;
            for (var i = 0; i < sz; i++) {
                atlas = this.textAtlases[i];
                find = atlas.getAEmpty(w, h, tmpAtlasPos);
                if (find) {
                    break;
                }
            }
            if (!find) {
                atlas = new TextAtlas();
                this.textAtlases.push(atlas);
                find = atlas.getAEmpty(w, h, tmpAtlasPos);
                if (!find) {
                    throw 'err1';
                }
                this.cleanAtlases();
            }
            if (find) {
                atlas.texture.addChar(data, tmpAtlasPos.x, tmpAtlasPos.y, ri.uv);
                ri.texture = atlas.texture;
            }
            return atlas;
        }
        GC() {
            var i = 0;
            var sz = this.textAtlases.length;
            var dt = 0;
            var destroyDt = TextRender.destroyAtlasDt;
            var totalUsedRateAtlas = 0;
            var curloop = RenderInfo.loopCount;
            var maxWasteRateID = -1;
            var maxWasteRate = 0;
            var tex = null;
            var curatlas = null;
            for (; i < sz; i++) {
                curatlas = this.textAtlases[i];
                tex = curatlas.texture;
                if (tex) {
                    totalUsedRateAtlas += tex.curUsedCovRateAtlas;
                    var waste = curatlas.usedRate - tex.curUsedCovRateAtlas;
                    if (maxWasteRate < waste) {
                        maxWasteRate = waste;
                        maxWasteRateID = i;
                    }
                }
                dt = curloop - curatlas.texture.lastTouchTm;
                if (dt > destroyDt) {
                    TextRender.showLog && console.log('TextRender GC delete atlas ' + tex ? curatlas.texture.id : 'unk');
                    curatlas.destroy();
                    this.textAtlases[i] = this.textAtlases[sz - 1];
                    sz--;
                    i--;
                    maxWasteRateID = -1;
                }
            }
            this.textAtlases.length = sz;
            sz = this.isoTextures.length;
            for (i = 0; i < sz; i++) {
                tex = this.isoTextures[i];
                dt = curloop - tex.lastTouchTm;
                if (dt > TextRender.destroyUnusedTextureDt) {
                    tex.ri.deleted = true;
                    tex.ri.texture = null;
                    tex.destroy();
                    this.isoTextures[i] = this.isoTextures[sz - 1];
                    sz--;
                    i--;
                }
            }
            this.isoTextures.length = sz;
            var needGC = this.textAtlases.length > 1 && this.textAtlases.length - totalUsedRateAtlas >= 2;
            if (TextRender.atlasWidth * TextRender.atlasWidth * 4 * this.textAtlases.length > TextRender.cleanMem || needGC || TextRender.simClean) {
                TextRender.simClean = false;
                TextRender.showLog && console.log('清理使用率低的贴图。总使用率:', totalUsedRateAtlas, ':', this.textAtlases.length, '最差贴图:' + maxWasteRateID);
                if (maxWasteRateID >= 0) {
                    curatlas = this.textAtlases[maxWasteRateID];
                    curatlas.destroy();
                    this.textAtlases[maxWasteRateID] = this.textAtlases[this.textAtlases.length - 1];
                    this.textAtlases.length = this.textAtlases.length - 1;
                    this.event('GC');
                }
            }
        }
        cleanAtlases() {
        }
        printDbgInfo() {
            console.log('图集个数:' + this.textAtlases.length + ',每个图集大小:' + TextRender.atlasWidth + 'x' + TextRender.atlasWidth, ' 用canvas:', TextRender.isWan1Wan);
            console.log('图集占用空间:' + (TextRender.atlasWidth * TextRender.atlasWidth * 4 / 1024 / 1024 * this.textAtlases.length) + 'M');
            console.log('缓存用到的字体:');
            for (var f in this.mapFont) {
                var fontsz = this.getFontSizeInfo(f);
                var offx = fontsz >> 24;
                var offy = (fontsz >> 16) & 0xff;
                var fw = (fontsz >> 8) & 0xff;
                var fh = fontsz & 0xff;
                console.log('    ' + f, ' off:', offx, offy, ' size:', fw, fh);
            }
            var num = 0;
            console.log('缓存数据:');
            var totalUsedRate = 0;
            var totalUsedRateAtlas = 0;
            this.textAtlases.forEach(function (a) {
                var id = a.texture.id;
                var dt = RenderInfo.loopCount - a.texture.lastTouchTm;
                var dtstr = dt > 0 ? ('' + dt + '帧以前') : '当前帧';
                totalUsedRate += a.texture.curUsedCovRate;
                totalUsedRateAtlas += a.texture.curUsedCovRateAtlas;
                console.log('--图集(id:' + id + ',当前使用率:' + (a.texture.curUsedCovRate * 1000 | 0) + '‰', '当前图集使用率:', (a.texture.curUsedCovRateAtlas * 100 | 0) + '%', '图集使用率:', (a.usedRate * 100 | 0), '%, 使用于:' + dtstr + ')--:');
                for (var k in a.charMaps) {
                    var ri = a.charMaps[k];
                    console.log('     off:', ri.orix, ri.oriy, ' bmp宽高:', ri.bmpWidth, ri.bmpHeight, '无效:', ri.deleted, 'touchdt:', (RenderInfo.loopCount - ri.touchTick), '位置:', ri.uv[0] * TextRender.atlasWidth | 0, ri.uv[1] * TextRender.atlasWidth | 0, '字符:', ri.char, 'key:', k);
                    num++;
                }
            });
            console.log('独立贴图文字(' + this.isoTextures.length + '个):');
            this.isoTextures.forEach(function (tex) {
                console.log('    size:', tex.width, tex.height, 'touch间隔:', (RenderInfo.loopCount - tex.lastTouchTm), 'char:', tex.ri.char);
            });
            console.log('总缓存:', num, '总使用率:', totalUsedRate, '总当前图集使用率:', totalUsedRateAtlas);
        }
        showAtlas(n, bgcolor, x, y, w, h) {
            if (!this.textAtlases[n]) {
                console.log('没有这个图集');
                return null;
            }
            var sp = new Sprite();
            var texttex = this.textAtlases[n].texture;
            var texture = {
                width: TextRender.atlasWidth,
                height: TextRender.atlasWidth,
                sourceWidth: TextRender.atlasWidth,
                sourceHeight: TextRender.atlasWidth,
                offsetX: 0,
                offsetY: 0,
                getIsReady: function () { return true; },
                _addReference: function () { },
                _removeReference: function () { },
                _getSource: function () { return texttex._getSource(); },
                bitmap: { id: texttex.id },
                _uv: Texture.DEF_UV
            };
            sp.size = function (w, h) {
                this.width = w;
                this.height = h;
                sp.graphics.clear();
                sp.graphics.drawRect(0, 0, sp.width, sp.height, bgcolor);
                sp.graphics.drawTexture(texture, 0, 0, sp.width, sp.height);
                return this;
            };
            sp.graphics.drawRect(0, 0, w, h, bgcolor);
            sp.graphics.drawTexture(texture, 0, 0, w, h);
            sp.pos(x, y);
            ILaya.stage.addChild(sp);
            return sp;
        }
    }
    TextRender.useOldCharBook = false;
    TextRender.atlasWidth = 1024;
    TextRender.noAtlas = false;
    TextRender.forceSplitRender = false;
    TextRender.forceWholeRender = false;
    TextRender.scaleFontWithCtx = true;
    TextRender.maxFontScale = 4;
    TextRender.standardFontSize = 32;
    TextRender.destroyAtlasDt = 10;
    TextRender.checkCleanTextureDt = 2000;
    TextRender.destroyUnusedTextureDt = 3000;
    TextRender.cleanMem = 100 * 1024 * 1024;
    TextRender.isWan1Wan = false;
    TextRender.showLog = false;
    TextRender.debugUV = false;
    TextRender.imgdtRect = [0, 0, 0, 0];
    TextRender.simClean = false;
    const tmpAtlasPos = new Point();

    class MeshTexture extends Sprite2DGeometry {
        static __init__() {
            MeshTexture.VertexDeclarition = new VertexDeclaration(48, [
                new VertexElement(0, VertexElementFormat.Vector4, 0),
                new VertexElement(16, VertexElementFormat.Vector4, 1),
                new VertexElement(32, VertexElementFormat.Vector4, 2),
            ]);
        }
        constructor() {
            super(MeshTexture.const_stride, 4, 4);
        }
        onVBRealloc(buff) {
            this._vbFloat32Array = new Float32Array(buff);
        }
        onIBRealloc(buff) {
            this._ibU16Array = new Uint16Array(buff);
        }
        addData(vertices, uvs, idx, matrix, rgba, uvrect = null) {
            let addVert = vertices.length / 2;
            this.expVBSize(addVert * MeshTexture.const_stride);
            var vertsz = vertices.length >> 1;
            var startpos = this._vertNum * MeshTexture.const_stride;
            var f32pos = startpos >> 2;
            var vbdata = this._vbFloat32Array;
            var ci = 0;
            var m00 = matrix.a;
            var m01 = matrix.b;
            var m10 = matrix.c;
            var m11 = matrix.d;
            var tx = matrix.tx;
            var ty = matrix.ty;
            var i = 0;
            let uvminx = 0;
            let uvminy = 0;
            let uvu = 1;
            let uvv = 1;
            if (uvrect) {
                uvminx = uvrect[0];
                uvminy = uvrect[1];
                uvu = uvrect[2];
                uvv = uvrect[3];
            }
            let r = ((rgba >>> 16) & 0xff) / 255.0;
            let g = ((rgba >>> 8) & 0xff) / 255.0;
            let b = (rgba & 0xff) / 255.0;
            let a = (rgba >>> 24) / 255.0;
            for (i = 0; i < vertsz; i++) {
                var x = vertices[ci], y = vertices[ci + 1];
                vbdata[f32pos] = x * m00 + y * m10 + tx;
                vbdata[f32pos + 1] = x * m01 + y * m11 + ty;
                vbdata[f32pos + 2] = uvminx + uvs[ci] * uvu;
                vbdata[f32pos + 3] = uvminy + uvs[ci + 1] * uvv;
                vbdata[f32pos + 4] = b;
                vbdata[f32pos + 5] = g;
                vbdata[f32pos + 6] = r;
                vbdata[f32pos + 7] = a;
                vbdata[f32pos + 8] = 0xff;
                f32pos += 12;
                ci += 2;
            }
            var vertN = this._vertNum;
            var ibstart = this._indexNum;
            this.expIBSize(idx.byteLength);
            var indexBuffer = this._ibU16Array;
            if (vertN > 0) {
                for (let i = ibstart, si = 0, end = ibstart + idx.length; i < end; i++, si++) {
                    indexBuffer[i] = idx[si] + vertN;
                }
            }
            else {
                indexBuffer.set(idx);
            }
            this._vertNum += vertsz;
            this._indexNum += idx.length;
        }
        get vertexDeclarition() {
            return MeshTexture.VertexDeclarition;
        }
    }
    MeshTexture.const_stride = 48;
    MeshTexture.VertexDeclarition = null;

    class MeshVG extends Sprite2DGeometry {
        static __init__() {
            MeshVG.vertexDeclaration = new VertexDeclaration(24, [
                new VertexElement(0, VertexElementFormat.Vector2, 0),
                new VertexElement(8, VertexElementFormat.Vector4, 1),
            ]);
        }
        constructor() {
            super(MeshVG.const_stride, 4, 4);
            this._vbFloat32Array = null;
        }
        onVBRealloc(buff) {
            this._vbFloat32Array = new Float32Array(buff);
        }
        onIBRealloc(buff) {
        }
        addVertAndIBToMesh(points, rgba, ib) {
            var startpos = this._vertNum * MeshVG.const_stride;
            this.expVBSize(points.length / 2 * MeshVG.const_stride);
            var f32pos = startpos >> 2;
            var vbdata = this._vbFloat32Array;
            var ci = 0;
            let r = ((rgba >>> 16) & 0xff) / 255.0;
            let g = ((rgba >>> 8) & 0xff) / 255.0;
            let b = (rgba & 0xff) / 255.0;
            let a = (rgba >>> 24) / 255.0;
            var sz = points.length / 2;
            for (var i = 0; i < sz; i++) {
                vbdata[f32pos++] = points[ci];
                vbdata[f32pos++] = points[ci + 1];
                ci += 2;
                vbdata[f32pos++] = b;
                vbdata[f32pos++] = g;
                vbdata[f32pos++] = r;
                vbdata[f32pos++] = a;
            }
            this.expIBSize(ib.length * 2);
            (new Uint16Array(this._IBBuff, this._indexNum * 2, ib.length)).set(new Uint16Array(ib));
            this._vertNum += sz;
            this._indexNum += ib.length;
        }
        get vertexDeclarition() {
            return MeshVG.vertexDeclaration;
        }
    }
    MeshVG.const_stride = 24;
    MeshVG.vertexDeclaration = null;

    const defaultClipMatrix = new Matrix(Const.MAX_CLIP_SIZE, 0, 0, Const.MAX_CLIP_SIZE, 0, 0);
    const tmpuv1 = [0, 0, 0, 0, 0, 0, 0, 0];
    const tmpMat$1 = new Matrix();
    class Context {
        static __init__() {
            Context.MAXCLIPRECT = new Rectangle(0, 0, Const.MAX_CLIP_SIZE, Const.MAX_CLIP_SIZE);
            ContextParams.DEFAULT = new ContextParams();
            if (!Context._textRender) {
                let textRender = Context._textRender = new TextRender();
                textRender.fontMeasure = new MeasureFont(textRender.charRender);
            }
        }
        constructor() {
            this._alpha = 1.0;
            this._material = null;
            this._fillStyle = DrawStyle.DEFAULT;
            this._strokeStyle = DrawStyle.DEFAULT;
            this._drawTexToDrawTri_Vert = new Float32Array(8);
            this._drawTexToDrawTri_Index = new Uint16Array([0, 1, 2, 0, 2, 3]);
            this._tempUV = new Float32Array(8);
            this._drawTriUseAbsMatrix = false;
            this._other = null;
            this._path = null;
            this._drawCount = 1;
            this._width = Const.MAX_CLIP_SIZE;
            this._height = Const.MAX_CLIP_SIZE;
            this._renderCount = 0;
            this.stopMerge = true;
            this._curSubmit = SubmitBase.RENDERBASE;
            this._submitKey = new SubmitKey();
            this._meshQuatTex = new MeshQuadTexture();
            this._meshVG = new MeshVG();
            this._meshTex = new MeshTexture();
            this._transedPoints = new Array(8);
            this._temp4Points = new Array(8);
            this._clipRect = Context.MAXCLIPRECT;
            this._globalClipMatrix = defaultClipMatrix.clone();
            this._clipInfoID = 0;
            this._clipID_Gen = 0;
            this._matBuffer = new Float32Array(6);
            this._lastMatScaleX = 1.0;
            this._lastMatScaleY = 1.0;
            this._lastMat_a = 1.0;
            this._lastMat_b = 0.0;
            this._lastMat_c = 0.0;
            this._lastMat_d = 1.0;
            this._nBlendType = 0;
            this._save = null;
            this._charSubmitCache = null;
            this._saveMark = null;
            this._shader2D = new Shader2D();
            this.sprite = null;
            this._italicDeg = 0;
            this._lastTex = null;
            this._fillColor = 0;
            this._flushCnt = 0;
            this.defTexture = null;
            this._colorFiler = null;
            this.drawTexAlign = false;
            this._incache = false;
            this._isMain = false;
            this._render2D = null;
            this._clearColor = new Color(0, 0, 0, 0);
            this._clear = false;
            this._shaderValueNeedRelease = [];
            this.render2D = new Render2DSimple();
            Context._contextcount++;
            if (!this.defTexture) {
                var defTex2d = new Texture2D(2, 2, exports.TextureFormat.R8G8B8A8, true, false, false);
                defTex2d.setPixelsData(new Uint8Array(16), false, false);
                defTex2d.lock = true;
                this.defTexture = new Texture(defTex2d);
            }
            this._lastTex = this.defTexture;
            this._other = ContextParams.DEFAULT;
            this._curMat = Matrix.create();
            this._charSubmitCache = new CharSubmitCache(this);
            this._mesh = this._meshQuatTex;
            this._mesh.clearMesh();
            this._save = [SaveMark.Create(this)];
            this._save.length = 10;
            this.clear();
            this._render2DManager = new RenderManager2D();
        }
        copyState(ctx) {
        }
        set isMain(v) {
            this._isMain = v;
        }
        get isMain() {
            return this._isMain;
        }
        set render2D(render) {
            this._render2D = render;
        }
        get render2D() {
            return this._render2D;
        }
        get lineJoin() {
            return '';
        }
        set lineJoin(value) {
        }
        get lineCap() {
            return '';
        }
        set lineCap(value) {
        }
        get miterLimit() {
            return '';
        }
        set miterLimit(value) {
        }
        touchRes(res) {
            res.touch();
        }
        transformByMatrix(matrix, tx, ty) {
            this.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx + tx, matrix.ty + ty);
        }
        drawRect(x, y, width, height, fillColor, lineColor, lineWidth) {
            var ctx = this;
            if (fillColor != null) {
                ctx.fillStyle = fillColor;
                ctx.fillRect(x, y, width, height);
            }
            if (lineColor != null) {
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = lineWidth;
                ctx.strokeRect(x, y, width, height);
            }
        }
        alpha(value) {
            this.globalAlpha *= value;
        }
        _transform(mat, pivotX, pivotY) {
            this.translate(pivotX, pivotY);
            this.transform(mat.a, mat.b, mat.c, mat.d, mat.tx, mat.ty);
            this.translate(-pivotX, -pivotY);
        }
        _rotate(angle, pivotX, pivotY) {
            this.translate(pivotX, pivotY);
            this.rotate(angle);
            this.translate(-pivotX, -pivotY);
        }
        _scale(scaleX, scaleY, pivotX, pivotY) {
            this.translate(pivotX, pivotY);
            this.scale(scaleX, scaleY);
            this.translate(-pivotX, -pivotY);
        }
        _drawLine(x, y, fromX, fromY, toX, toY, lineColor, lineWidth, vid) {
            this.beginPath();
            this.strokeStyle = lineColor;
            this.lineWidth = lineWidth;
            this.moveTo(x + fromX, y + fromY);
            this.lineTo(x + toX, y + toY);
            this.stroke();
        }
        _drawLines(x, y, points, lineColor, lineWidth, vid) {
            this.beginPath();
            this.strokeStyle = lineColor;
            this.lineWidth = lineWidth;
            this.addPath(points.slice(), false, false, x, y);
            this.stroke();
        }
        drawCurves(x, y, points, lineColor, lineWidth) {
            this.beginPath();
            this.strokeStyle = lineColor;
            this.lineWidth = lineWidth;
            this.moveTo(x + points[0], y + points[1]);
            var i = 2, n = points.length;
            while (i < n) {
                this.quadraticCurveTo(x + points[i++], y + points[i++], x + points[i++], y + points[i++]);
            }
            this.stroke();
        }
        _fillAndStroke(fillColor, strokeColor, lineWidth, isConvexPolygon = false) {
            if (fillColor != null) {
                this.fillStyle = fillColor;
                this.fill();
            }
            if (strokeColor != null && lineWidth > 0) {
                this.strokeStyle = strokeColor;
                this.lineWidth = lineWidth;
                this.stroke();
            }
        }
        _drawCircle(x, y, radius, fillColor, lineColor, lineWidth, vid) {
            this.beginPath(true);
            this.arc(x, y, radius, radius, 0, 2 * Math.PI, false, true, 40);
            this.closePath();
            this._fillAndStroke(fillColor, lineColor, lineWidth);
        }
        _drawEllipse(x, y, width, height, fillColor, lineColor, lineWidth) {
            this.beginPath(true);
            this.arc(x, y, width, height, 0, 2 * Math.PI, false, true, 40);
            this.closePath();
            this._fillAndStroke(fillColor, lineColor, lineWidth);
        }
        _drawRoundRect(x, y, width, height, lt, rt, lb, rb, fillColor, lineColor, lineWidth) {
            this.beginPath(true);
            var tPath = this._getPath();
            if (0 >= lt) {
                tPath.addPoint(x, y);
            }
            else {
                this.arc(x + lt, y + lt, lt, lt, Math.PI, Math.PI + 0.5 * Math.PI);
            }
            let startX = x + width - rt;
            if (0 >= rt) {
                tPath.addPoint(startX, y);
            }
            else {
                this.arc(startX, y + rt, rt, rt, Math.PI + 0.5 * Math.PI, 2 * Math.PI);
            }
            startX = x + width - rb;
            let startY = y + height - rb;
            if (0 >= rb) {
                tPath.addPoint(startX, startY);
            }
            else {
                this.arc(startX, startY, rb, rb, 0, 0.5 * Math.PI);
            }
            startX = x + lb;
            startY = y + height - lb;
            if (0 >= lb) {
                tPath.addPoint(startX, startY);
            }
            else {
                this.arc(startX, startY, lb, lb, Math.PI - 0.5 * Math.PI, Math.PI);
            }
            tPath.addPoint(x, y + lt);
            this.closePath();
            this._fillAndStroke(fillColor, lineColor, lineWidth);
        }
        _drawPie(x, y, radius, startAngle, endAngle, fillColor, lineColor, lineWidth, vid) {
            this.beginPath();
            this.moveTo(x, y);
            this.arc(x, y, radius, radius, startAngle, endAngle);
            this.closePath();
            this._fillAndStroke(fillColor, lineColor, lineWidth);
        }
        _drawPoly(x, y, points, fillColor, lineColor, lineWidth, isConvexPolygon, vid) {
            this.beginPath();
            this.addPath(points.slice(), true, isConvexPolygon, x, y);
            this.closePath();
            this._fillAndStroke(fillColor, lineColor, lineWidth, isConvexPolygon);
        }
        _drawPath(x, y, paths, brush, pen) {
            this.beginPath();
            for (var i = 0, n = paths.length; i < n; i++) {
                var path = paths[i];
                switch (path[0]) {
                    case "moveTo":
                        this.moveTo(x + path[1], y + path[2]);
                        break;
                    case "lineTo":
                        this.lineTo(x + path[1], y + path[2]);
                        break;
                    case "arcTo":
                        this.arcTo(x + path[1], y + path[2], x + path[3], y + path[4], path[5]);
                        break;
                    case "closePath":
                        this.closePath();
                        break;
                }
            }
            if (brush != null) {
                this.fillStyle = brush.fillStyle;
                this.fill();
            }
            if (pen != null) {
                this.strokeStyle = pen.strokeStyle;
                this.lineWidth = pen.lineWidth || 1;
                this.lineJoin = pen.lineJoin;
                this.lineCap = pen.lineCap;
                this.miterLimit = pen.miterLimit;
                this.stroke();
            }
        }
        static set2DRenderConfig() {
        }
        clearBG(r, g, b, a) {
            if (r == null || r == undefined) {
                this._clear = false;
            }
            else {
                this._clearColor.setValue(r, g, b, a);
                this._clear = true;
            }
        }
        _releaseMem() {
            this._curMat && this._curMat.destroy();
            this._curMat = null;
            this._shader2D.destroy();
            this._shader2D = null;
            this._charSubmitCache.clear();
            this._path = null;
            this._save = null;
            this.sprite = null;
        }
        destroy() {
            --Context._contextcount;
            this.sprite = null;
            this._charSubmitCache && this._charSubmitCache.destroy();
            if (this.defTexture) {
                this.defTexture.bitmap && this.defTexture.bitmap.destroy();
                this.defTexture.destroy();
            }
            for (var i = 0, n = this._shaderValueNeedRelease.length; i < n; i++) {
                this._shaderValueNeedRelease[i] && this._shaderValueNeedRelease[i].release();
            }
        }
        clear() {
            this._submitKey.clear();
            this._drawCount = 1;
            this._other = ContextParams.DEFAULT;
            this._alpha = 1.0;
            this._nBlendType = 0;
            this._clipRect = Context.MAXCLIPRECT;
            this._fillStyle = this._strokeStyle = DrawStyle.DEFAULT;
            this._curMat.identity();
            this._other.clear();
            this._saveMark = this._save[0];
            this._save._length = 1;
        }
        size(w, h) {
            if (this._width != w || this._height != h) {
                this._width = w;
                this._height = h;
                if (this.isMain) {
                    RenderState2D.width = w;
                    RenderState2D.height = h;
                }
            }
            if (w === 0 && h === 0)
                this._releaseMem();
        }
        get width() {
            return this._width;
        }
        set width(w) {
            this.size(w, this._height);
        }
        get height() {
            return this._height;
        }
        set height(h) {
            this.size(this._width, h);
        }
        getMatScaleX() {
            if (this._lastMat_a == this._curMat.a && this._lastMat_b == this._curMat.b)
                return this._lastMatScaleX;
            this._lastMatScaleX = this._curMat.getScaleX();
            this._lastMat_a = this._curMat.a;
            this._lastMat_b = this._curMat.b;
            return this._lastMatScaleX;
        }
        getMatScaleY() {
            if (this._lastMat_c == this._curMat.c && this._lastMat_d == this._curMat.d)
                return this._lastMatScaleY;
            this._lastMatScaleY = this._curMat.getScaleY();
            this._lastMat_c = this._curMat.c;
            this._lastMat_d = this._curMat.d;
            return this._lastMatScaleY;
        }
        getFillColor() {
            return this._fillColor;
        }
        set fillStyle(value) {
            if (!this._fillStyle.equal(value)) {
                SaveBase.save(this, SaveBase.TYPE_FILESTYLE, this._shader2D, false);
                this._fillStyle = DrawStyle.create(value);
                this._submitKey.other = -this._fillStyle.toInt();
            }
        }
        get fillStyle() {
            return this._fillStyle;
        }
        set globalAlpha(value) {
            value = Math.floor(value * 1000) / 1000;
            if (value != this._alpha) {
                SaveBase.save(this, SaveBase.TYPE_ALPHA, this._shader2D, false);
                this._alpha = value;
            }
        }
        get globalAlpha() {
            return this._alpha;
        }
        set textAlign(value) {
            (this._other.textAlign === value) || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_TEXTALIGN, this._other, false), this._other.textAlign = value);
        }
        get textAlign() {
            return this._other.textAlign;
        }
        set textBaseline(value) {
            (this._other.textBaseline === value) || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_TEXTBASELINE, this._other, false), this._other.textBaseline = value);
        }
        get textBaseline() {
            return this._other.textBaseline;
        }
        set globalCompositeOperation(value) {
            this._drawToRender2D(this._curSubmit);
            var n = BlendMode.TOINT[value];
            n == null || (this._nBlendType === n) || (SaveBase.save(this, SaveBase.TYPE_GLOBALCOMPOSITEOPERATION, this, true), this._curSubmit = SubmitBase.RENDERBASE, this._nBlendType = n);
        }
        get globalCompositeOperation() {
            return BlendMode.NAMES[this._nBlendType];
        }
        set strokeStyle(value) {
            this._strokeStyle.equal(value) || (SaveBase.save(this, SaveBase.TYPE_STROKESTYLE, this._shader2D, false), this._strokeStyle = DrawStyle.create(value), this._submitKey.other = -this._strokeStyle.toInt());
        }
        get strokeStyle() {
            return this._strokeStyle;
        }
        translate(x, y) {
            if (x !== 0 || y !== 0) {
                SaveTranslate.save(this);
                if (this._curMat._bTransform) {
                    SaveTransform.save(this);
                    this._curMat.tx += (x * this._curMat.a + y * this._curMat.c);
                    this._curMat.ty += (x * this._curMat.b + y * this._curMat.d);
                }
                else {
                    this._curMat.tx = x;
                    this._curMat.ty = y;
                }
            }
        }
        set lineWidth(value) {
            (this._other.lineWidth === value) || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_LINEWIDTH, this._other, false), this._other.lineWidth = value);
        }
        get lineWidth() {
            return this._other.lineWidth;
        }
        save() {
            this._save[this._save._length++] = SaveMark.Create(this);
        }
        restore() {
            var sz = this._save._length;
            var lastBlend = this._nBlendType;
            if (sz < 1)
                return;
            for (var i = sz - 1; i >= 0; i--) {
                var o = this._save[i];
                o.restore(this);
                if (o.isSaveMark()) {
                    this._save._length = i;
                    return;
                }
            }
            if (lastBlend != this._nBlendType) {
                this.stopMerge = true;
            }
        }
        fillText(txt, x, y, fontStr, color, align, lineWidth = 0, borderColor = "") {
            Context._textRender.filltext(this, txt, x, y, fontStr, color, borderColor, lineWidth, align);
        }
        drawText(text, x, y, font, color, textAlign) {
            Context._textRender.filltext(this, text, x, y, font, color, null, 0, textAlign);
        }
        strokeWord(text, x, y, font, color, lineWidth, textAlign) {
            Context._textRender.filltext(this, text, x, y, font, null, color, lineWidth, textAlign);
        }
        fillBorderText(txt, x, y, font, color, borderColor, lineWidth, textAlign) {
            Context._textRender.filltext(this, txt, x, y, font, color, borderColor, lineWidth, textAlign);
        }
        _fast_filltext(data, x, y, fontObj, color, strokeColor, lineWidth, textAlign) {
            Context._textRender._fast_filltext(this, data, x, y, fontObj, color, strokeColor, lineWidth, textAlign);
        }
        _fillRect(x, y, width, height, rgba) {
            var submit = this._curSubmit;
            var sameKey = this._mesh.vertexNum + 4 < Context._MAXVERTNUM &&
                submit && (submit._key.submitType === SubmitBase.KEY_DRAWTEXTURE &&
                submit._key.blendShader === this._nBlendType &&
                !this.isStopMerge(submit)) &&
                this._curSubmit.material == this._material;
            if (!sameKey) {
                this._drawToRender2D(this._curSubmit);
                this._mesh = this._meshQuatTex;
            }
            let mesh = this._mesh;
            this.transformQuad(x, y, width, height, 0, this._curMat, this._transedPoints);
            if (!this.clipedOff(this._transedPoints)) {
                if (!sameKey) {
                    submit = this._curSubmit = SubmitBase.create(this, mesh, Value2D.create(exports.RenderSpriteData.Texture2D));
                    this.fillShaderValue(submit.shaderValue);
                    this._copyClipInfo(submit.shaderValue);
                    submit.clipInfoID = this._clipInfoID;
                    if (!this._lastTex || this._lastTex.destroyed) {
                        submit.shaderValue.textureHost = this.defTexture;
                    }
                    else {
                        submit.shaderValue.textureHost = this._lastTex;
                    }
                    submit._key.other = (this._lastTex && this._lastTex.bitmap) ? this._lastTex.bitmap.id : -1;
                }
                mesh.addQuad(this._transedPoints, Texture.NO_UV, rgba, false);
                this._curSubmit._numEle += 6;
            }
        }
        fillRect(x, y, width, height, fillStyle) {
            var drawstyle = fillStyle ? DrawStyle.create(fillStyle) : this._fillStyle;
            var rgba = this.mixRGBandAlpha(drawstyle.toInt());
            this._fillRect(x, y, width, height, rgba);
        }
        fillTexture(texture, x, y, width, height, type, offset, color) {
            if (!texture._getSource()) {
                this.sprite && ILaya.systemTimer.callLater(this, this._repaintSprite);
                return;
            }
            this._fillTexture(texture, texture.width, texture.height, texture.uvrect, x, y, width, height, type, offset.x, offset.y, color);
        }
        _fillTexture(texture, texw, texh, texuvRect, x, y, width, height, type, offsetx, offsety, color) {
            var submit = this._curSubmit;
            this._drawToRender2D(this._curSubmit);
            this._mesh = this._meshQuatTex;
            var repeatx = true;
            var repeaty = true;
            switch (type) {
                case "repeat": break;
                case "repeat-x":
                    repeaty = false;
                    break;
                case "repeat-y":
                    repeatx = false;
                    break;
                case "no-repeat":
                    repeatx = repeaty = false;
                    break;
            }
            var uv = this._temp4Points;
            var stu = 0;
            var stv = 0;
            var stx = 0, sty = 0, edx = 0, edy = 0;
            if (offsetx < 0) {
                stx = x;
                stu = (-offsetx % texw) / texw;
            }
            else {
                stx = x + offsetx;
            }
            if (offsety < 0) {
                sty = y;
                stv = (-offsety % texh) / texh;
            }
            else {
                sty = y + offsety;
            }
            edx = x + width;
            edy = y + height;
            (!repeatx) && (edx = Math.min(edx, x + offsetx + texw));
            (!repeaty) && (edy = Math.min(edy, y + offsety + texh));
            if (edx < x || edy < y)
                return;
            if (stx > edx || sty > edy)
                return;
            var edu = (edx - x - offsetx) / texw;
            var edv = (edy - y - offsety) / texh;
            this.transformQuad(stx, sty, edx - stx, edy - sty, 0, this._curMat, this._transedPoints);
            uv[0] = stu;
            uv[1] = stv;
            uv[2] = edu;
            uv[3] = stv;
            uv[4] = edu;
            uv[5] = edv;
            uv[6] = stu;
            uv[7] = edv;
            if (!this.clipedOff(this._transedPoints)) {
                var sv = Value2D.create(exports.RenderSpriteData.Texture2D);
                sv.shaderData.addDefine(ShaderDefines2D.FILLTEXTURE);
                var arry = texuvRect.concat();
                Vector4.tempVec4.setValue(arry[0], arry[1], arry[2], arry[3]);
                sv.u_TexRange = Vector4.tempVec4;
                submit = this._curSubmit = SubmitBase.create(this, this._mesh, sv);
                this.fillShaderValue(sv);
                submit.clipInfoID = this._clipInfoID;
                submit.shaderValue.textureHost = texture;
                var rgba = this._mixRGBandAlpha(color, this._alpha);
                this._mesh.addQuad(this._transedPoints, uv, rgba, true);
                this._curSubmit._numEle += 6;
            }
            this.breakNextMerge();
        }
        setColorFilter(filter) {
            SaveBase.save(this, SaveBase.TYPE_COLORFILTER, this, true);
            this._colorFiler = filter;
            this.stopMerge = true;
        }
        drawTexture(tex, x, y, width, height, color = 0xffffffff) {
            this._drawTextureM(tex, x, y, width, height, null, 1, null, color);
        }
        drawTextures(tex, pos, tx, ty, colors) {
            if (!tex._getSource()) {
                this.sprite && ILaya.systemTimer.callLater(this, this._repaintSprite);
                return;
            }
            var n = pos.length / 2;
            var ipos = 0;
            var bmpid = tex.bitmap.id;
            for (var i = 0; i < n; i++) {
                const color = typeof colors[i] === 'number' ? colors[i] : 0xffffffff;
                this._inner_drawTexture(tex, bmpid, pos[ipos++] + tx, pos[ipos++] + ty, 0, 0, null, null, 1.0, false, color);
            }
        }
        _drawTextureM(tex, x, y, width, height, m, alpha, uv, color) {
            var cs = this.sprite;
            if (!tex._getSource(function () {
                if (cs) {
                    cs.repaint();
                }
            })) {
                return false;
            }
            return this._inner_drawTexture(tex, tex.bitmap.id, x, y, width, height, m, uv, alpha, false, color);
        }
        _drawRenderTexture(tex, x, y, width, height, m, alpha, uv, color = 0xffffffff) {
            return this._inner_drawTexture(tex, -1, x, y, width, height, m, uv, alpha, false, color);
        }
        _copyClipInfo(shaderValue) {
            let clipInfo = this._globalClipMatrix;
            var cm = shaderValue.clipMatDir;
            cm.x = clipInfo.a;
            cm.y = clipInfo.b;
            cm.z = clipInfo.c;
            cm.w = clipInfo.d;
            shaderValue.clipMatDir = cm;
            var cmp = shaderValue.clipMatPos;
            cmp.x = clipInfo.tx;
            cmp.y = clipInfo.ty;
            shaderValue.clipMatPos = cmp;
        }
        _copyClipInfoToShaderData(shaderData) {
            let clipInfo = this._globalClipMatrix;
            Vector4.tempVec4.setValue(clipInfo.a, clipInfo.b, clipInfo.c, clipInfo.d);
            shaderData.setVector(ShaderDefines2D.UNIFORM_CLIPMATDIR, Vector4.tempVec4);
            Vector2.TempVector2.setValue(clipInfo.tx, clipInfo.ty);
            shaderData.setVector2(ShaderDefines2D.UNIFORM_CLIPMATPOS, Vector2.TempVector2);
        }
        isStopMerge(submit) {
            return this.stopMerge || (submit.clipInfoID !== this._clipInfoID);
        }
        drawCallOptimize(enable) {
            this._charSubmitCache.enable(enable, this);
            return enable;
        }
        _drawToRender2D(submit) {
            let mesh = this._mesh;
            if (mesh.indexNum <= 0)
                return;
            let shaderValue = submit.shaderValue;
            let shaderdata = shaderValue.shaderData;
            switch (submit._key.blendShader) {
                case 1:
                case 3:
                case 5:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ONE);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE);
                    break;
                case 2:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_DST_COLOR);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
                    break;
                case 6:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ZERO);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_SRC_ALPHA);
                    break;
                case 7:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ZERO);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ZERO);
                    break;
                case 9:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_SRC_ALPHA);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
                    break;
                default:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ONE);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
            }
            if (submit._colorFiler) {
                var ft = submit._colorFiler;
                shaderValue.setFilter(ft);
                Matrix4x4.TEMPMatrix0.cloneByArray(ft._mat);
                shaderdata.setMatrix4x4(ShaderDefines2D.UNIFORM_COLORMAT, Matrix4x4.TEMPMatrix0);
                Vector4.tempVec4.setValue(ft._alpha[0], ft._alpha[1], ft._alpha[2], ft._alpha[3]);
                shaderdata.setVector(ShaderDefines2D.UNIFORM_COLORALPHA, Vector4.tempVec4);
            }
            this._drawMesh(mesh, 0, mesh.vertexNum, submit._startIdx, mesh.indexNum, submit.shaderValue, submit.material);
            this.stopMerge = false;
            this._curSubmit = SubmitBase.RENDERBASE;
            this._drawCount++;
        }
        _drawMesh(mesh, vboff, vertNum, iboff, indexNum, shaderValue, customMaterial) {
            if (!this._render2DManager._renderEnd) {
                this._render2DManager.render(Render2DSimple.rendercontext2D);
            }
            if (mesh.indexNum) {
                this._render2D.draw(mesh, vboff, vertNum * mesh.vertexDeclarition.vertexStride, iboff, indexNum * 2, shaderValue, customMaterial);
            }
            mesh.clearMesh();
            if (!shaderValue._needRelease) {
                shaderValue._needRelease = true;
                this._shaderValueNeedRelease.push(shaderValue);
            }
        }
        _inner_drawTexture(tex, imgid, x, y, width, height, m, uv, alpha, lastRender, color) {
            if (width <= 0 || height <= 0) {
                return false;
            }
            var preKey = this._curSubmit._key;
            uv = uv || tex._uv;
            if (preKey.submitType === SubmitBase.KEY_TRIANGLES && preKey.other === imgid) {
                var tv = this._drawTexToDrawTri_Vert;
                tv[0] = x;
                tv[1] = y;
                tv[2] = x + width, tv[3] = y, tv[4] = x + width, tv[5] = y + height, tv[6] = x, tv[7] = y + height;
                this._drawTriUseAbsMatrix = true;
                var tuv = this._tempUV;
                tuv[0] = uv[0];
                tuv[1] = uv[1];
                tuv[2] = uv[2];
                tuv[3] = uv[3];
                tuv[4] = uv[4];
                tuv[5] = uv[5];
                tuv[6] = uv[6];
                tuv[7] = uv[7];
                this.drawTriangles(tex, 0, 0, tv, tuv, this._drawTexToDrawTri_Index, m || this._curMat, alpha, null, 0xffffffff);
                this._drawTriUseAbsMatrix = false;
                return true;
            }
            var submit = this._curSubmit;
            var ops = lastRender ? this._charSubmitCache.getPos() : this._transedPoints;
            this.transformQuad(x, y, width || tex.width, height || tex.height, this._italicDeg, m || this._curMat, ops);
            if (this.drawTexAlign) {
                var round = Math.round;
                ops[0] = round(ops[0]);
                ops[1] = round(ops[1]);
                ops[2] = round(ops[2]);
                ops[3] = round(ops[3]);
                ops[4] = round(ops[4]);
                ops[5] = round(ops[5]);
                ops[6] = round(ops[6]);
                ops[7] = round(ops[7]);
                this.drawTexAlign = false;
            }
            var rgba = this._mixRGBandAlpha(color, this._alpha * alpha);
            if (lastRender) {
                this._charSubmitCache.add(this, tex, imgid, ops, uv, rgba);
                return true;
            }
            var sameKey = (imgid >= 0 && preKey.submitType === SubmitBase.KEY_DRAWTEXTURE && preKey.other === imgid) &&
                !this.isStopMerge(this._curSubmit) &&
                this._mesh.vertexNum + 4 < Context._MAXVERTNUM &&
                this._curSubmit.material == this._material;
            if (!sameKey) {
                this._drawToRender2D(this._curSubmit);
                this._mesh = this._meshQuatTex;
            }
            this._lastTex = tex;
            if (!sameKey) {
                let shaderValue = Value2D.create(exports.RenderSpriteData.Texture2D);
                this.fillShaderValue(shaderValue);
                shaderValue.textureHost = tex;
                this._curSubmit = submit = SubmitBase.create(this, this._mesh, shaderValue);
                submit._key.other = imgid;
                this._copyClipInfo(submit.shaderValue);
                submit.clipInfoID = this._clipInfoID;
            }
            this._mesh.addQuad(ops, uv, rgba, true);
            submit._numEle += 6;
            return true;
        }
        fillShaderValue(shaderValue) {
            shaderValue.size = new Vector2(this._width, this._height);
            this._copyClipInfo(shaderValue);
        }
        clipedOff(pt) {
            if (this._clipRect.width <= 0 || this._clipRect.height <= 0)
                return true;
            return false;
        }
        transformQuad(x, y, w, h, italicDeg, m, out) {
            var xoff = 0;
            if (italicDeg != 0) {
                xoff = Math.tan(italicDeg * Math.PI / 180) * h;
            }
            var maxx = x + w;
            var maxy = y + h;
            var tx = m.tx;
            var ty = m.ty;
            var ma = m.a;
            var mb = m.b;
            var mc = m.c;
            var md = m.d;
            var a0 = x + xoff;
            var a1 = y;
            var a2 = maxx + xoff;
            var a3 = y;
            var a4 = maxx;
            var a5 = maxy;
            var a6 = x;
            var a7 = maxy;
            if (m._bTransform) {
                out[0] = a0 * ma + a1 * mc + tx;
                out[1] = a0 * mb + a1 * md + ty;
                out[2] = a2 * ma + a3 * mc + tx;
                out[3] = a2 * mb + a3 * md + ty;
                out[4] = a4 * ma + a5 * mc + tx;
                out[5] = a4 * mb + a5 * md + ty;
                out[6] = a6 * ma + a7 * mc + tx;
                out[7] = a6 * mb + a7 * md + ty;
            }
            else {
                out[0] = a0 + tx;
                out[1] = a1 + ty;
                out[2] = a2 + tx;
                out[3] = a3 + ty;
                out[4] = a4 + tx;
                out[5] = a5 + ty;
                out[6] = a6 + tx;
                out[7] = a7 + ty;
            }
        }
        breakNextMerge() {
            this.stopMerge = true;
        }
        _repaintSprite() {
            this.sprite && this.sprite.repaint();
        }
        drawTextureWithTransform(tex, x, y, width, height, transform, tx, ty, alpha, blendMode, uv, color = 0xffffffff) {
            var oldcomp;
            var curMat = this._curMat;
            if (blendMode) {
                oldcomp = this.globalCompositeOperation;
                this.globalCompositeOperation = blendMode;
            }
            if (!transform) {
                this._drawTextureM(tex, x + tx, y + ty, width, height, curMat, alpha, uv, color);
                if (blendMode) {
                    this.globalCompositeOperation = oldcomp;
                }
                return;
            }
            tmpMat$1.a = transform.a;
            tmpMat$1.b = transform.b;
            tmpMat$1.c = transform.c;
            tmpMat$1.d = transform.d;
            tmpMat$1.tx = transform.tx + tx;
            tmpMat$1.ty = transform.ty + ty;
            tmpMat$1._bTransform = transform._bTransform;
            if (transform && curMat._bTransform) {
                Matrix.mul(tmpMat$1, curMat, tmpMat$1);
                transform = tmpMat$1;
                transform._bTransform = true;
            }
            else {
                tmpMat$1.tx += curMat.tx;
                tmpMat$1.ty += curMat.ty;
                transform = tmpMat$1;
            }
            this._drawTextureM(tex, x, y, width, height, transform, alpha, uv, color);
            if (blendMode)
                this.globalCompositeOperation = oldcomp;
        }
        drawGeo(geo, material, x, y) {
            this.drawLeftData();
            let mat = this._curMat;
            let buffer = this._matBuffer;
            buffer[0] = mat.a;
            buffer[1] = mat.b;
            buffer[2] = mat.tx + mat.a * x + mat.c * y;
            buffer[3] = mat.c;
            buffer[4] = mat.d;
            buffer[5] = mat.ty + mat.b * x + mat.d * y;
            material.setBuffer("u_NMatrix", buffer);
            material.setVector2("u_size", new Vector2(this._width, this._height));
            this._render2D.drawMesh(geo, material);
        }
        drawGeos(geo, elements, x, y) {
            this.drawLeftData();
            let mat = this._curMat;
            let buffer = this._matBuffer;
            buffer[0] = mat.a;
            buffer[1] = mat.b;
            buffer[2] = mat.tx + mat.a * x + mat.c * y;
            buffer[3] = mat.c;
            buffer[4] = mat.d;
            buffer[5] = mat.ty + mat.b * x + mat.d * y;
            for (let i = 0, n = elements.length; i < n; i++) {
                let material = elements[i][0];
                material.setBuffer("u_NMatrix", buffer);
                material.setVector2("u_size", new Vector2(this._width, this._height));
                geo.clearRenderParams();
                geo.setDrawElemenParams(elements[i][1], elements[i][2]);
                this._render2D.drawMesh(geo, material);
            }
        }
        drawTriangles(tex, x, y, vertices, uvs, indices, matrix, alpha, blendMode, colorNum = 0xffffffff) {
            if (alpha == null)
                alpha = 1.0;
            if (!tex._getSource()) {
                if (this.sprite) {
                    ILaya.systemTimer.callLater(this, this._repaintSprite);
                }
                return;
            }
            var oldcomp = null;
            if (blendMode) {
                oldcomp = this.globalCompositeOperation;
                this.globalCompositeOperation = blendMode;
            }
            var webGLImg = tex.bitmap;
            var preKey = this._curSubmit._key;
            var sameKey = preKey.submitType === SubmitBase.KEY_TRIANGLES &&
                preKey.other === webGLImg.id &&
                preKey.blendShader == this._nBlendType &&
                this._mesh.vertexNum + vertices.length / 2 < Context._MAXVERTNUM &&
                this._curSubmit.material == this._material;
            if (!sameKey) {
                this._drawToRender2D(this._curSubmit);
                this._mesh = this._meshTex;
            }
            if (!sameKey) {
                var submit = this._curSubmit = SubmitBase.create(this, this._mesh, Value2D.create(exports.RenderSpriteData.Texture2D));
                submit.shaderValue.textureHost = tex;
                this.fillShaderValue(submit.shaderValue);
                submit._key.submitType = SubmitBase.KEY_TRIANGLES;
                submit._key.other = webGLImg.id;
                this._copyClipInfo(submit.shaderValue);
                submit.clipInfoID = this._clipInfoID;
            }
            var rgba = this._mixRGBandAlpha(colorNum, this._alpha * alpha);
            if (!this._drawTriUseAbsMatrix) {
                if (!matrix) {
                    tmpMat$1.a = 1;
                    tmpMat$1.b = 0;
                    tmpMat$1.c = 0;
                    tmpMat$1.d = 1;
                    tmpMat$1.tx = x;
                    tmpMat$1.ty = y;
                }
                else {
                    tmpMat$1.a = matrix.a;
                    tmpMat$1.b = matrix.b;
                    tmpMat$1.c = matrix.c;
                    tmpMat$1.d = matrix.d;
                    tmpMat$1.tx = matrix.tx + x;
                    tmpMat$1.ty = matrix.ty + y;
                }
                Matrix.mul(tmpMat$1, this._curMat, tmpMat$1);
                this._mesh.addData(vertices, uvs, indices, tmpMat$1 || this._curMat, rgba, null);
            }
            else {
                this._mesh.addData(vertices, uvs, indices, matrix, rgba, null);
            }
            this._curSubmit._numEle += indices.length;
            if (blendMode) {
                this.globalCompositeOperation = oldcomp;
            }
        }
        transform(a, b, c, d, tx, ty) {
            SaveTransform.save(this);
            Matrix.mul(Matrix.TEMP.setTo(a, b, c, d, tx, ty), this._curMat, this._curMat);
            this._curMat._checkTransform();
        }
        rotate(angle) {
            SaveTransform.save(this);
            this._curMat.rotateEx(angle);
        }
        scale(scaleX, scaleY) {
            SaveTransform.save(this);
            this._curMat.scaleEx(scaleX, scaleY);
        }
        clipRect(x, y, width, height, escape) {
            SaveClipRect.save(this);
            if (this._clipRect == Context.MAXCLIPRECT) {
                this._clipRect = new Rectangle(x, y, width, height);
            }
            else {
                this._clipRect.width = width;
                this._clipRect.height = height;
                this._clipRect.x = x;
                this._clipRect.y = y;
            }
            this._clipID_Gen++;
            this._clipID_Gen %= 10000;
            this._clipInfoID = this._clipID_Gen;
            if (escape) {
                defaultClipMatrix.copyTo(this._globalClipMatrix);
                return;
            }
            var cm = this._globalClipMatrix;
            var minx = cm.tx;
            var miny = cm.ty;
            var maxx = minx + cm.a;
            var maxy = miny + cm.d;
            if (this._clipRect.width >= Const.MAX_CLIP_SIZE) {
                cm.a = cm.d = Const.MAX_CLIP_SIZE;
                cm.b = cm.c = cm.tx = cm.ty = 0;
            }
            else {
                if (this._curMat._bTransform) {
                    cm.tx = this._clipRect.x * this._curMat.a + this._clipRect.y * this._curMat.c + this._curMat.tx;
                    cm.ty = this._clipRect.x * this._curMat.b + this._clipRect.y * this._curMat.d + this._curMat.ty;
                    cm.a = this._clipRect.width * this._curMat.a;
                    cm.b = this._clipRect.width * this._curMat.b;
                    cm.c = this._clipRect.height * this._curMat.c;
                    cm.d = this._clipRect.height * this._curMat.d;
                }
                else {
                    cm.tx = this._clipRect.x + this._curMat.tx;
                    cm.ty = this._clipRect.y + this._curMat.ty;
                    cm.a = this._clipRect.width;
                    cm.b = cm.c = 0;
                    cm.d = this._clipRect.height;
                }
            }
            if (cm.a > 0 && cm.d > 0) {
                var cmaxx = cm.tx + cm.a;
                var cmaxy = cm.ty + cm.d;
                if (cmaxx <= minx || cmaxy <= miny || cm.tx >= maxx || cm.ty >= maxy) {
                    cm.a = -0.1;
                    cm.d = -0.1;
                }
                else {
                    if (cm.tx < minx) {
                        cm.a -= (minx - cm.tx);
                        cm.tx = minx;
                    }
                    if (cmaxx > maxx) {
                        cm.a -= (cmaxx - maxx);
                    }
                    if (cm.ty < miny) {
                        cm.d -= (miny - cm.ty);
                        cm.ty = miny;
                    }
                    if (cmaxy > maxy) {
                        cm.d -= (cmaxy - maxy);
                    }
                    if (cm.a <= 0)
                        cm.a = -0.1;
                    if (cm.d <= 0)
                        cm.d = -0.1;
                }
            }
        }
        startRender() {
            for (let sv of this._shaderValueNeedRelease) {
                sv.release();
                sv._needRelease = false;
            }
            this._shaderValueNeedRelease.length = 0;
            this._render2D.renderStart(this._clear, this._clearColor);
            this.clear();
        }
        endRender() {
            this.flush();
            if (!this._render2DManager._renderEnd) {
                this._render2DManager.render(Render2DSimple.rendercontext2D);
            }
            this._render2D.renderEnd();
            this._curSubmit = SubmitBase.RENDERBASE;
        }
        drawLeftData() {
            if (!this._render2DManager._renderEnd) {
                this._render2DManager.render(Render2DSimple.rendercontext2D);
            }
            this._drawToRender2D(this._curSubmit);
        }
        flush() {
            this.drawLeftData();
            this._clipID_Gen = 0;
            this._path && this._path.reset();
            this._curSubmit = SubmitBase.RENDERBASE;
            this._flushCnt++;
            if (this._flushCnt % 60 == 0 && this.isMain) {
                if (TextRender.textRenderInst) {
                    TextRender.textRenderInst.GC();
                }
            }
        }
        beginPath(convex = false) {
            this._getPath().beginPath(convex);
        }
        closePath() {
            this._path.closePath();
        }
        addPath(points, close, convex, dx, dy) {
            let sz = points.length;
            for (let i = 0; i < sz - 1; i += 2) {
                points[i] += dx;
                points[i + 1] += dy;
            }
            if (close && sz > 5 && (points[sz - 2] != points[0] || points[sz - 1] != points[1])) {
                points.push(points[0], points[1]);
            }
            this._getPath().push(points, convex);
        }
        fill() {
            var m = this._curMat;
            var tPath = this._getPath();
            var submit = this._curSubmit;
            var sameKey = (submit._key.submitType === SubmitBase.KEY_VG && submit._key.blendShader === this._nBlendType) &&
                !this.isStopMerge(submit) &&
                this._curSubmit.material == this._material;
            if (!sameKey) {
                this._drawToRender2D(submit);
                this._mesh = this._meshVG;
                this._curSubmit = this.addVGSubmit(this._mesh);
                this.fillShaderValue(this._curSubmit.shaderValue);
            }
            var rgba = this.mixRGBandAlpha(this.fillStyle.toInt());
            var curEleNum = 0;
            var idx;
            for (var i = 0, sz = tPath.paths.length; i < sz; i++) {
                var p = tPath.paths[i];
                var vertNum = p.path.length / 2;
                if (vertNum < 3 || (vertNum == 3 && !p.convex))
                    continue;
                var cpath = p.path.concat();
                var pi = 0;
                var xp, yp;
                var _x, _y;
                if (m._bTransform) {
                    for (pi = 0; pi < vertNum; pi++) {
                        xp = pi << 1;
                        yp = xp + 1;
                        _x = cpath[xp];
                        _y = cpath[yp];
                        cpath[xp] = m.a * _x + m.c * _y + m.tx;
                        cpath[yp] = m.b * _x + m.d * _y + m.ty;
                    }
                }
                else {
                    for (pi = 0; pi < vertNum; pi++) {
                        xp = pi << 1;
                        yp = xp + 1;
                        _x = cpath[xp];
                        _y = cpath[yp];
                        cpath[xp] = _x + m.tx;
                        cpath[yp] = _y + m.ty;
                    }
                }
                if (this._mesh.vertexNum + vertNum > Context._MAXVERTNUM) {
                    this._curSubmit._numEle += curEleNum;
                    curEleNum = 0;
                    this._mesh = new MeshVG();
                    this._curSubmit = this.addVGSubmit(this._mesh);
                    this.fillShaderValue(this._curSubmit.shaderValue);
                }
                var curvert = this._mesh.vertexNum;
                if (p.convex) {
                    var faceNum = vertNum - 2;
                    idx = new Array(faceNum * 3);
                    var idxpos = 0;
                    for (var fi = 0; fi < faceNum; fi++) {
                        idx[idxpos++] = curvert;
                        idx[idxpos++] = fi + 1 + curvert;
                        idx[idxpos++] = fi + 2 + curvert;
                    }
                }
                else {
                    idx = Earcut.earcut(cpath, null, 2);
                    if (curvert > 0) {
                        for (var ii = 0; ii < idx.length; ii++) {
                            idx[ii] += curvert;
                        }
                    }
                }
                this._mesh.addVertAndIBToMesh(cpath, rgba, idx);
                curEleNum += idx.length;
            }
            this._curSubmit._numEle += curEleNum;
        }
        addVGSubmit(mesh) {
            var submit = SubmitBase.create(this, mesh, Value2D.create(exports.RenderSpriteData.Primitive));
            this.fillShaderValue(submit.shaderValue);
            submit._key.submitType = SubmitBase.KEY_VG;
            this._copyClipInfo(submit.shaderValue);
            submit.clipInfoID = this._clipInfoID;
            return submit;
        }
        stroke() {
            if (this.lineWidth <= 0)
                return;
            var rgba = this.mixRGBandAlpha(this.strokeStyle._color.numColor);
            var tPath = this._getPath();
            var submit = this._curSubmit;
            var sameKey = (submit._key.submitType === SubmitBase.KEY_VG && submit._key.blendShader === this._nBlendType) &&
                !this.isStopMerge(submit) &&
                this._curSubmit.material == this._material;
            if (!sameKey) {
                this._drawToRender2D(this._curSubmit);
                this._mesh = this._meshVG;
                this._curSubmit = this.addVGSubmit(this._mesh);
                this.fillShaderValue(this._curSubmit.shaderValue);
            }
            var curEleNum = 0;
            for (var i = 0, sz = tPath.paths.length; i < sz; i++) {
                var p = tPath.paths[i];
                if (p.path.length <= 0)
                    continue;
                var idx = [];
                var vertex = [];
                var maxVertexNum = p.path.length * 2;
                if (maxVertexNum < 2)
                    continue;
                if (this._mesh.vertexNum + maxVertexNum > Context._MAXVERTNUM) {
                    this._curSubmit._numEle += curEleNum;
                    curEleNum = 0;
                    this._drawToRender2D(this._curSubmit);
                    this._mesh = new MeshVG();
                    this._curSubmit = this.addVGSubmit(this._mesh);
                    this.fillShaderValue(this._curSubmit.shaderValue);
                }
                BasePoly.createLine2(p.path, idx, this.lineWidth, this._mesh.vertexNum, vertex, p.loop);
                var ptnum = vertex.length / 2;
                var m = this._curMat;
                var pi = 0;
                var xp, yp;
                var _x, _y;
                if (m._bTransform) {
                    for (pi = 0; pi < ptnum; pi++) {
                        xp = pi << 1;
                        yp = xp + 1;
                        _x = vertex[xp];
                        _y = vertex[yp];
                        vertex[xp] = m.a * _x + m.c * _y + m.tx;
                        vertex[yp] = m.b * _x + m.d * _y + m.ty;
                    }
                }
                else {
                    for (pi = 0; pi < ptnum; pi++) {
                        xp = pi << 1;
                        yp = xp + 1;
                        _x = vertex[xp];
                        _y = vertex[yp];
                        vertex[xp] = _x + m.tx;
                        vertex[yp] = _y + m.ty;
                    }
                }
                this._mesh.addVertAndIBToMesh(vertex, rgba, idx);
                curEleNum += idx.length;
            }
            this._curSubmit._numEle += curEleNum;
        }
        moveTo(x, y) {
            var tPath = this._getPath();
            tPath.newPath();
            tPath._lastOriX = x;
            tPath._lastOriY = y;
            tPath.addPoint(x, y);
        }
        lineTo(x, y) {
            var tPath = this._getPath();
            if (Math.abs(x - tPath._lastOriX) < 1e-3 && Math.abs(y - tPath._lastOriY) < 1e-3)
                return;
            tPath._lastOriX = x;
            tPath._lastOriY = y;
            tPath.addPoint(x, y);
        }
        arcTo(x1, y1, x2, y2, r) {
            var i = 0;
            var x = 0, y = 0;
            var dx = this._path._lastOriX - x1;
            var dy = this._path._lastOriY - y1;
            var len1 = Math.sqrt(dx * dx + dy * dy);
            if (len1 <= 0.000001) {
                return;
            }
            var ndx = dx / len1;
            var ndy = dy / len1;
            var dx2 = x2 - x1;
            var dy2 = y2 - y1;
            var len22 = dx2 * dx2 + dy2 * dy2;
            var len2 = Math.sqrt(len22);
            if (len2 <= 0.000001) {
                return;
            }
            var ndx2 = dx2 / len2;
            var ndy2 = dy2 / len2;
            var odx = ndx + ndx2;
            var ody = ndy + ndy2;
            var olen = Math.sqrt(odx * odx + ody * ody);
            if (olen <= 0.000001) {
                return;
            }
            var nOdx = odx / olen;
            var nOdy = ody / olen;
            var alpha = Math.acos(nOdx * ndx + nOdy * ndy);
            var halfAng = Math.PI / 2 - alpha;
            len1 = r * Math.tan(halfAng);
            var ptx1 = len1 * ndx + x1;
            var pty1 = len1 * ndy + y1;
            var orilen = Math.sqrt(len1 * len1 + r * r);
            var orix = x1 + nOdx * orilen;
            var oriy = y1 + nOdy * orilen;
            var dir = ndx * ndy2 - ndy * ndx2;
            var fChgAng = 0;
            var sinx = 0.0;
            var cosx = 0.0;
            if (dir >= 0) {
                fChgAng = halfAng * 2;
                var fda = fChgAng / Context.SEGNUM;
                sinx = Math.sin(fda);
                cosx = Math.cos(fda);
            }
            else {
                fChgAng = -halfAng * 2;
                fda = fChgAng / Context.SEGNUM;
                sinx = Math.sin(fda);
                cosx = Math.cos(fda);
            }
            var lastx = this._path._lastOriX, lasty = this._path._lastOriY;
            var _x1 = ptx1, _y1 = pty1;
            if (Math.abs(_x1 - this._path._lastOriX) > 0.1 || Math.abs(_y1 - this._path._lastOriY) > 0.1) {
                x = _x1;
                y = _y1;
                lastx = _x1;
                lasty = _y1;
                this._path._lastOriX = x;
                this._path._lastOriY = y;
                this._path.addPoint(x, y);
            }
            var cvx = ptx1 - orix;
            var cvy = pty1 - oriy;
            for (i = 0; i < Context.SEGNUM; i++) {
                var cx = cvx * cosx + cvy * sinx;
                var cy = -cvx * sinx + cvy * cosx;
                x = cx + orix;
                y = cy + oriy;
                if (Math.abs(lastx - x) > 0.1 || Math.abs(lasty - y) > 0.1) {
                    this._path._lastOriX = x;
                    this._path._lastOriY = y;
                    this._path.addPoint(x, y);
                    lastx = x;
                    lasty = y;
                }
                cvx = cx;
                cvy = cy;
            }
        }
        arc(cx, cy, rx, ry, startAngle, endAngle, counterclockwise = false, b = true, minNum = 20) {
            if (startAngle > endAngle) {
                [startAngle, endAngle] = [endAngle, startAngle];
            }
            var sx = this.getMatScaleX();
            var sy = this.getMatScaleY();
            var sr = rx * (sx > sy ? sx : sy);
            var cl = 2 * Math.PI * sr;
            let ndivs = (Math.max(cl / 5, minNum)) | 0;
            let stepAng = Math.PI * 2 / ndivs;
            var tPath = this._getPath();
            let x = cx + Math.cos(startAngle) * rx;
            let y = cy + Math.sin(startAngle) * ry;
            if (x != this._path._lastOriX || y != this._path._lastOriY) {
                tPath.addPoint(x, y);
            }
            let curAng = Math.ceil(startAngle / stepAng) * stepAng;
            while (endAngle - curAng >= stepAng) {
                x = cx + Math.cos(curAng) * rx;
                y = cy + Math.sin(curAng) * ry;
                tPath.addPoint(x, y);
                curAng += stepAng;
            }
            x = cx + Math.cos(endAngle) * rx;
            y = cy + Math.sin(endAngle) * ry;
            if (x != this._path._lastOriX || y != this._path._lastOriY) {
                tPath.addPoint(x, y);
            }
        }
        quadraticCurveTo(cpx, cpy, x, y) {
            var tBezier = Bezier.I;
            var tArray = tBezier.getBezierPoints([this._path._lastOriX, this._path._lastOriY, cpx, cpy, x, y], 30, 2);
            for (var i = 0, n = tArray.length / 2; i < n; i++) {
                this.lineTo(tArray[i * 2], tArray[i * 2 + 1]);
            }
            this.lineTo(x, y);
        }
        mixRGBandAlpha(color) {
            return this._mixRGBandAlpha(color, this._alpha);
        }
        _mixRGBandAlpha(color, alpha) {
            if (alpha >= 1) {
                return color;
            }
            var a = ((color & 0xff000000) >>> 24);
            if (a != 0) {
                a *= alpha;
            }
            else {
                a = alpha * 255;
            }
            return (color & 0x00ffffff) | (a << 24);
        }
        strokeRect(x, y, width, height, parameterLineWidth) {
            if (this.lineWidth > 0) {
                var rgba = this.mixRGBandAlpha(this.strokeStyle._color.numColor);
                var hw = this.lineWidth / 2;
                this._fillRect(x - hw, y - hw, width + this.lineWidth, this.lineWidth, rgba);
                this._fillRect(x - hw, y - hw + height, width + this.lineWidth, this.lineWidth, rgba);
                this._fillRect(x - hw, y + hw, this.lineWidth, height - this.lineWidth, rgba);
                this._fillRect(x - hw + width, y + hw, this.lineWidth, height - this.lineWidth, rgba);
            }
        }
        drawParticle(x, y, pt) {
        }
        _getPath() {
            return this._path || (this._path = new Path());
        }
        get canvas() {
            return this._canvas;
        }
        _fillTexture_h(tex, imgid, uv, oriw, orih, x, y, w, color) {
            if (oriw <= 0)
                return;
            var stx = x;
            var num = Math.floor(w / oriw);
            var left = w % oriw;
            for (var i = 0; i < num; i++) {
                this._inner_drawTexture(tex, imgid, stx, y, oriw, orih, this._curMat, uv, 1, false, color);
                stx += oriw;
            }
            if (left > 0) {
                var du = uv[2] - uv[0];
                var uvr = uv[0] + du * (left / oriw);
                var tuv = tmpuv1;
                tuv[0] = uv[0];
                tuv[1] = uv[1];
                tuv[2] = uvr;
                tuv[3] = uv[3];
                tuv[4] = uvr;
                tuv[5] = uv[5];
                tuv[6] = uv[6];
                tuv[7] = uv[7];
                this._inner_drawTexture(tex, imgid, stx, y, left, orih, this._curMat, tuv, 1, false, color);
            }
        }
        _fillTexture_v(tex, imgid, uv, oriw, orih, x, y, h, color) {
            if (orih <= 0)
                return;
            var sty = y;
            var num = Math.floor(h / orih);
            var left = h % orih;
            for (var i = 0; i < num; i++) {
                this._inner_drawTexture(tex, imgid, x, sty, oriw, orih, this._curMat, uv, 1, false, color);
                sty += orih;
            }
            if (left > 0) {
                var dv = uv[7] - uv[1];
                var uvb = uv[1] + dv * (left / orih);
                var tuv = tmpuv1;
                tuv[0] = uv[0];
                tuv[1] = uv[1];
                tuv[2] = uv[2];
                tuv[3] = uv[3];
                tuv[4] = uv[4];
                tuv[5] = uvb;
                tuv[6] = uv[6];
                tuv[7] = uvb;
                this._inner_drawTexture(tex, imgid, x, sty, oriw, left, this._curMat, tuv, 1, false, color);
            }
        }
        drawTextureWithSizeGrid(tex, tx, ty, width, height, sizeGrid, gx, gy, color) {
            if (!tex._getSource())
                return;
            tx += gx;
            ty += gy;
            var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
            var top = sizeGrid[0];
            var left = sizeGrid[3];
            var right = sizeGrid[1];
            var bottom = sizeGrid[2];
            var repeat = sizeGrid[4];
            if (width == tex.width) {
                left = right = 0;
            }
            if (height == tex.height) {
                top = bottom = 0;
            }
            var d_top = top / h;
            var d_left = left / w;
            var d_right = right / w;
            var d_bottom = bottom / h;
            var imgid = tex.bitmap.id;
            var mat = this._curMat;
            var tuv = this._tempUV;
            var scale_x = 1;
            var scale_y = 1;
            if (left + right > width)
                scale_x = width / (left + right);
            if (top + bottom > height)
                scale_y = height / (top + bottom);
            left *= scale_x;
            right *= scale_x;
            top *= scale_y;
            bottom *= scale_y;
            var uvl = uv[0];
            var uvt = uv[1];
            var uvr = uv[4];
            var uvb = uv[5];
            var uvl_ = uvl;
            var uvt_ = uvt;
            var uvr_ = uvr;
            var uvb_ = uvb;
            if (left && top) {
                uvr_ = uvl + d_left;
                uvb_ = uvt + d_top;
                tuv[0] = uvl, tuv[1] = uvt, tuv[2] = uvr_, tuv[3] = uvt,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl, tuv[7] = uvb_;
                this._inner_drawTexture(tex, imgid, tx, ty, left, top, mat, tuv, 1, false, color);
            }
            if (right && top) {
                uvl_ = uvr - d_right;
                uvt_ = uvt;
                uvr_ = uvr;
                uvb_ = uvt + d_top;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                this._inner_drawTexture(tex, imgid, width - right + tx, 0 + ty, right, top, mat, tuv, 1, false, color);
            }
            if (left && bottom) {
                uvl_ = uvl;
                uvt_ = uvb - d_bottom;
                uvr_ = uvl + d_left;
                uvb_ = uvb;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                this._inner_drawTexture(tex, imgid, 0 + tx, height - bottom + ty, left, bottom, mat, tuv, 1, false, color);
            }
            if (right && bottom) {
                uvl_ = uvr - d_right;
                uvt_ = uvb - d_bottom;
                uvr_ = uvr;
                uvb_ = uvb;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                this._inner_drawTexture(tex, imgid, width - right + tx, height - bottom + ty, right, bottom, mat, tuv, 1, false, color);
            }
            if (top) {
                uvl_ = uvl + d_left;
                uvt_ = uvt;
                uvr_ = uvr - d_right;
                uvb_ = uvt + d_top;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                if (repeat) {
                    this._fillTexture_h(tex, imgid, tuv, tex.width - left - right, top, left + tx, ty, width - left - right, color);
                }
                else {
                    this._inner_drawTexture(tex, imgid, left + tx, ty, width - left - right, top, mat, tuv, 1, false, color);
                }
            }
            if (bottom) {
                uvl_ = uvl + d_left;
                uvt_ = uvb - d_bottom;
                uvr_ = uvr - d_right;
                uvb_ = uvb;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                if (repeat) {
                    this._fillTexture_h(tex, imgid, tuv, tex.width - left - right, bottom, left + tx, height - bottom + ty, width - left - right, color);
                }
                else {
                    this._inner_drawTexture(tex, imgid, left + tx, height - bottom + ty, width - left - right, bottom, mat, tuv, 1, false, color);
                }
            }
            if (left) {
                uvl_ = uvl;
                uvt_ = uvt + d_top;
                uvr_ = uvl + d_left;
                uvb_ = uvb - d_bottom;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                if (repeat) {
                    this._fillTexture_v(tex, imgid, tuv, left, tex.height - top - bottom, tx, top + ty, height - top - bottom, color);
                }
                else {
                    this._inner_drawTexture(tex, imgid, tx, top + ty, left, height - top - bottom, mat, tuv, 1, false, color);
                }
            }
            if (right) {
                uvl_ = uvr - d_right;
                uvt_ = uvt + d_top;
                uvr_ = uvr;
                uvb_ = uvb - d_bottom;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                if (repeat) {
                    this._fillTexture_v(tex, imgid, tuv, right, tex.height - top - bottom, width - right + tx, top + ty, height - top - bottom, color);
                }
                else {
                    this._inner_drawTexture(tex, imgid, width - right + tx, top + ty, right, height - top - bottom, mat, tuv, 1, false, color);
                }
            }
            uvl_ = uvl + d_left;
            uvt_ = uvt + d_top;
            uvr_ = uvr - d_right;
            uvb_ = uvb - d_bottom;
            tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
            if (repeat) {
                var tuvr = Context.tmpUVRect;
                tuvr[0] = uvl_;
                tuvr[1] = uvt_;
                tuvr[2] = uvr_ - uvl_;
                tuvr[3] = uvb_ - uvt_;
                this._fillTexture(tex, tex.width - left - right, tex.height - top - bottom, tuvr, left + tx, top + ty, width - left - right, height - top - bottom, 'repeat', 0, 0, color);
            }
            else {
                this._inner_drawTexture(tex, imgid, left + tx, top + ty, width - left - right, height - top - bottom, mat, tuv, 1, false, color);
            }
        }
    }
    Context._MAXVERTNUM = 65535;
    Context.MAXCLIPRECT = null;
    Context.SEGNUM = 32;
    Context._contextcount = 0;
    Context._textRender = null;
    Context.tmpUVRect = [0, 0, 0, 0];
    class ContextParams {
        constructor() {
            this.lineWidth = 1;
        }
        clear() {
            this.lineWidth = 1;
            this.textAlign = this.textBaseline = null;
        }
        make() {
            return this === ContextParams.DEFAULT ? new ContextParams() : this;
        }
    }

    class LayaGLQuickRunner {
        static __init__() {
            LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.TRANSFORM | SpriteConst.GRAPHICS] = LayaGLQuickRunner.alpha_transform_drawLayaGL;
            LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.GRAPHICS] = LayaGLQuickRunner.alpha_drawLayaGL;
            LayaGLQuickRunner.map[SpriteConst.TRANSFORM | SpriteConst.GRAPHICS] = LayaGLQuickRunner.transform_drawLayaGL;
            LayaGLQuickRunner.map[SpriteConst.TRANSFORM | SpriteConst.CHILDS] = LayaGLQuickRunner.transform_drawNodes;
            LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.TRANSFORM | SpriteConst.TEXTURE] = LayaGLQuickRunner.alpha_transform_drawTexture;
            LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.TEXTURE] = LayaGLQuickRunner.alpha_drawTexture;
            LayaGLQuickRunner.map[SpriteConst.TRANSFORM | SpriteConst.TEXTURE] = LayaGLQuickRunner.transform_drawTexture;
            LayaGLQuickRunner.map[SpriteConst.GRAPHICS | SpriteConst.CHILDS] = LayaGLQuickRunner.drawLayaGL_drawNodes;
        }
        static transform_drawTexture(sprite, context, x, y) {
            var tex = sprite.texture;
            context.save();
            context.transformByMatrix(sprite.transform, x, y);
            var width = sprite._isWidthSet ? sprite._width : tex.sourceWidth;
            var height = sprite._isHeightSet ? sprite._height : tex.sourceHeight;
            var wRate = width / tex.sourceWidth;
            var hRate = height / tex.sourceHeight;
            width = tex.width * wRate;
            height = tex.height * hRate;
            if (width <= 0 || height <= 0)
                return null;
            var px = -sprite.pivotX + tex.offsetX * wRate;
            var py = -sprite.pivotY + tex.offsetY * hRate;
            if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                context.drawTexture(tex, px, py, width, height);
            context.restore();
        }
        static alpha_drawTexture(sprite, context, x, y) {
            var style = sprite._style;
            var alpha = style.alpha;
            var tex = sprite.texture;
            if (alpha > 0.01 || sprite._needRepaint()) {
                var temp = context.globalAlpha;
                context.globalAlpha *= alpha;
                var width = sprite._isWidthSet ? sprite._width : tex.sourceWidth;
                var height = sprite._isHeightSet ? sprite._height : tex.sourceHeight;
                var wRate = width / tex.sourceWidth;
                var hRate = height / tex.sourceHeight;
                width = tex.width * wRate;
                height = tex.height * hRate;
                if (width <= 0 || height <= 0)
                    return null;
                var px = x - style.pivotX + tex.offsetX * wRate;
                var py = y - style.pivotY + tex.offsetY * hRate;
                if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                    context.drawTexture(tex, px, py, width, height);
                context.globalAlpha = temp;
            }
        }
        static alpha_transform_drawTexture(sprite, context, x, y) {
            var style = sprite._style;
            var alpha = style.alpha;
            var tex = sprite.texture;
            if (alpha > 0.01 || sprite._needRepaint()) {
                var temp = context.globalAlpha;
                context.globalAlpha *= alpha;
                context.save();
                context.transformByMatrix(sprite.transform, x, y);
                var width = sprite._isWidthSet ? sprite._width : tex.sourceWidth;
                var height = sprite._isHeightSet ? sprite._height : tex.sourceHeight;
                var wRate = width / tex.sourceWidth;
                var hRate = height / tex.sourceHeight;
                width = tex.width * wRate;
                height = tex.height * hRate;
                if (width <= 0 || height <= 0)
                    return null;
                var px = -style.pivotX + tex.offsetX * wRate;
                var py = -style.pivotY + tex.offsetY * hRate;
                if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                    context.drawTexture(tex, px, py, width, height);
                context.restore();
                context.globalAlpha = temp;
            }
        }
        static alpha_transform_drawLayaGL(sprite, context, x, y) {
            var style = sprite._style;
            var alpha = style.alpha;
            if (alpha > 0.01 || sprite._needRepaint()) {
                var temp = context.globalAlpha;
                context.globalAlpha *= alpha;
                context.save();
                context.transformByMatrix(sprite.transform, x, y);
                if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                    sprite._graphics && sprite._graphics._render(sprite, context, -style.pivotX, -style.pivotY);
                context.restore();
                context.globalAlpha = temp;
            }
        }
        static alpha_drawLayaGL(sprite, context, x, y) {
            var style = sprite._style;
            var alpha = style.alpha;
            if (alpha > 0.01 || sprite._needRepaint()) {
                var temp = context.globalAlpha;
                context.globalAlpha *= alpha;
                if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                    sprite._graphics && sprite._graphics._render(sprite, context, x - style.pivotX, y - style.pivotY);
                context.globalAlpha = temp;
            }
        }
        static transform_drawLayaGL(sprite, context, x, y) {
            var style = sprite._style;
            context.save();
            context.transformByMatrix(sprite.transform, x, y);
            if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                sprite._graphics && sprite._graphics._render(sprite, context, -style.pivotX, -style.pivotY);
            context.restore();
        }
        static transform_drawNodes(sprite, context, x, y) {
            var drawcallOptim = sprite._getBit(NodeFlags.DRAWCALL_OPTIMIZE) && context.drawCallOptimize(true);
            var style = sprite._style;
            context.save();
            context.transformByMatrix(sprite.transform, x, y);
            x = -style.pivotX;
            y = -style.pivotY;
            var childs = sprite._children, n = childs.length;
            let rect;
            let left, top, right, bottom, _x, _y;
            if (style.viewport) {
                rect = style.viewport;
                left = rect.x;
                top = rect.y;
                right = rect.right;
                bottom = rect.bottom;
            }
            for (let i = 0; i < n; ++i) {
                let ele = childs[i];
                let visFlag = ele._visible || ele._getBit(NodeFlags.DISABLE_VISIBILITY);
                if (rect && ((_x = ele._x) >= right ||
                    (_x + ele.width) <= left ||
                    (_y = ele._y) >= bottom ||
                    (_y + ele.height) <= top))
                    visFlag = false;
                if (visFlag)
                    ele.render(context, x, y);
            }
            context.restore();
            drawcallOptim && context.drawCallOptimize(false);
        }
        static drawLayaGL_drawNodes(sprite, context, x, y) {
            var drawcallOptim = sprite._getBit(NodeFlags.DRAWCALL_OPTIMIZE) && context.drawCallOptimize(true);
            let drawingToTexture = context._drawingToTexture;
            var style = sprite._style;
            x = x - style.pivotX;
            y = y - style.pivotY;
            if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                sprite._graphics && sprite._graphics._render(sprite, context, x, y);
            var childs = sprite._children, n = childs.length;
            let rect;
            let left, top, right, bottom, _x, _y;
            if (style.viewport) {
                rect = style.viewport;
                left = rect.x;
                top = rect.y;
                right = rect.right;
                bottom = rect.bottom;
            }
            let visFlag;
            for (let i = 0; i < n; ++i) {
                let ele = childs[i];
                if (drawingToTexture)
                    visFlag = ele._visible && !ele._getBit(NodeFlags.ESCAPE_DRAWING_TO_TEXTURE);
                else
                    visFlag = ele._visible || ele._getBit(NodeFlags.DISABLE_VISIBILITY);
                if (rect && ((_x = ele._x) >= right ||
                    (_x + ele.width) <= left ||
                    (_y = ele._y) >= bottom ||
                    (_y + ele.height) <= top))
                    visFlag = false;
                if (visFlag)
                    ele.render(context, x, y);
            }
            drawcallOptim && context.drawCallOptimize(false);
        }
    }
    LayaGLQuickRunner.map = [];

    var DefferTouchResContextID = 0;
    class DefferTouchResContext extends Context {
        constructor() {
            super(...arguments);
            this.cache = null;
            this.mustTouchRes = [];
            this.randomTouchRes = [];
            this.genID = DefferTouchResContextID++;
        }
        touchRes(res) {
            if (res.isRandomTouch) {
                this.randomTouchRes.push(res);
            }
            else {
                this.mustTouchRes.push(res);
            }
        }
    }

    class RenderToCache extends Render2D {
        constructor() {
            super(null);
            this.renderResult = [];
        }
        clone(out) {
            return null;
        }
        _createMesh() {
        }
        setVertexDecl(decl) {
            if (this._tex_vert_decl != decl) {
                this._tex_vert_decl = decl;
                this._createMesh();
            }
        }
        renderStart() {
        }
        draw(mesh2d, vboff, vblen, iboff, iblen, mtl) {
            this.setVertexDecl(mesh2d.vertexDeclarition);
            let submesh = new RenderObject2D(mesh2d, vboff, vblen, iboff, iblen, mtl);
            let clipPos = mtl.clipMatPos;
            let clipDir = mtl.clipMatDir;
            let clipMat = submesh.localClipMatrix;
            clipMat.a = clipDir.x;
            clipMat.b = clipDir.y;
            clipMat.c = clipDir.z;
            clipMat.d = clipDir.w;
            clipMat.tx = clipPos.x;
            clipMat.ty = clipPos.y;
            mtl.shaderData.addDefine(ShaderDefines2D.WORLDMAT);
            submesh.toNativeMesh();
            this.renderResult.push(submesh);
        }
        drawMesh(mesh, mtl) {
            throw new NotImplementedError();
        }
        drawElement(ele) {
            throw new NotImplementedError();
        }
        renderEnd() {
        }
    }

    class RenderObject2D {
        constructor(mesh, vboff, vblen, iboff, iblen, mtl) {
            this.localClipMatrix = new Matrix();
            this.vertexDeclarition = mesh.vertexDeclarition;
            this.vbBuffer = new ArrayBuffer(vblen);
            this.ibBuffer = new ArrayBuffer(iblen);
            (new Uint8Array(this.vbBuffer)).set(new Uint8Array(mesh.vbBuffer, vboff, vblen));
            (new Uint8Array(this.ibBuffer)).set(new Uint8Array(mesh.ibBuffer, iboff, iblen));
            this.mtl = mtl;
            this.vboff = 0;
            this.vblen = vblen;
            this.iboff = 0;
            this.iblen = iblen;
        }
        toNativeMesh() {
            let renderDevice = LayaGL.renderDeviceFactory;
            let geo = this.geo = renderDevice.createRenderGeometryElement(exports.MeshTopology.Triangles, exports.DrawType.DrawElement);
            let mesh = geo.bufferState = renderDevice.createBufferState();
            let vb = renderDevice.createVertexBuffer(exports.BufferUsage.Dynamic);
            vb.vertexDeclaration = this.vertexDeclarition;
            let ib = renderDevice.createIndexBuffer(exports.BufferUsage.Dynamic);
            mesh.applyState([vb], ib);
            geo.indexFormat = exports.IndexFormat.UInt16;
            vb.setDataLength(this.vblen);
            vb.setData(this.vbBuffer, this.vboff, 0, this.vblen);
            ib._setIndexDataLength(this.iblen);
            ib._setIndexData(new Uint16Array(this.ibBuffer, this.iboff, this.iblen / 2), 0);
            geo.clearRenderParams();
            geo.setDrawElemenParams(this.iblen / 2, 0);
            this.renderElement = LayaGL.render2DRenderPassFactory.createRenderElement2D();
            this.renderElement.geometry = geo;
            this.renderElement.value2DShaderData = this.mtl.shaderData;
            this.renderElement.subShader = this.mtl._defaultShader.getSubShaderAt(0);
            this.renderElement.materialShaderData = null;
        }
        destroyGPUResource() {
            this.renderElement && this.renderElement.destroy();
            let geo = this.geo;
            if (geo) {
                geo.bufferState._vertexBuffers[0].destroy();
                geo.bufferState._bindedIndexBuffer.destroy();
                geo.bufferState.destroy();
                geo.bufferState;
                geo.destroy();
                this.geo = null;
            }
        }
    }
    class Cache_Info {
        constructor() {
            this.page = null;
        }
        reset() {
            this.page && this.page.reset();
            this.page = null;
        }
    }
    function mergeClipMatrix(a, b, out) {
        let amaxx = a.tx + a.a;
        let amaxy = a.ty + a.d;
        let bmaxx = b.tx + b.a;
        let bmaxy = b.ty + b.d;
        let minx = out.tx = Math.max(a.tx, b.tx);
        let miny = out.ty = Math.max(a.ty, b.ty);
        out.b = out.c = 0;
        out.tx = minx;
        out.ty = miny;
        if (amaxx <= b.tx || amaxy <= b.ty || bmaxx <= a.tx || bmaxy <= a.ty) {
            out.a = -0.1;
            out.d = -0.1;
        }
        else {
            let maxx = Math.min(amaxx, bmaxx);
            let maxy = Math.min(amaxy, bmaxy);
            out.a = maxx - minx;
            out.d = maxy - miny;
        }
        return out;
    }
    class RenderPageContext {
        constructor(ctx, x, y) {
            this.alpha = 1;
            this.width = 0;
            this.height = 0;
            this.blend = 0;
            let mat = this.curMatrix = ctx._curMat.clone();
            mat.tx += mat.a * x + mat.c * y;
            mat.ty += mat.b * x + mat.d * y;
            this.alpha = ctx.globalAlpha;
            this.render2d = ctx.render2D;
            this.width = ctx.width;
            this.height = ctx.height;
            this.clipInfo = ctx._globalClipMatrix.clone();
            this.blend = ctx._nBlendType;
        }
        _copyClipInfo(shaderValue) {
            let clipInfo = this.clipInfo;
            var cm = shaderValue.clipMatDir;
            cm.x = clipInfo.a;
            cm.y = clipInfo.b;
            cm.z = clipInfo.c;
            cm.w = clipInfo.d;
            shaderValue.clipMatDir = cm;
            var cmp = shaderValue.clipMatPos;
            cmp.x = clipInfo.tx;
            cmp.y = clipInfo.ty;
            shaderValue.clipMatPos = cmp;
        }
        clipRect(rect) {
            let x = rect.x;
            let y = rect.y;
            let width = rect.width;
            let height = rect.height;
            var cm = this.clipInfo;
            var minx = cm.tx;
            var miny = cm.ty;
            var maxx = minx + cm.a;
            var maxy = miny + cm.d;
            if (width >= Const.MAX_CLIP_SIZE) {
                cm.a = cm.d = Const.MAX_CLIP_SIZE;
                cm.b = cm.c = cm.tx = cm.ty = 0;
            }
            else {
                let mat = this.curMatrix;
                if (mat._bTransform) {
                    cm.tx = x * mat.a + y * mat.c + mat.tx;
                    cm.ty = x * mat.b + y * mat.d + mat.ty;
                    cm.a = width * mat.a;
                    cm.b = width * mat.b;
                    cm.c = height * mat.c;
                    cm.d = height * mat.d;
                }
                else {
                    cm.tx = x + mat.tx;
                    cm.ty = y + mat.ty;
                    cm.a = width;
                    cm.b = cm.c = 0;
                    cm.d = height;
                }
            }
            if (cm.a > 0 && cm.d > 0) {
                var cmaxx = cm.tx + cm.a;
                var cmaxy = cm.ty + cm.d;
                if (cmaxx <= minx || cmaxy <= miny || cm.tx >= maxx || cm.ty >= maxy) {
                    cm.a = -0.1;
                    cm.d = -0.1;
                }
                else {
                    if (cm.tx < minx) {
                        cm.a -= (minx - cm.tx);
                        cm.tx = minx;
                    }
                    if (cmaxx > maxx) {
                        cm.a -= (cmaxx - maxx);
                    }
                    if (cm.ty < miny) {
                        cm.d -= (miny - cm.ty);
                        cm.ty = miny;
                    }
                    if (cmaxy > maxy) {
                        cm.d -= (cmaxy - maxy);
                    }
                    if (cm.a <= 0)
                        cm.a = -0.1;
                    if (cm.d <= 0)
                        cm.d = -0.1;
                }
            }
        }
        setBlendMode(blend) {
            this.blend = BlendMode.TOINT[blend];
        }
        _applyBlend(shaderValue) {
            let shaderdata = shaderValue.shaderData;
            switch (this.blend) {
                case 1:
                case 3:
                case 5:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ONE);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE);
                    break;
                case 2:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_DST_COLOR);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
                    break;
                case 6:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ZERO);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_SRC_ALPHA);
                    break;
                case 7:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ZERO);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ZERO);
                    break;
                case 9:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_SRC_ALPHA);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
                    break;
                default:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ONE);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
            }
        }
    }
    class CachePage {
        constructor() {
            this.sprite = null;
            this.meshes = null;
            this.defferTouchRes = null;
            this.defferTouchResRand = null;
            this.children = null;
        }
        reset() {
            this.clearGPUObject();
        }
        clearGPUObject() {
            if (this.meshes) {
                this.meshes.forEach(m => {
                    m.destroyGPUResource();
                });
            }
        }
        render(sprite, context, isRoot) {
            let spriteTrans = sprite.transform;
            let curMat = context.curMatrix;
            if (isRoot) {
                curMat.copyTo(worldMat);
            }
            else {
                let x = sprite._x;
                let y = sprite._y;
                if (spriteTrans) {
                    spriteTrans.copyTo(tmpMat);
                    tmpMat.tx = x;
                    tmpMat.ty = y;
                    Matrix.mul(tmpMat, curMat, worldMat);
                }
                else {
                    worldMat.a = curMat.a;
                    worldMat.b = curMat.b;
                    worldMat.c = curMat.c;
                    worldMat.d = curMat.d;
                    worldMat.tx = curMat.a * x + curMat.c * y + curMat.tx;
                    worldMat.ty = curMat.b * x + curMat.d * y + curMat.ty;
                }
                context.alpha *= sprite.alpha;
                if (sprite.blendMode) {
                    context.setBlendMode(sprite.blendMode);
                }
            }
            vec21.setValue(context.width, context.height);
            let wMat4 = tmpMat4;
            let mate = wMat4.elements;
            mate[0] = worldMat.a;
            mate[1] = worldMat.b;
            mate[4] = worldMat.c;
            mate[5] = worldMat.d;
            mate[12] = worldMat.tx;
            mate[13] = worldMat.ty;
            this.meshes.forEach(renderinfo => {
                let render = context.render2d;
                let curMtl = renderinfo.mtl;
                if (curMtl.textureHost instanceof TextTexture) {
                    curMtl.textureHost.touchTexture();
                }
                curMtl.size = vec21;
                let clipMat = renderinfo.localClipMatrix;
                if (clipMat.a == Const.MAX_CLIP_SIZE && clipMat.d == Const.MAX_CLIP_SIZE) {
                    context.clipInfo.copyTo(tmpMat1);
                }
                else {
                    Matrix.mul(clipMat, worldMat, tmpMat1);
                    mergeClipMatrix(context.clipInfo, tmpMat1, tmpMat1);
                }
                let clipDir = curMtl.clipMatDir;
                let clipPos = curMtl.clipMatPos;
                clipDir.x = tmpMat1.a;
                clipDir.y = tmpMat1.b;
                clipDir.z = tmpMat1.c;
                clipDir.w = tmpMat1.d;
                curMtl.clipMatDir = clipDir;
                clipPos.x = tmpMat1.tx;
                clipPos.y = tmpMat1.ty;
                curMtl.clipMatPos = clipPos;
                curMtl.mmat = wMat4;
                curMtl.vertAlpha = context.alpha;
                context._applyBlend(curMtl);
                render.drawElement(renderinfo.renderElement);
            });
            this.defferTouchRes.forEach(res => { res.touch(); });
            this.defferTouchResRand.forEach(res => res.touch());
            this.children && this.children.forEach(sp => {
                let oldMat = context.curMatrix.clone();
                let oldAlpha = context.alpha;
                let parentCacheInfo = sp.parent._cacheStyle.cacheInfo;
                let offmat = parentCacheInfo.mat;
                Matrix.mul(offmat, oldMat, context.curMatrix);
                context.alpha *= parentCacheInfo.alpha;
                let oldBlend = context.blend;
                if (parentCacheInfo.blend != undefined) {
                    context.setBlendMode(parentCacheInfo.blend);
                }
                let oldClipMatrix = context.clipInfo.clone();
                let clipMat = parentCacheInfo.clipMatrix;
                Matrix.mul(clipMat, context.curMatrix, tmpMat1);
                mergeClipMatrix(context.clipInfo, tmpMat1, context.clipInfo);
                sp._cacheStyle.cacheInfo.page.render(sp, context, false);
                context.curMatrix = oldMat;
                context.alpha = oldAlpha;
                context.blend = oldBlend;
                context.clipInfo = oldClipMatrix;
            });
        }
    }
    var vec21 = new Vector2();
    class SpriteCache {
        static curMatSubSpriteMat(sprite, curMat, outMat) {
            if (sprite._renderType & SpriteConst.TRANSFORM) {
                sprite.transform.copyTo(invMat);
                invMat.tx = sprite._x;
                invMat.ty = sprite._y;
                invMat.invert();
                Matrix.mul(invMat, curMat, outMat);
            }
            else {
                curMat.copyTo(outMat);
                let cx = -sprite._x;
                let cy = -sprite._y;
                outMat.tx += (outMat.a * cx + outMat.c * cy);
                outMat.ty += (outMat.b * cx + outMat.d * cy);
            }
            return outMat;
        }
        static renderCacheAsNormal(context, sprite, next, x, y) {
            let rebuild = false;
            var cache = sprite._getCacheStyle().cacheInfo.page;
            if (!cache || sprite._needRepaint() || ILaya.stage.isGlobalRepaint()) {
                if (sprite.alpha <= 1e-6) {
                    sprite.alpha = 0.001;
                }
                rebuild = true;
                if (context instanceof DefferTouchResContext) {
                    let parentPage = context.cache;
                    if (!parentPage.children) {
                        parentPage.children = [sprite];
                    }
                    else if (parentPage.children.indexOf(sprite) < 0) {
                        parentPage.children.push(sprite);
                    }
                    let parentNode = sprite.parent;
                    let parentCacheInfo = parentNode._cacheStyle.cacheInfo;
                    parentCacheInfo.page = parentPage;
                    if (context.genID != parentCacheInfo.contextID) {
                        parentCacheInfo.contextID = context.genID;
                        let curMat = context._curMat.clone();
                        if (x != 0 || y != 0) {
                            curMat.tx += x * curMat.a + y * curMat.c;
                            curMat.ty += x * curMat.b + y * curMat.d;
                        }
                        parentCacheInfo.mat = SpriteCache.curMatSubSpriteMat(sprite, curMat, curMat);
                        parentCacheInfo.alpha = context.globalAlpha / sprite.alpha;
                        let pageRootSprite = parentPage.sprite;
                        if (parentNode.blendMode) {
                            parentCacheInfo.blend = parentNode.blendMode;
                        }
                        else {
                            let curNode = parentNode;
                            while (curNode != pageRootSprite) {
                                curNode = curNode.parent;
                                if (curNode.blendMode) {
                                    parentCacheInfo.blend = curNode.blendMode;
                                    break;
                                }
                            }
                        }
                        parentCacheInfo.clipMatrix = context._globalClipMatrix.clone();
                    }
                }
                cache = sprite._cacheStyle.cacheInfo.page = new CachePage();
                cache.sprite = sprite;
                Stat.canvasNormal++;
                let ctx = new DefferTouchResContext();
                ctx.cache = cache;
                let renderer = new RenderToCache();
                ctx.render2D = renderer;
                ctx.startRender();
                next._fun(sprite, ctx, 0, 0);
                ctx.endRender();
                cache.meshes = renderer.renderResult;
                cache.defferTouchRes = ctx.mustTouchRes;
                cache.defferTouchResRand = ctx.randomTouchRes;
                sprite.once(Event.REMOVED, () => {
                    cache = sprite._cacheStyle.cacheInfo.page;
                    cache.reset();
                });
            }
            if (!(context instanceof DefferTouchResContext)) {
                let ctx = new RenderPageContext(context, x, y);
                cache.render(sprite, ctx, true);
            }
            return rebuild;
        }
    }
    var worldMat = new Matrix;
    var invMat = new Matrix;
    var tmpMat = new Matrix;
    var tmpMat4 = new Matrix4x4;
    var tmpMat1 = new Matrix();

    const INIT = 0x11111;
    class RenderSprite {
        static __init__() {
            LayaGLQuickRunner.__init__();
            var initRender = new RenderSprite(INIT, null);
            let len = RenderSprite.renders.length = SpriteConst.CHILDS * 2;
            for (let i = 0; i < len; i++)
                RenderSprite.renders[i] = initRender;
            RenderSprite.renders[0] = new RenderSprite(0, null);
        }
        static _initRenderFun(sprite, context, x, y) {
            var type = sprite._renderType;
            var r = RenderSprite.renders[type] = RenderSprite._getTypeRender(type);
            r._fun(sprite, context, x, y);
        }
        static _getTypeRender(type) {
            if (LayaGLQuickRunner.map[type] && LayaEnv.isPlaying)
                return new RenderSprite(type, null);
            var rst = null;
            var tType = SpriteConst.CHILDS;
            while (tType > 0) {
                if (tType & type)
                    rst = new RenderSprite(tType, rst);
                tType = tType >> 1;
            }
            return rst;
        }
        constructor(type, next) {
            this._spriteRect_TextureSpace = new Rectangle();
            this._maskRect_TextureSpace = new Rectangle();
            if (LayaGLQuickRunner.map[type] && LayaEnv.isPlaying) {
                this._fun = LayaGLQuickRunner.map[type];
                this._next = RenderSprite.NORENDER;
                return;
            }
            this._next = next || RenderSprite.NORENDER;
            switch (type) {
                case 0:
                    this._fun = this._no;
                    return;
                case SpriteConst.ALPHA:
                    this._fun = this._alpha;
                    return;
                case SpriteConst.TRANSFORM:
                    this._fun = this._transform;
                    return;
                case SpriteConst.BLEND:
                    this._fun = this._blend;
                    return;
                case SpriteConst.CANVAS:
                    this._fun = this._canvas;
                    return;
                case SpriteConst.MASK:
                    this._fun = this._mask;
                    return;
                case SpriteConst.CLIP:
                    this._fun = this._clip;
                    return;
                case SpriteConst.GRAPHICS:
                    this._fun = this._graphics;
                    return;
                case SpriteConst.CHILDS:
                    this._fun = this._children;
                    return;
                case SpriteConst.CUSTOM:
                    this._fun = this._custom;
                    return;
                case SpriteConst.TEXTURE:
                    this._fun = this._texture;
                    return;
                case SpriteConst.FILTERS:
                    this._fun = Filter._filter;
                    return;
                case SpriteConst.HITAREA:
                    this._fun = this._hitarea;
                    return;
                case SpriteConst.RENDERNODE2D:
                    this._fun = this._renderNode2D;
                    break;
                case INIT:
                    this._fun = RenderSprite._initRenderFun;
                    return;
            }
        }
        _renderNode2D(sprite, context, x, y) {
            if (sprite._renderNode.addCMDCall)
                sprite._renderNode.addCMDCall(context, x, y);
            context.drawLeftData();
            if (context._render2DManager._renderEnd) {
                context._render2DManager._renderEnd = false;
                context._render2DManager.addRenderObject(sprite._renderNode);
            }
            else {
                context._render2DManager.addRenderObject(sprite._renderNode);
            }
            if (this._next != RenderSprite.NORENDER)
                this._next._fun(sprite, context, x, y);
        }
        _no(sprite, context, x, y) {
        }
        _custom(sprite, context, x, y) {
            sprite.customRender(context, x, y);
            this._next._fun(sprite, context, 0, 0);
        }
        _clip(sprite, context, x, y) {
            let next = this._next;
            if (next == RenderSprite.NORENDER)
                return;
            if (sprite._getBit(NodeFlags.DISABLE_INNER_CLIPPING) && !context._drawingToTexture) {
                next._fun(sprite, context, x, y);
                return;
            }
            let r = sprite._style.scrollRect;
            let width = r.width;
            let height = r.height;
            if (width === 0)
                width = 0.001;
            if (height === 0)
                height = 0.001;
            context.save();
            context.clipRect(x, y, width, height);
            next._fun(sprite, context, x - r.x, y - r.y);
            context.restore();
        }
        _texture(sprite, context, x, y) {
            if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR)) {
                var tex = sprite.texture;
                if (tex._getSource()) {
                    var width = sprite._isWidthSet ? sprite._width : tex.sourceWidth;
                    var height = sprite._isHeightSet ? sprite._height : tex.sourceHeight;
                    var wRate = width / tex.sourceWidth;
                    var hRate = height / tex.sourceHeight;
                    width = tex.width * wRate;
                    height = tex.height * hRate;
                    if (width > 0 && height > 0) {
                        let px = x - sprite.pivotX + tex.offsetX * wRate;
                        let py = y - sprite.pivotY + tex.offsetY * hRate;
                        context._material = sprite.graphics.material;
                        context.drawTexture(tex, px, py, width, height, 0xffffffff);
                        context._material = null;
                    }
                }
            }
            if (this._next != RenderSprite.NORENDER)
                this._next._fun(sprite, context, x, y);
        }
        _graphics(sprite, context, x, y) {
            if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR)) {
                let style = sprite._style;
                let g = sprite._graphics;
                g && g._render(sprite, context, x - style.pivotX, y - style.pivotY);
            }
            if (this._next != RenderSprite.NORENDER)
                this._next._fun(sprite, context, x, y);
        }
        _hitarea(sprite, context, x, y) {
            if (!context._drawingToTexture && sprite.hitArea) {
                var style = sprite._style;
                var g = sprite.hitArea._hit;
                var temp = context.globalAlpha;
                context.globalAlpha *= 0.5;
                g && g._render(sprite, context, x - style.pivotX, y - style.pivotY);
                g = sprite.hitArea._unHit;
                g && g._render(sprite, context, x - style.pivotX, y - style.pivotY);
                context.globalAlpha = temp;
            }
            if (this._next != RenderSprite.NORENDER)
                this._next._fun(sprite, context, x, y);
        }
        _alpha(sprite, context, x, y) {
            var style = sprite._style;
            var alpha = style.alpha;
            if (alpha > 0.01 || sprite._needRepaint()) {
                var temp = context.globalAlpha;
                context.globalAlpha *= alpha;
                if (this._next != RenderSprite.NORENDER)
                    this._next._fun(sprite, context, x, y);
                context.globalAlpha = temp;
            }
        }
        _transform(sprite, context, x, y) {
            var transform = sprite.transform, _next = this._next;
            if (transform && _next != RenderSprite.NORENDER) {
                context.save();
                context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx + x, transform.ty + y);
                _next._fun(sprite, context, 0, 0);
                context.restore();
            }
            else {
                if (_next != RenderSprite.NORENDER)
                    _next._fun(sprite, context, x, y);
            }
        }
        _children(sprite, context, x, y) {
            let style = sprite._style;
            let childs = sprite._children, n = childs.length;
            x = x - sprite.pivotX;
            y = y - sprite.pivotY;
            let textLastRender = sprite._getBit(NodeFlags.DRAWCALL_OPTIMIZE) && context.drawCallOptimize(true);
            let drawingToTexture = context._drawingToTexture;
            let rect;
            let left, top, right, bottom, x2, y2;
            if (style.viewport) {
                rect = style.viewport;
                left = rect.x;
                top = rect.y;
                right = rect.right;
                bottom = rect.bottom;
            }
            for (let i = 0; i < n; ++i) {
                let ele = childs[i];
                let visFlag;
                if (drawingToTexture)
                    visFlag = ele._visible && !ele._getBit(NodeFlags.ESCAPE_DRAWING_TO_TEXTURE);
                else
                    visFlag = ele._visible || ele._getBit(NodeFlags.DISABLE_VISIBILITY);
                if (visFlag) {
                    if (rect && ((x2 = ele._x) >= right || (x2 + ele.width) <= left || (y2 = ele._y) >= bottom || (y2 + ele.height) <= top))
                        visFlag = false;
                    else if (sprite._cacheStyle.mask == ele && (!ele._getBit(NodeFlags.DISABLE_VISIBILITY) || drawingToTexture))
                        visFlag = false;
                }
                if (visFlag) {
                    if (ele._getBit(NodeFlags.DISABLE_OUTER_CLIPPING))
                        context.clipRect(0, 0, 1, 1, true);
                    ele.render(context, x, y);
                }
            }
            textLastRender && context.drawCallOptimize(false);
        }
        _renderNextToCacheRT(sprite, context, marginLeft = 0, marginTop = 0, marginRight = 0, marginBottom = 0) {
            var _cacheStyle = sprite._getCacheStyle();
            if (sprite._needRepaint() || !_cacheStyle.renderTexture || ILaya.stage.isGlobalRepaint()) {
                if (_cacheStyle.renderTexture) {
                    _cacheStyle.renderTexture.destroy();
                }
                let scaleInfo = sprite._cacheStyle._calculateCacheRect(sprite, "bitmap", 0, 0);
                let tRec = _cacheStyle.cacheRect;
                if (tRec.width <= 0 || tRec.height <= 0) {
                    _cacheStyle.renderTexture = null;
                    return false;
                }
                Stat.canvasBitmap++;
                let w = tRec.width * scaleInfo.x + marginLeft + marginRight;
                let h = tRec.height * scaleInfo.y + marginTop + marginBottom;
                let rt = new RenderTexture2D(w, h, exports.RenderTargetFormat.R8G8B8A8);
                let ctx = new Context();
                ctx.copyState(context);
                ctx.size(w, h);
                ctx.clearBG(0, 0, 0, 0);
                ctx.render2D = new Render2DSimple(rt);
                let tempY = Render2DSimple.rendercontext2D.invertY;
                Render2DSimple.rendercontext2D.invertY = true;
                ctx.startRender();
                tRec.x -= marginLeft;
                tRec.y -= marginTop;
                this._next._fun(sprite, ctx, -tRec.x, -tRec.y);
                ctx.endRender();
                Render2DSimple.rendercontext2D.invertY = tempY;
                ctx.render2D.setRenderTarget(context.render2D.out);
                ctx.destroy();
                _cacheStyle.renderTexture = rt;
                return true;
            }
            return false;
        }
        _canvas(sprite, context, x, y) {
            var _cacheStyle = sprite._cacheStyle;
            var _next = this._next;
            if (!context._drawingToTexture && _cacheStyle.mask && _cacheStyle.mask._getBit(NodeFlags.DISABLE_VISIBILITY)) {
                _next._fun(sprite, context, x, y);
                return;
            }
            let isbmp = sprite.cacheAs === 'bitmap';
            if (isbmp) {
                context.drawLeftData();
                this._renderNextToCacheRT(sprite, context);
                var tRec = _cacheStyle.cacheRect;
                context._material = sprite.graphics.material;
                let rt = _cacheStyle.renderTexture;
                rt && context._drawRenderTexture(rt, x + tRec.x, y + tRec.y, rt.width, rt.height, null, 1, [0, 1, 1, 1, 1, 0, 0, 0]);
                context._material = null;
            }
            else {
                if (!RenderSprite.cacheNormalEnable) {
                    _next._fun(sprite, context, x, y);
                    return;
                }
                else {
                    context.drawLeftData();
                    SpriteCache.renderCacheAsNormal(context, sprite, this._next, x, y);
                }
            }
        }
        static RenderToRenderTexture(sprite, context, x, y, renderTexture = null, isDrawRenderRect = true) {
            let scaleInfo = sprite._getCacheStyle()._calculateCacheRect(sprite, "bitmap", 0, 0);
            this._transBound(sprite._cacheStyle.cacheRect, sprite.transform);
            let tRec = sprite._cacheStyle.cacheRect;
            let ctx = new Context();
            ctx._drawingToTexture = true;
            context && ctx.copyState(context);
            let rt = renderTexture;
            if (rt) {
                ctx.size(rt.width, rt.height);
                ctx.clearBG(RenderTexture2D._clearColor.r, RenderTexture2D._clearColor.g, RenderTexture2D._clearColor.b, RenderTexture2D._clearColor.a);
            }
            else {
                let w = tRec.width * scaleInfo.x + (isDrawRenderRect ? 0 : tRec.x);
                let h = tRec.height * scaleInfo.y + (isDrawRenderRect ? 0 : tRec.y);
                rt = new RenderTexture2D(w, h, exports.RenderTargetFormat.R8G8B8A8);
                ctx.size(w, h);
                ctx.clearBG(0, 0, 0, 0);
            }
            ctx.render2D = ctx.render2D.clone(rt);
            ctx.startRender();
            if (isDrawRenderRect) {
                sprite.render(ctx, x - sprite.x - tRec.x, y - sprite.y - tRec.y);
            }
            else {
                sprite.render(ctx, x - sprite.x, y - sprite.y);
            }
            ctx.endRender();
            ctx._drawingToTexture = false;
            context && ctx.render2D.setRenderTarget(context.render2D.out);
            ctx.destroy();
            return rt;
        }
        static RenderToCacheTexture(sprite, context, x, y, isDrawRenderRect = true) {
            var _cacheStyle = sprite._getCacheStyle();
            if (sprite._needRepaint() || !_cacheStyle.renderTexture || ILaya.stage.isGlobalRepaint()) {
                if (_cacheStyle.renderTexture) {
                    _cacheStyle.renderTexture.destroy();
                }
                _cacheStyle.renderTexture = RenderSprite.RenderToRenderTexture(sprite, context, x, y, null, isDrawRenderRect);
                return true;
            }
            return false;
        }
        _blend(sprite, context, x, y) {
            var style = sprite._style;
            context.save();
            context.globalCompositeOperation = style.blendMode;
            this._next._fun(sprite, context, x, y);
            context.restore();
        }
        static _transBound(bound, trans) {
            if (!trans || !bound)
                return;
            let a = trans.a, b = trans.b, c = trans.c, d = trans.d;
            let x1 = bound.x;
            let y1 = bound.y;
            let x2 = x1 + bound.width;
            let y2 = y1 + bound.height;
            let tx1 = x1 * a;
            let tx2 = x2 * a;
            let ty1 = y1 * c;
            let ty2 = y2 * c;
            let px1 = x1 * b;
            let px2 = x2 * b;
            let py1 = y1 * d;
            let py2 = y2 * d;
            let minX = Math.min(tx1 + ty1, tx1 + ty2, tx2 + ty1, tx2 + ty2);
            let maxX = Math.max(tx1 + ty1, tx1 + ty2, tx2 + ty1, tx2 + ty2);
            let minY = Math.min(px1 + py1, px1 + py2, px2 + py1, px2 + py2);
            let maxY = Math.max(px1 + py1, px1 + py2, px2 + py1, px2 + py2);
            bound.setTo(minX, minY, maxX - minX, maxY - minY);
        }
        _mask(sprite, ctx, x, y) {
            let mask = sprite.mask;
            if (mask._getBit(NodeFlags.DISABLE_VISIBILITY) && !ctx._drawingToTexture) {
                if (this._next != RenderSprite.NORENDER)
                    this._next._fun(sprite, ctx, x, y);
                return;
            }
            let cache = sprite._getCacheStyle();
            if (sprite._needRepaint() || !cache.renderTexture || cache.renderTexture.destroyed || ILaya.stage.isGlobalRepaint()) {
                if (cache.renderTexture) {
                    cache.renderTexture.destroy();
                }
                sprite._cacheStyle._calculateCacheRect(sprite, "bitmap", 0, 0);
                let spRect_TS = this._spriteRect_TextureSpace.copyFrom(cache.cacheRect);
                if (spRect_TS.width <= 0 || spRect_TS.height <= 0)
                    return;
                spRect_TS.x += sprite.pivotX;
                spRect_TS.y += sprite.pivotY;
                let maskcache = mask._getCacheStyle();
                maskcache._calculateCacheRect(mask, "bitmap", 0, 0);
                RenderSprite._transBound(maskcache.cacheRect, mask.transform);
                let maskRect_TS = this._maskRect_TextureSpace.copyFrom(maskcache.cacheRect);
                maskRect_TS.x += mask._x;
                maskRect_TS.y += mask._y;
                let x1 = Math.max(spRect_TS.x, maskRect_TS.x);
                let y1 = Math.max(spRect_TS.y, maskRect_TS.y);
                let x2 = Math.min(spRect_TS.x + spRect_TS.width, maskRect_TS.x + maskRect_TS.width);
                let y2 = Math.min(spRect_TS.y + spRect_TS.height, maskRect_TS.y + maskRect_TS.height);
                let width1 = x2 - x1;
                let height1 = y2 - y1;
                if (width1 <= 0 || height1 <= 0)
                    return;
                RenderSprite.RenderToCacheTexture(mask, ctx, 0, 0);
                let rt = new RenderTexture2D(width1, height1, exports.RenderTargetFormat.R8G8B8A8);
                let ctx1 = new Context();
                ctx1.clearBG(0, 0, 0, 0);
                ctx1.size(width1, height1);
                ctx1.render2D = new Render2DSimple(rt);
                ctx1.startRender();
                ctx1._drawingToTexture = ctx._drawingToTexture;
                this._next._fun(sprite, ctx1, sprite.pivotX - x1, sprite.pivotY - y1);
                ctx1._drawingToTexture = false;
                let maskRT = maskcache.renderTexture;
                ctx1.globalCompositeOperation = 'mask';
                ctx1._drawRenderTexture(maskRT, maskRect_TS.x - x1, maskRect_TS.y - y1, maskRect_TS.width, maskRect_TS.height, null, 1, [0, 1, 1, 1, 1, 0, 0, 0]);
                ctx1.endRender();
                ctx1.render2D.setRenderTarget(ctx.render2D.out);
                ctx1.destroy();
                cache.renderTexture = rt;
                cache.cacheRect.x = x1 - sprite.pivotX;
                cache.cacheRect.y = y1 - sprite.pivotY;
                cache.cacheRect.width = rt.width;
                cache.cacheRect.height = rt.height;
            }
            let tex = cache.renderTexture;
            let rect = cache.cacheRect;
            ctx._drawRenderTexture(tex, x + rect.x, y + rect.y, tex.width, tex.height, null, 1, [0, 1, 1, 1, 1, 0, 0, 0]);
        }
    }
    RenderSprite.cacheNormalEnable = true;
    RenderSprite.renders = [];
    RenderSprite.NORENDER = new RenderSprite(0, null);

    class HTMLCanvas extends Resource {
        get source() {
            return this._source;
        }
        get width() {
            return this._width;
        }
        set width(width) {
            this._width = width;
        }
        get height() {
            return this._height;
        }
        set height(height) {
            this._height = height;
        }
        _getSource() {
            return this._source;
        }
        constructor(createCanvas = false) {
            super();
            if (createCanvas)
                this._source = Browser.createElement("canvas");
            else {
                this._source = this;
            }
            this.lock = true;
        }
        clear() {
            if (this._ctx) {
                if (this._ctx.clear) {
                    this._ctx.clear();
                }
                else {
                    this._ctx.clearRect(0, 0, this._width, this._height);
                }
            }
            if (this._texture) {
                this._texture.destroy();
                this._texture = null;
            }
        }
        destroy() {
            super.destroy();
            this._setCPUMemory(0);
            this._ctx && this._ctx.destroy && this._ctx.destroy();
            this._ctx = null;
        }
        release() {
        }
        get context() {
            if (this._ctx)
                return this._ctx;
            if (this._source == this) {
                this._ctx = new Context();
            }
            else {
                this._ctx = this._source.getContext(LayaEnv.isConch ? 'layagl' : '2d');
            }
            this._ctx._canvas = this;
            return this._ctx;
        }
        _setContext(context) {
            this._ctx = context;
        }
        getContext(contextID, other = null) {
            return this.context;
        }
        getMemSize() {
            return 0;
        }
        size(w, h) {
            if (this._width != w || this._height != h || (this._source && (this._source.width != w || this._source.height != h))) {
                this._width = w;
                this._height = h;
                this._setCPUMemory(w * h * 4);
                this._ctx && this._ctx.size && this._ctx.size(w, h);
                if (this._source) {
                    this._source.height = h;
                    this._source.width = w;
                }
                if (this._texture) {
                    this._texture.destroy();
                    this._texture = null;
                }
            }
        }
        getTexture() {
            if (!this._texture) {
                var bitmap = new Texture2D(this.source.width, this.source.height, exports.TextureFormat.R8G8B8A8, true, false, false);
                bitmap.setImageData(this.source, false, false);
                this._texture = new Texture(bitmap);
            }
            return this._texture;
        }
        toBase64(type, encoderOptions) {
            if (this._source) {
                return this._source.toDataURL(type, encoderOptions);
            }
            return null;
        }
    }

    class BoundsStyle {
        reset() {
            if (this.bounds)
                this.bounds.recover();
            if (this.userBounds)
                this.userBounds.recover();
            this.bounds = null;
            this.userBounds = null;
            this.temBM = null;
            return this;
        }
        recover() {
            Pool.recover("BoundsStyle", this.reset());
        }
        static create() {
            return Pool.getItemByClass("BoundsStyle", BoundsStyle);
        }
    }

    class CacheStyle {
        constructor() {
            this.renderTexOffx = 0;
            this.renderTexOffy = 0;
            this.cacheInfo = new Cache_Info();
            this.reset();
        }
        onInvisible() {
        }
        set renderTexture(rt) {
            if (this._renderTexture && rt != this._renderTexture) {
                this._renderTexture.destroy();
            }
            this._renderTexture = rt;
        }
        get renderTexture() {
            return this._renderTexture;
        }
        recover() {
            if (this === CacheStyle.EMPTY)
                return;
            Pool.recover("SpriteCache", this.reset());
        }
        reset() {
            this.userSetCache = "none";
            this.staticCache = false;
            this.mask = null;
            this.maskParent = null;
            if (this.cacheRect)
                this.cacheRect.recover();
            this.cacheRect = null;
            this.cacheInfo.reset();
            return this;
        }
        static create() {
            return Pool.getItemByClass("SpriteCache", CacheStyle);
        }
        _calculateCacheRect(sprite, tCacheType, x, y) {
            var _cacheStyle = sprite._getCacheStyle();
            if (!_cacheStyle.cacheRect)
                _cacheStyle.cacheRect = Rectangle.create();
            var tRec;
            if (tCacheType === "bitmap") {
                tRec = sprite.getSelfBounds();
                tRec.width = tRec.width;
                tRec.height = tRec.height;
                tRec.x = tRec.x - sprite.pivotX;
                tRec.y = tRec.y - sprite.pivotY;
                tRec.x = Math.floor(tRec.x + x) - x;
                tRec.y = Math.floor(tRec.y + y) - y;
                tRec.width = Math.floor(tRec.width);
                tRec.height = Math.floor(tRec.height);
                _cacheStyle.cacheRect.copyFrom(tRec);
            }
            else {
                _cacheStyle.cacheRect.setTo(-sprite._style.pivotX, -sprite._style.pivotY, 1, 1);
            }
            tRec = _cacheStyle.cacheRect;
            if (sprite._style.scrollRect) {
                var scrollRect = sprite._style.scrollRect;
                tRec.x -= scrollRect.x;
                tRec.y -= scrollRect.y;
            }
            CacheStyle._scaleInfo.setTo(1, 1);
            return CacheStyle._scaleInfo;
        }
    }
    CacheStyle.EMPTY = new CacheStyle();
    CacheStyle._scaleInfo = new Point();
    CacheStyle.CANVAS_EXTEND_EDGE = 16;

    class SpriteStyle {
        constructor() {
            this.reset();
        }
        reset() {
            this.scaleX = this.scaleY = 1;
            this.skewX = this.skewY = 0;
            this.pivotX = this.pivotY = this.rotation = 0;
            this.alpha = 1;
            if (this.scrollRect)
                this.scrollRect.recover();
            this.scrollRect = null;
            if (this.viewport)
                this.viewport.recover();
            this.viewport = null;
            this.hitArea = null;
            this.dragging = null;
            this.blendMode = null;
            return this;
        }
        recover() {
            if (this === SpriteStyle.EMPTY)
                return;
            Pool.recover("SpriteStyle", this.reset());
        }
        static create() {
            return Pool.getItemByClass("SpriteStyle", SpriteStyle);
        }
    }
    SpriteStyle.EMPTY = new SpriteStyle();

    class AlphaCmd {
        static create(alpha) {
            var cmd = Pool.getItemByClass("AlphaCmd", AlphaCmd);
            cmd.alpha = alpha;
            return cmd;
        }
        recover() {
            Pool.recover("AlphaCmd", this);
        }
        run(context, gx, gy) {
            context.alpha(this.alpha);
        }
        get cmdID() {
            return AlphaCmd.ID;
        }
    }
    AlphaCmd.ID = "Alpha";

    class DrawCircleCmd {
        constructor() {
            this.lineWidth = 0;
        }
        static create(x, y, radius, fillColor, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass("DrawCircleCmd", DrawCircleCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.radius = radius;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover("DrawCircleCmd", this);
        }
        run(context, gx, gy) {
            let offset = (this.lineWidth >= 1 && this.lineColor) ? this.lineWidth / 2 : 0;
            if (this.percent && context.sprite) {
                let w = context.sprite.width;
                let h = context.sprite.height;
                context._drawCircle(this.x * w + gx, this.y * h + gy, this.radius * Math.min(w, h) - offset, this.fillColor, this.lineColor, this.lineWidth, 0);
            }
            else
                context._drawCircle(this.x + gx, this.y + gy, this.radius - offset, this.fillColor, this.lineColor, this.lineWidth, 0);
        }
        get cmdID() {
            return DrawCircleCmd.ID;
        }
        getBoundPoints(sp) {
            return Rectangle._getBoundPointS(this.x - this.radius, this.y - this.radius, this.radius + this.radius, this.radius + this.radius, this.percent ? sp : null);
        }
    }
    DrawCircleCmd.ID = "DrawCircle";
    ClassUtils.regClass("DrawCircleCmd", DrawCircleCmd);

    class DrawCurvesCmd {
        static create(x, y, points, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass("DrawCurvesCmd", DrawCurvesCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.points = points;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            this.points = null;
            this.lineColor = null;
            Pool.recover("DrawCurvesCmd", this);
        }
        run(context, gx, gy) {
            if (this.points)
                context.drawCurves(this.x + gx, this.y + gy, this.points, this.lineColor, this.lineWidth);
        }
        get cmdID() {
            return DrawCurvesCmd.ID;
        }
        getBoundPoints() {
            return Bezier.I.getBezierPoints(this.points);
        }
    }
    DrawCurvesCmd.ID = "DrawCurves";
    ClassUtils.regClass("DrawCurvesCmd", DrawCurvesCmd);

    class DrawImageCmd {
        constructor() {
            this.color = 0xffffffff;
        }
        static create(texture, x, y, width, height, color) {
            if (width == null)
                width = texture.sourceWidth;
            if (height == null)
                height = texture.sourceHeight;
            let wRate = width / texture.sourceWidth;
            let hRate = height / texture.sourceHeight;
            width = texture.width * wRate;
            height = texture.height * hRate;
            x += texture.offsetX * wRate;
            y += texture.offsetY * hRate;
            var cmd = Pool.getItemByClass("DrawImageCmd", DrawImageCmd);
            cmd.texture = texture;
            texture._addReference();
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
            return cmd;
        }
        recover() {
            this.texture && this.texture._removeReference();
            this.texture = null;
            Pool.recover("DrawImageCmd", this);
        }
        run(context, gx, gy) {
            if (this.texture) {
                context.drawTexture(this.texture, this.x + gx, this.y + gy, this.width, this.height, this.color);
            }
        }
        get cmdID() {
            return DrawImageCmd.ID;
        }
    }
    DrawImageCmd.ID = "DrawImage";

    class DrawLineCmd {
        constructor() {
            this.lineWidth = 0;
        }
        static create(fromX, fromY, toX, toY, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass("DrawLineCmd", DrawLineCmd);
            cmd.fromX = fromX;
            cmd.fromY = fromY;
            cmd.toX = toX;
            cmd.toY = toY;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            Pool.recover("DrawLineCmd", this);
        }
        run(context, gx, gy) {
            let offset = (this.lineWidth < 1 || this.lineWidth % 2 === 0) ? 0 : 0.5;
            if (this.percent && context.sprite) {
                let w = context.sprite.width;
                let h = context.sprite.height;
                context._drawLine(gx, gy, this.fromX * w + offset, this.fromY * h + offset, this.toX * w + offset, this.toY * h + offset, this.lineColor, this.lineWidth, 0);
            }
            else
                context._drawLine(gx, gy, this.fromX + offset, this.fromY + offset, this.toX + offset, this.toY + offset, this.lineColor, this.lineWidth, 0);
        }
        get cmdID() {
            return DrawLineCmd.ID;
        }
        getBoundPoints(sp) {
            _tempPoints$2.length = 0;
            let lineWidth;
            lineWidth = this.lineWidth * 0.5;
            let fromX = this.fromX, fromY = this.fromY, toX = this.toX, toY = this.toY;
            if (this.percent) {
                fromX *= sp.width;
                fromY *= sp.height;
                toX *= sp.width;
                toY *= sp.height;
            }
            if (fromX == toX) {
                _tempPoints$2.push(fromX + lineWidth, fromY, toX + lineWidth, toY, fromX - lineWidth, fromY, toX - lineWidth, toY);
            }
            else if (fromY == toY) {
                _tempPoints$2.push(fromX, fromY + lineWidth, toX, toY + lineWidth, fromX, fromY - lineWidth, toX, toY - lineWidth);
            }
            else {
                _tempPoints$2.push(fromX, fromY, toX, toY);
            }
            return _tempPoints$2;
        }
    }
    DrawLineCmd.ID = "DrawLine";
    const _tempPoints$2 = [];
    ClassUtils.regClass("DrawLineCmd", DrawLineCmd);

    class DrawLinesCmd {
        constructor() {
            this.lineWidth = 0;
        }
        static create(x, y, points, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass("DrawLinesCmd", DrawLinesCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.points = points;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            this.points = null;
            this.lineColor = null;
            Pool.recover("DrawLinesCmd", this);
        }
        run(context, gx, gy) {
            let offset = (this.lineWidth < 1 || this.lineWidth % 2 === 0) ? 0 : 0.5;
            this.points && context._drawLines(this.x + offset + gx, this.y + offset + gy, this.points, this.lineColor, this.lineWidth, 0);
        }
        get cmdID() {
            return DrawLinesCmd.ID;
        }
    }
    DrawLinesCmd.ID = "DrawLines";
    ClassUtils.regClass("DrawLinesCmd", DrawLinesCmd);

    class DrawPathCmd {
        static create(x, y, paths, brush, pen) {
            var cmd = Pool.getItemByClass("DrawPathCmd", DrawPathCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.paths = paths;
            cmd.brush = brush;
            cmd.pen = pen;
            return cmd;
        }
        recover() {
            this.paths = null;
            this.brush = null;
            this.pen = null;
            Pool.recover("DrawPathCmd", this);
        }
        run(context, gx, gy) {
            this.paths && context._drawPath(this.x + gx, this.y + gy, this.paths, this.brush, this.pen);
        }
        get cmdID() {
            return DrawPathCmd.ID;
        }
        getBoundPoints() {
            let rst = _tempPoints$1;
            rst.length = 0;
            let paths = this.paths;
            let len = paths.length;
            for (let i = 0; i < len; i++) {
                let tCMD = paths[i];
                if (tCMD.length > 1) {
                    rst.push(tCMD[1], tCMD[2]);
                    if (tCMD.length > 3) {
                        rst.push(tCMD[3], tCMD[4]);
                    }
                }
            }
            return rst;
        }
    }
    DrawPathCmd.ID = "DrawPath";
    const _tempPoints$1 = [];
    ClassUtils.regClass("DrawPathCmd", DrawPathCmd);

    class DrawPieCmd {
        constructor() {
            this.radius = 0;
            this.lineWidth = 0;
        }
        static create(x, y, radius, startAngle, endAngle, fillColor, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass("DrawPieCmd", DrawPieCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.radius = radius;
            cmd._startAngle = startAngle;
            cmd._endAngle = endAngle;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover("DrawPieCmd", this);
        }
        run(context, gx, gy) {
            let offset = (this.lineWidth >= 1 && this.lineColor) ? this.lineWidth / 2 : 0;
            let lineOffset = this.lineColor ? this.lineWidth : 0;
            context._drawPie(this.x + offset + gx, this.y + offset + gy, this.radius - lineOffset, this._startAngle, this._endAngle, this.fillColor, this.lineColor, this.lineWidth, 0);
        }
        get cmdID() {
            return DrawPieCmd.ID;
        }
        get startAngle() {
            return this._startAngle * 180 / Math.PI;
        }
        set startAngle(value) {
            this._startAngle = value * Math.PI / 180;
        }
        get endAngle() {
            return this._endAngle * 180 / Math.PI;
        }
        set endAngle(value) {
            this._endAngle = value * Math.PI / 180;
        }
        getBoundPoints() {
            let rst = _tempPoints;
            _tempPoints.length = 0;
            let k = Math.PI / 180;
            let d1 = this.endAngle - this.startAngle;
            let x = this.x, y = this.y, radius = this.radius;
            if (d1 >= 360 || d1 <= -360) {
                rst.push(x - radius, y - radius);
                rst.push(x + radius, y - radius);
                rst.push(x + radius, y + radius);
                rst.push(x - radius, y + radius);
                return rst;
            }
            rst.push(x, y);
            var delta = d1 % 360;
            if (delta < 0)
                delta += 360;
            var end1 = this.startAngle + delta;
            var st = this.startAngle * k;
            var ed = end1 * k;
            rst.push(x + radius * Math.cos(st), y + radius * Math.sin(st));
            rst.push(x + radius * Math.cos(ed), y + radius * Math.sin(ed));
            var s1 = Math.ceil(this.startAngle / 90) * 90;
            var s2 = Math.floor(end1 / 90) * 90;
            for (var cs = s1; cs <= s2; cs += 90) {
                var csr = cs * k;
                rst.push(x + radius * Math.cos(csr), y + radius * Math.sin(csr));
            }
            return rst;
        }
    }
    DrawPieCmd.ID = "DrawPie";
    const _tempPoints = [];
    ClassUtils.regClass("DrawPieCmd", DrawPieCmd);

    class DrawPolyCmd {
        static create(x, y, points, fillColor, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass("DrawPolyCmd", DrawPolyCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.points = points;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            this.points = null;
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover("DrawPolyCmd", this);
        }
        run(context, gx, gy) {
            let isConvexPolygon = this.points.length <= 6;
            let offset = (this.lineWidth >= 1 && this.lineColor) ? (this.lineWidth % 2 === 0 ? 0 : 0.5) : 0;
            this.points && context._drawPoly(this.x + offset + gx, this.y + offset + gy, this.points, this.fillColor, this.lineColor, this.lineWidth, isConvexPolygon, 0);
        }
        get cmdID() {
            return DrawPolyCmd.ID;
        }
    }
    DrawPolyCmd.ID = "DrawPoly";
    ClassUtils.regClass("DrawPolyCmd", DrawPolyCmd);

    class DrawRectCmd {
        constructor() {
            this.lineWidth = 0;
        }
        static create(x, y, width, height, fillColor, lineColor, lineWidth, percent) {
            var cmd = Pool.getItemByClass("DrawRectCmd", DrawRectCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            cmd.percent = percent;
            return cmd;
        }
        recover() {
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover("DrawRectCmd", this);
        }
        run(context, gx, gy) {
            let offset = (this.lineWidth >= 1 && this.lineColor) ? this.lineWidth / 2 : 0;
            let lineOffset = this.lineColor ? this.lineWidth : 0;
            if (this.percent && context.sprite) {
                let w = context.sprite.width;
                let h = context.sprite.height;
                context.drawRect(this.x * w + offset + gx, this.y * h + offset + gy, this.width * w - lineOffset, this.height * h - lineOffset, this.fillColor, this.lineColor, this.lineWidth);
            }
            else
                context.drawRect(this.x + offset + gx, this.y + offset + gy, this.width - lineOffset, this.height - lineOffset, this.fillColor, this.lineColor, this.lineWidth);
        }
        get cmdID() {
            return DrawRectCmd.ID;
        }
        getBoundPoints(sp) {
            return Rectangle._getBoundPointS(this.x, this.y, this.width, this.height, this.percent ? sp : null);
        }
    }
    DrawRectCmd.ID = "DrawRect";
    ClassUtils.regClass("DrawRectCmd", DrawRectCmd);

    class DrawTextureCmd {
        constructor() {
            this.color = 0xffffffff;
            this.uv = null;
        }
        static create(texture, x, y, width, height, matrix, alpha, color, blendMode, uv) {
            if (width == null)
                width = texture.sourceWidth;
            if (height == null)
                height = texture.sourceHeight;
            let wRate = width / texture.sourceWidth;
            let hRate = height / texture.sourceHeight;
            width = texture.width * wRate;
            height = texture.height * hRate;
            x += texture.offsetX * wRate;
            y += texture.offsetY * hRate;
            var cmd = Pool.getItemByClass("DrawTextureCmd", DrawTextureCmd);
            cmd.texture = texture;
            texture._addReference();
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.matrix = matrix;
            cmd.alpha = alpha;
            cmd.blendMode = blendMode;
            cmd.uv = uv || null;
            cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
            return cmd;
        }
        recover() {
            this.texture && this.texture._removeReference();
            this.texture = null;
            this.matrix = null;
            Pool.recover("DrawTextureCmd", this);
        }
        run(context, gx, gy) {
            this.texture && context.drawTextureWithTransform(this.texture, this.x, this.y, this.width, this.height, this.matrix, gx, gy, this.alpha, this.blendMode, this.uv, this.color);
        }
        get cmdID() {
            return DrawTextureCmd.ID;
        }
    }
    DrawTextureCmd.ID = "DrawTexture";
    ClassUtils.regClass("DrawTextureCmd", DrawTextureCmd);

    class FillTextureCmd {
        constructor() {
            this.color = 0xffffffff;
        }
        static create(texture, x, y, width, height, type, offset, color) {
            var cmd = Pool.getItemByClass("FillTextureCmd", FillTextureCmd);
            cmd.texture = texture;
            texture._addReference();
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.type = type;
            cmd.offset = offset;
            cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
            return cmd;
        }
        recover() {
            this.texture && this.texture._removeReference();
            this.texture = null;
            this.offset = null;
            Pool.recover("FillTextureCmd", this);
        }
        run(context, gx, gy) {
            if (this.texture) {
                if (this.percent && context.sprite) {
                    let w = context.sprite.width;
                    let h = context.sprite.height;
                    context.fillTexture(this.texture, this.x * w + gx, this.y * h + gy, this.width * w, this.height * h, this.type, this.offset || Point.EMPTY, this.color);
                }
                else
                    context.fillTexture(this.texture, this.x + gx, this.y + gy, this.width, this.height, this.type, this.offset || Point.EMPTY, this.color);
            }
        }
        get cmdID() {
            return FillTextureCmd.ID;
        }
        getBoundPoints(sp) {
            if (this.width && this.height)
                return Rectangle._getBoundPointS(this.x, this.y, this.width, this.height, this.percent ? sp : null);
            else
                return Rectangle._getBoundPointS(this.x, this.y, this.texture.width, this.texture.height);
        }
    }
    FillTextureCmd.ID = "FillTexture";
    ClassUtils.regClass("FillTextureCmd", FillTextureCmd);

    class RestoreCmd {
        static create() {
            var cmd = Pool.getItemByClass("RestoreCmd", RestoreCmd);
            return cmd;
        }
        recover() {
            Pool.recover("RestoreCmd", this);
        }
        run(context) {
            context.restore();
        }
        get cmdID() {
            return RestoreCmd.ID;
        }
    }
    RestoreCmd.ID = "Restore";

    class RotateCmd {
        static create(angle, pivotX, pivotY) {
            var cmd = Pool.getItemByClass("RotateCmd", RotateCmd);
            cmd.angle = angle;
            cmd.pivotX = pivotX;
            cmd.pivotY = pivotY;
            return cmd;
        }
        recover() {
            Pool.recover("RotateCmd", this);
        }
        run(context, gx, gy) {
            context._rotate(this.angle, this.pivotX + gx, this.pivotY + gy);
        }
        get cmdID() {
            return RotateCmd.ID;
        }
    }
    RotateCmd.ID = "Rotate";

    class ScaleCmd {
        static create(scaleX, scaleY, pivotX, pivotY) {
            var cmd = Pool.getItemByClass("ScaleCmd", ScaleCmd);
            cmd.scaleX = scaleX;
            cmd.scaleY = scaleY;
            cmd.pivotX = pivotX;
            cmd.pivotY = pivotY;
            return cmd;
        }
        recover() {
            Pool.recover("ScaleCmd", this);
        }
        run(context, gx, gy) {
            context._scale(this.scaleX, this.scaleY, this.pivotX + gx, this.pivotY + gy);
        }
        get cmdID() {
            return ScaleCmd.ID;
        }
    }
    ScaleCmd.ID = "Scale";

    class TransformCmd {
        static create(matrix, pivotX, pivotY) {
            var cmd = Pool.getItemByClass("TransformCmd", TransformCmd);
            cmd.matrix = matrix;
            cmd.pivotX = pivotX;
            cmd.pivotY = pivotY;
            return cmd;
        }
        recover() {
            this.matrix = null;
            Pool.recover("TransformCmd", this);
        }
        run(context, gx, gy) {
            context._transform(this.matrix, this.pivotX + gx, this.pivotY + gy);
        }
        get cmdID() {
            return TransformCmd.ID;
        }
    }
    TransformCmd.ID = "Transform";

    class TranslateCmd {
        static create(tx, ty) {
            var cmd = Pool.getItemByClass("TranslateCmd", TranslateCmd);
            cmd.tx = tx;
            cmd.ty = ty;
            return cmd;
        }
        recover() {
            Pool.recover("TranslateCmd", this);
        }
        run(context) {
            context.translate(this.tx, this.ty);
        }
        get cmdID() {
            return TranslateCmd.ID;
        }
    }
    TranslateCmd.ID = "Translate";

    class DrawTrianglesCmd {
        static create(texture, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode) {
            var cmd = Pool.getItemByClass("DrawTrianglesCmd", DrawTrianglesCmd);
            cmd.texture = texture;
            texture._addReference();
            cmd.x = x;
            cmd.y = y;
            cmd.vertices = vertices;
            cmd.uvs = uvs;
            cmd.indices = indices;
            cmd.matrix = matrix;
            cmd.alpha = alpha;
            cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
            cmd.blendMode = blendMode;
            return cmd;
        }
        recover() {
            this.texture && this.texture._removeReference();
            this.texture = null;
            this.vertices = null;
            this.uvs = null;
            this.indices = null;
            this.matrix = null;
            Pool.recover("DrawTrianglesCmd", this);
        }
        run(context, gx, gy) {
            context.drawTriangles(this.texture, this.x + gx, this.y + gy, this.vertices, this.uvs, this.indices, this.matrix, this.alpha, this.blendMode, this.color);
        }
        get cmdID() {
            return DrawTrianglesCmd.ID;
        }
        getBoundPoints() {
            let vert = this.vertices;
            var vnum = vert.length;
            if (vnum < 2)
                return [];
            var minx = vert[0];
            var miny = vert[1];
            var maxx = minx;
            var maxy = miny;
            for (var i = 2; i < vnum;) {
                var cx = vert[i++];
                var cy = vert[i++];
                if (minx > cx)
                    minx = cx;
                if (miny > cy)
                    miny = cy;
                if (maxx < cx)
                    maxx = cx;
                if (maxy < cy)
                    maxy = cy;
            }
            return [minx, miny, maxx, miny, maxx, maxy, minx, maxy];
        }
    }
    DrawTrianglesCmd.ID = "DrawTriangles";
    ClassUtils.regClass("DrawTrianglesCmd", DrawTrianglesCmd);

    class Draw9GridTextureCmd {
        constructor() {
            this.color = 0xffffffff;
        }
        static create(texture, x, y, width, height, sizeGrid, percent = false, color = null) {
            let cmd = Pool.getItemByClass("Draw9GridTextureCmd", Draw9GridTextureCmd);
            cmd.texture = texture;
            texture._addReference();
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.sizeGrid = sizeGrid;
            cmd.percent = percent;
            cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
            return cmd;
        }
        recover() {
            this.texture && this.texture._removeReference();
            this.texture = null;
            Pool.recover("Draw9GridTextureCmd", this);
        }
        run(context, gx, gy) {
            if (this.texture) {
                let sizeGrid = this.sizeGrid || this.texture._sizeGrid || EMPTY_SIZE_GRID;
                if (this.percent && context.sprite) {
                    let w = context.sprite.width;
                    let h = context.sprite.height;
                    context.drawTextureWithSizeGrid(this.texture, this.x * w, this.y * h, this.width * w, this.height * h, sizeGrid, gx, gy, this.color);
                }
                else
                    context.drawTextureWithSizeGrid(this.texture, this.x, this.y, this.width, this.height, sizeGrid, gx, gy, this.color);
            }
        }
        get cmdID() {
            return Draw9GridTextureCmd.ID;
        }
        getBoundPoints(sp) {
            let minx = this.x;
            let miny = this.y;
            let maxx = this.width;
            let maxy = this.height;
            if (this.percent) {
                minx *= sp.width;
                miny *= sp.height;
                maxx *= sp.width;
                maxy *= sp.height;
            }
            return [minx, miny, maxx, miny, maxx, maxy, minx, maxy];
        }
    }
    Draw9GridTextureCmd.ID = "Draw9GridTexture";
    const EMPTY_SIZE_GRID = [0, 0, 0, 0, 0];
    ClassUtils.regClass("Draw9GridTextureCmd", Draw9GridTextureCmd);

    class SaveCmd {
        static create() {
            var cmd = Pool.getItemByClass("SaveCmd", SaveCmd);
            return cmd;
        }
        recover() {
            Pool.recover("SaveCmd", this);
        }
        run(context) {
            context.save();
        }
        get cmdID() {
            return SaveCmd.ID;
        }
    }
    SaveCmd.ID = "Save";

    class DrawEllipseCmd {
        constructor() {
            this.lineWidth = 0;
        }
        static create(x, y, width, height, fillColor, lineColor, lineWidth, percent) {
            var cmd = Pool.getItemByClass("DrawEllipseCmd", DrawEllipseCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            cmd.percent = percent;
            return cmd;
        }
        recover() {
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover("DrawEllipseCmd", this);
        }
        run(context, gx, gy) {
            let offset = (this.lineWidth >= 1 && this.lineColor) ? this.lineWidth / 2 : 0;
            if (this.percent && context.sprite) {
                let w = context.sprite.width;
                let h = context.sprite.height;
                context._drawEllipse(this.x * w + gx, this.y * h + gy, this.width * w - offset, this.height * h - offset, this.fillColor, this.lineColor, this.lineWidth);
            }
            else {
                context._drawEllipse(this.x + gx, this.y + gy, this.width - offset, this.height - offset, this.fillColor, this.lineColor, this.lineWidth);
            }
        }
        get cmdID() {
            return DrawEllipseCmd.ID;
        }
        getBoundPoints(sp) {
            return Rectangle._getBoundPointS(this.x - this.width, this.y - this.height, this.width * 2, this.height * 2, this.percent ? sp : null);
        }
    }
    DrawEllipseCmd.ID = "DrawEllipse";
    ClassUtils.regClass("DrawEllipseCmd", DrawEllipseCmd);

    class DrawRoundRectCmd {
        constructor() {
            this.lineWidth = 0;
        }
        static create(x, y, width, height, lt, rt, lb, rb, fillColor, lineColor, lineWidth, percent) {
            var cmd = Pool.getItemByClass("DrawRoundRectCmd", DrawRoundRectCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.lt = lt;
            cmd.rt = rt;
            cmd.lb = lb;
            cmd.rb = rb;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            cmd.percent = percent;
            return cmd;
        }
        recover() {
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover("DrawRoundRectCmd", this);
        }
        run(context, gx, gy) {
            let offset = (this.lineWidth >= 1 && this.lineColor) ? this.lineWidth / 2 : 0;
            let lineOffset = this.lineColor ? this.lineWidth : 0;
            if (this.percent && context.sprite) {
                let w = context.sprite.width;
                let h = context.sprite.height;
                context._drawRoundRect(this.x * w + offset + gx, this.y * h + offset + gy, this.width * w - lineOffset, this.height * h - lineOffset, this.lt, this.rt, this.lb, this.rb, this.fillColor, this.lineColor, this.lineWidth);
            }
            else {
                context._drawRoundRect(this.x + offset + gx, this.y + offset + gy, this.width - lineOffset, this.height - lineOffset, this.lt, this.rt, this.lb, this.rb, this.fillColor, this.lineColor, this.lineWidth);
            }
        }
        get cmdID() {
            return DrawRoundRectCmd.ID;
        }
        getBoundPoints(sp) {
            return Rectangle._getBoundPointS(this.x, this.y, this.width, this.height, this.percent ? sp : null);
        }
    }
    DrawRoundRectCmd.ID = "DrawRoundRect";
    ClassUtils.regClass("DrawRoundRectCmd", DrawRoundRectCmd);

    class FillTextCmd {
        constructor() {
            this.x = 0;
            this.y = 0;
            this._strokeColor = '#000000';
            this._loosyBound = null;
        }
        get text() {
            return this._text;
        }
        set text(value) {
            this._text = value;
        }
        get strokeColor() {
            return this._strokeColor;
        }
        set strokeColor(value) {
            this._strokeColor = value;
        }
        get stroke() {
            return this._stroke;
        }
        set stroke(value) {
            this._stroke = value;
        }
        get align() {
            return this._align;
        }
        set align(value) {
            this._align = value;
        }
        static create(text, x, y, font, color, align, stroke, strokeColor) {
            var cmd = Pool.getItemByClass("FillTextCmd", FillTextCmd);
            cmd._text = null;
            cmd._wordText = null;
            cmd.x = x;
            cmd.y = y;
            cmd.font = font;
            cmd.color = color;
            cmd._stroke = stroke;
            cmd._strokeColor = strokeColor;
            switch (align) {
                case 'center':
                    cmd._align = Const.ENUM_TEXTALIGN_CENTER;
                    break;
                case 'right':
                    cmd._align = Const.ENUM_TEXTALIGN_RIGHT;
                    break;
                default:
                    cmd._align = Const.ENUM_TEXTALIGN_DEFAULT;
            }
            if (text instanceof WordText$1) {
                cmd._wordText = text;
                text.cleanCache();
            }
            else
                cmd._text = text;
            return cmd;
        }
        recover() {
            Pool.recover("FillTextCmd", this);
        }
        run(context, gx, gy) {
            if (ILaya.stage.isGlobalRepaint()) {
                this._wordText && this._wordText.cleanCache();
            }
            if (null == this._text)
                this._text = '';
            if (null == this._fontObj) {
                this.font = null;
            }
            if (null == this._color) {
                this._color = '#ffffff';
            }
            context._fast_filltext(this._wordText || this._text, this.x + gx, this.y + gy, this._fontObj, this._color, this._strokeColor, this._stroke, this._align);
        }
        get cmdID() {
            return FillTextCmd.ID;
        }
        get font() {
            return this._font;
        }
        set font(value) {
            this._font = value;
            if (!value)
                value = Config.defaultFontSize + "px " + Config.defaultFont;
            this._fontObj = FontInfo.parse(value);
            this._wordText && this._wordText.cleanCache();
        }
        get color() {
            return this._color;
        }
        set color(value) {
            this._color = value;
            this._wordText && this._wordText.cleanCache();
        }
        getBoundPoints() {
            if (!this._loosyBound) {
                let ctx = ILaya.Browser.context;
                ctx.save();
                ctx.font = this.font;
                let size = ctx.measureText(this.text);
                let w = size.width;
                ctx.restore();
                let x = this.x;
                let y = this.y;
                switch (this._align) {
                    case Const.ENUM_TEXTALIGN_CENTER:
                        x -= w / 2;
                        break;
                    case Const.ENUM_TEXTALIGN_RIGHT:
                        x -= w;
                        break;
                }
                if (!this._fontObj)
                    this.font = null;
                x -= 4;
                y -= this._fontObj._size;
                this._loosyBound = new Rectangle(x, y, w + 8, this._fontObj._size * 2);
            }
            return Rectangle._getBoundPointS(this._loosyBound.x, this._loosyBound.y, this._loosyBound.width, this._loosyBound.height, null);
        }
    }
    FillTextCmd.ID = "FillText";
    ClassUtils.regClass("FillTextCmd", FillTextCmd);

    const _tempMatrix = new Matrix();
    const _initMatrix = new Matrix();
    const _tempMatrixArrays = [];
    class GraphicsBounds {
        constructor() {
            this._cacheBounds = null;
        }
        destroy() {
            this._graphics = null;
            this._cacheBounds = null;
            if (this._temp)
                this._temp.length = 0;
            if (this._rstBoundPoints)
                this._rstBoundPoints.length = 0;
            if (this._bounds)
                this._bounds.recover();
            this._bounds = null;
            Pool.recover("GraphicsBounds", this);
        }
        static create() {
            return Pool.getItemByClass("GraphicsBounds", GraphicsBounds);
        }
        reset() {
            this._cacheBounds = null;
        }
        getBounds(realSize = false) {
            realSize = !!realSize;
            if (realSize !== this._cacheBounds) {
                this._temp = this._getCmdPoints(realSize);
                this._bounds = Rectangle._getWrapRec(this._temp, this._bounds);
                this._cacheBounds = realSize;
            }
            return this._bounds;
        }
        getBoundPoints(realSize = false) {
            this.getBounds(realSize);
            return this._rstBoundPoints = Utils.copyArray(this._rstBoundPoints, this._temp);
        }
        _getCmdPoints(realSize = false) {
            let cmds = this._graphics.cmds;
            let sp = this._graphics._sp;
            this._affectBySize = false;
            let rst = this._temp || (this._temp = []);
            rst.length = 0;
            if (cmds.length == 0)
                return rst;
            let matrixs = _tempMatrixArrays;
            matrixs.length = 0;
            let tMatrix = _initMatrix;
            tMatrix.identity();
            let tempMatrix = _tempMatrix;
            for (let i = 0, n = cmds.length; i < n; i++) {
                let cmd = cmds[i];
                if (cmd.percent)
                    this._affectBySize = true;
                switch (cmd.cmdID) {
                    case AlphaCmd.ID:
                    case SaveCmd.ID:
                        matrixs.push(tMatrix);
                        tMatrix = tMatrix.clone();
                        break;
                    case RestoreCmd.ID:
                        tMatrix = matrixs.pop();
                        break;
                    case ScaleCmd.ID:
                        tempMatrix.identity();
                        tempMatrix.translate(-cmd.pivotX, -cmd.pivotY);
                        tempMatrix.scale(cmd.scaleX, cmd.scaleY);
                        tempMatrix.translate(cmd.pivotX, cmd.pivotY);
                        this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case RotateCmd.ID:
                        tempMatrix.identity();
                        tempMatrix.translate(-cmd.pivotX, -cmd.pivotY);
                        tempMatrix.rotate(cmd.angle);
                        tempMatrix.translate(cmd.pivotX, cmd.pivotY);
                        this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case TranslateCmd.ID:
                        tempMatrix.identity();
                        tempMatrix.translate(cmd.tx, cmd.ty);
                        this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case TransformCmd.ID:
                        tempMatrix.identity();
                        tempMatrix.translate(-cmd.pivotX, -cmd.pivotY);
                        tempMatrix.concat(cmd.matrix);
                        tempMatrix.translate(cmd.pivotX, cmd.pivotY);
                        this._switchMatrix(tMatrix, tempMatrix);
                        break;
                    case DrawImageCmd.ID:
                    case FillTextureCmd.ID:
                        addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, cmd.width, cmd.height), tMatrix);
                        break;
                    case DrawTextureCmd.ID:
                        tMatrix.copyTo(tempMatrix);
                        if (cmd.matrix)
                            tempMatrix.concat(cmd.matrix);
                        addPointArrToRst(rst, Rectangle._getBoundPointS(cmd.x, cmd.y, cmd.width, cmd.height), tempMatrix);
                        break;
                    case DrawRectCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(sp), tMatrix);
                        break;
                    case DrawCircleCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(sp), tMatrix);
                        break;
                    case DrawEllipseCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(sp), tMatrix);
                        break;
                    case DrawRoundRectCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(sp), tMatrix);
                        break;
                    case DrawLineCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(sp), tMatrix);
                        break;
                    case DrawCurvesCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(), tMatrix, cmd.x, cmd.y);
                        break;
                    case DrawLinesCmd.ID:
                    case DrawPolyCmd.ID:
                        addPointArrToRst(rst, cmd.points, tMatrix, cmd.x, cmd.y);
                        break;
                    case DrawPathCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(), tMatrix, cmd.x, cmd.y);
                        break;
                    case DrawPieCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(), tMatrix);
                        break;
                    case DrawTrianglesCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(), tMatrix);
                        break;
                    case Draw9GridTextureCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(sp), tMatrix);
                        break;
                    case FillTextCmd.ID:
                        addPointArrToRst(rst, cmd.getBoundPoints(), tMatrix);
                        break;
                    default:
                        addPointArrToRst(rst, Rectangle._getBoundPointS(sp.x, sp.y, sp.width, sp.height, null), tMatrix);
                        break;
                }
            }
            if (rst.length > 200) {
                rst = Utils.copyArray(rst, Rectangle._getWrapRec(rst)._getBoundPoints());
            }
            else if (rst.length > 8)
                rst = GrahamScan.scanPList(rst);
            return rst;
        }
        _switchMatrix(tMatix, tempMatrix) {
            tempMatrix.concat(tMatix);
            tempMatrix.copyTo(tMatix);
        }
    }
    function addPointArrToRst(rst, points, matrix, dx = 0, dy = 0) {
        let len = points.length;
        for (let i = 0; i < len; i += 2) {
            addPointToRst(rst, points[i] + dx, points[i + 1] + dy, matrix);
        }
    }
    function addPointToRst(rst, x, y, matrix) {
        var _tempPoint = Point.TEMP;
        _tempPoint.setTo(x ? x : 0, y ? y : 0);
        matrix.transformPoint(_tempPoint);
        rst.push(_tempPoint.x, _tempPoint.y);
    }

    class ClipRectCmd {
        static create(x, y, width, height) {
            var cmd = Pool.getItemByClass("ClipRectCmd", ClipRectCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            return cmd;
        }
        recover() {
            Pool.recover("ClipRectCmd", this);
        }
        run(context, gx, gy) {
            context.clipRect(this.x + gx, this.y + gy, this.width, this.height);
        }
        get cmdID() {
            return ClipRectCmd.ID;
        }
    }
    ClipRectCmd.ID = "ClipRect";

    class DrawTexturesCmd {
        static create(texture, pos, colors) {
            var cmd = Pool.getItemByClass("DrawTexturesCmd", DrawTexturesCmd);
            cmd.texture = texture;
            texture._addReference();
            cmd.pos = pos;
            cmd.colors = colors || [];
            return cmd;
        }
        recover() {
            this.texture._removeReference();
            this.texture = null;
            this.pos = null;
            Pool.recover("DrawTexturesCmd", this);
        }
        run(context, gx, gy) {
            context.drawTextures(this.texture, this.pos, gx, gy, this.colors);
        }
        get cmdID() {
            return DrawTexturesCmd.ID;
        }
    }
    DrawTexturesCmd.ID = "DrawTextures";

    class CacheManger {
        constructor() {
        }
        static regCacheByFunction(disposeFunction, getCacheListFunction) {
            CacheManger.unRegCacheByFunction(disposeFunction, getCacheListFunction);
            var cache;
            cache = { tryDispose: disposeFunction, getCacheList: getCacheListFunction };
            CacheManger._cacheList.push(cache);
        }
        static unRegCacheByFunction(disposeFunction, getCacheListFunction) {
            var i, len;
            len = CacheManger._cacheList.length;
            for (i = 0; i < len; i++) {
                if (CacheManger._cacheList[i].tryDispose == disposeFunction && CacheManger._cacheList[i].getCacheList == getCacheListFunction) {
                    CacheManger._cacheList.splice(i, 1);
                    return;
                }
            }
        }
        static forceDispose() {
            var i, len = CacheManger._cacheList.length;
            for (i = 0; i < len; i++) {
                CacheManger._cacheList[i].tryDispose(true);
            }
        }
        static beginCheck(waitTime = 15000) {
            ILaya.systemTimer.loop(waitTime, null, CacheManger._checkLoop);
        }
        static stopCheck() {
            ILaya.systemTimer.clear(null, CacheManger._checkLoop);
        }
        static _checkLoop() {
            var cacheList = CacheManger._cacheList;
            if (cacheList.length < 1)
                return;
            var tTime = ILaya.Browser.now();
            var count;
            var len;
            len = count = cacheList.length;
            while (count > 0) {
                CacheManger._index++;
                CacheManger._index = CacheManger._index % len;
                cacheList[CacheManger._index].tryDispose(false);
                if (ILaya.Browser.now() - tTime > CacheManger.loopTimeLimit)
                    break;
                count--;
            }
        }
    }
    CacheManger.loopTimeLimit = 2;
    CacheManger._cacheList = [];
    CacheManger._index = 0;

    class VectorGraphManager {
        constructor() {
            this.useDic = {};
            this.shapeDic = {};
            this.shapeLineDic = {};
            this._id = 0;
            this._checkKey = false;
            this._freeIdArray = [];
            CacheManger.regCacheByFunction(this.startDispose.bind(this), this.getCacheList.bind(this));
        }
        static getInstance() {
            return VectorGraphManager.instance = VectorGraphManager.instance || new VectorGraphManager();
        }
        getId() {
            return this._id++;
        }
        addShape(id, shape) {
            this.shapeDic[id] = shape;
            if (!this.useDic[id]) {
                this.useDic[id] = true;
            }
        }
        addLine(id, Line) {
            this.shapeLineDic[id] = Line;
            if (!this.shapeLineDic[id]) {
                this.shapeLineDic[id] = true;
            }
        }
        getShape(id) {
            if (this._checkKey) {
                if (this.useDic[id] != null) {
                    this.useDic[id] = true;
                }
            }
        }
        deleteShape(id) {
            if (this.shapeDic[id]) {
                this.shapeDic[id] = null;
                delete this.shapeDic[id];
            }
            if (this.shapeLineDic[id]) {
                this.shapeLineDic[id] = null;
                delete this.shapeLineDic[id];
            }
            if (this.useDic[id] != null) {
                delete this.useDic[id];
            }
        }
        getCacheList() {
            var str;
            var list = [];
            for (str in this.shapeDic) {
                list.push(this.shapeDic[str]);
            }
            for (str in this.shapeLineDic) {
                list.push(this.shapeLineDic[str]);
            }
            return list;
        }
        startDispose(key) {
            var str;
            for (str in this.useDic) {
                this.useDic[str] = false;
            }
            this._checkKey = true;
        }
        endDispose() {
            if (this._checkKey) {
                var str;
                for (str in this.useDic) {
                    if (!this.useDic[str]) {
                        this.deleteShape(str);
                    }
                }
                this._checkKey = false;
            }
        }
    }

    class DrawGeoCmd {
        static create(geo, material) {
            var cmd = Pool.getItemByClass("DrawGeoCmd" + material.id, DrawGeoCmd);
            cmd.init(geo, material);
            return cmd;
        }
        static creatGEO(decl, vbArray, vblen, ibArray, iblen) {
            let geo = LayaGL.renderDeviceFactory.createRenderGeometryElement(exports.MeshTopology.Triangles, exports.DrawType.DrawElement);
            let mesh = LayaGL.renderDeviceFactory.createBufferState();
            geo.bufferState = mesh;
            let vb = LayaGL.renderDeviceFactory.createVertexBuffer(exports.BufferUsage.Dynamic);
            vb.vertexDeclaration = decl;
            let ib = LayaGL.renderDeviceFactory.createIndexBuffer(exports.BufferUsage.Dynamic);
            mesh.applyState([vb], ib);
            geo.indexFormat = exports.IndexFormat.UInt16;
            vb.setDataLength(vblen);
            vb.setData(vbArray.buffer, 0, 0, vblen);
            ib._setIndexDataLength(iblen);
            ib._setIndexData(new Uint16Array(ibArray.buffer, 0, iblen / 2), 0);
            geo.clearRenderParams();
            geo.setDrawElemenParams(iblen / 2, 0);
            return geo;
        }
        init(geo, material) {
            this.material = material;
            this.geo = geo;
        }
        recover() {
            Pool.recover("DrawGeoCmd" + this.material.id, this);
        }
        run(context, gx, gy) {
            context.drawGeo(this.geo, this.material, gx, gy);
        }
        get cmdID() {
            return DrawGeoCmd.ID;
        }
    }
    DrawGeoCmd.ID = "DrawGeoCmd";

    class DrawGeosCmd {
        static create(geo, elements) {
            var cmd = Pool.getItemByClass("DrawGeosCmd", DrawGeosCmd);
            cmd.init(geo, elements);
            return cmd;
        }
        init(geo, elements) {
            this.elements = elements;
            this.geo = geo;
        }
        recover() {
            Pool.recover("DrawGeosCmd", this);
        }
        run(context, gx, gy) {
            context.drawGeos(this.geo, this.elements, gx, gy);
        }
        get cmdID() {
            return DrawGeosCmd.ID;
        }
    }
    DrawGeosCmd.ID = "DrawGeoCmd";

    class Graphics {
        static add2DGlobalUniformData(propertyID, propertyKey, uniformtype) {
            let sceneUniformMap = LayaGL.renderDeviceFactory.createGlobalUniformMap("Sprite2DGlobal");
            sceneUniformMap.addShaderUniform(propertyID, propertyKey, uniformtype);
        }
        static get globalShaderData() {
            return null;
        }
        constructor() {
            this._sp = null;
            this._render = this._renderEmpty;
            this._cmds = [];
            this._vectorgraphArray = null;
            this._graphicBounds = null;
            this._createData();
        }
        _createData() {
        }
        _clearData() {
        }
        _destroyData() {
        }
        destroy() {
            this.clear(true);
            if (this._graphicBounds)
                this._graphicBounds.destroy();
            this._graphicBounds = null;
            this._vectorgraphArray = null;
            if (this._sp) {
                this._sp._renderType = 0;
                this._sp = null;
            }
            if (this._material) {
                this._material._removeReference();
                this._material = null;
            }
            this._destroyData();
        }
        clear(recoverCmds = true) {
            if (recoverCmds) {
                for (let i = 0, len = this._cmds.length; i < len; i++) {
                    this._cmds[i].recover();
                }
            }
            this._cmds.length = 0;
            this._render = this._renderEmpty;
            this._clearData();
            if (this._sp) {
                this._sp._renderType &= ~SpriteConst.GRAPHICS;
            }
            this._repaint();
            if (this._vectorgraphArray) {
                for (let i = 0, len = this._vectorgraphArray.length; i < len; i++) {
                    VectorGraphManager.getInstance().deleteShape(this._vectorgraphArray[i]);
                }
                this._vectorgraphArray.length = 0;
            }
        }
        _clearBoundsCache(onSizeChanged) {
            if (this._graphicBounds) {
                if (!onSizeChanged || this._graphicBounds._affectBySize)
                    this._graphicBounds.reset();
            }
        }
        _initGraphicBounds() {
            if (!this._graphicBounds) {
                this._graphicBounds = GraphicsBounds.create();
                this._graphicBounds._graphics = this;
            }
        }
        _repaint() {
            this._clearBoundsCache();
            this._sp && this._sp.repaint();
        }
        _isOnlyOne() {
            return this._cmds.length === 1;
        }
        get cmds() {
            return this._cmds;
        }
        set cmds(value) {
            if (this._sp) {
                this._sp._renderType |= SpriteConst.GRAPHICS;
            }
            this._cmds = value;
            let len = value.length;
            this._render = len === 0 ? this._renderEmpty : (len === 1 ? this._renderOne : this._renderAll);
            this._repaint();
        }
        addCmd(cmd) {
            if (cmd == null) {
                console.warn("null cmd");
                return;
            }
            if (this._sp) {
                this._sp._renderType |= SpriteConst.GRAPHICS;
            }
            this._cmds.push(cmd);
            this._render = this._cmds.length === 1 ? this._renderOne : this._renderAll;
            this._repaint();
            return cmd;
        }
        removeCmd(cmd) {
            let i = this.cmds.indexOf(cmd);
            if (i != -1) {
                this._cmds.splice(i, 1);
                let len = this._cmds.length;
                this._render = len === 0 ? this._renderEmpty : (len === 1 ? this._renderOne : this._renderAll);
                this._repaint();
            }
        }
        getBounds(realSize = false) {
            this._initGraphicBounds();
            return this._graphicBounds.getBounds(realSize);
        }
        getBoundPoints(realSize = false) {
            this._initGraphicBounds();
            return this._graphicBounds.getBoundPoints(realSize);
        }
        get material() {
            return this._material;
        }
        set material(value) {
            if (this._material == value)
                return;
            this._material && this._material._removeReference();
            this._material = value;
            if (value != null)
                value._addReference();
        }
        drawImage(texture, x = 0, y = 0, width = null, height = null, color = null) {
            if (!texture)
                return null;
            if (!texture.bitmap)
                return null;
            return this.addCmd(DrawImageCmd.create(texture, x, y, width, height, color));
        }
        drawTexture(texture, x = 0, y = 0, width = null, height = null, matrix = null, alpha = 1, color = null, blendMode = null, uv) {
            if (!texture || alpha < 0.01)
                return null;
            if (!texture.bitmap)
                return null;
            return this.addCmd(DrawTextureCmd.create(texture, x, y, width, height, matrix, alpha, color, blendMode, uv));
        }
        drawTextures(texture, pos, colors) {
            if (!texture)
                return null;
            return this.addCmd(DrawTexturesCmd.create(texture, pos, colors));
        }
        drawGeo(geo, material) {
            return this.addCmd(DrawGeoCmd.create(geo, material));
        }
        drawGeos(geo, elements) {
            return this.addCmd(DrawGeosCmd.create(geo, elements));
        }
        drawTriangles(texture, x, y, vertices, uvs, indices, matrix = null, alpha = 1, color = null, blendMode = null) {
            return this.addCmd(DrawTrianglesCmd.create(texture, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode));
        }
        fillTexture(texture, x, y, width = 0, height = 0, type = "repeat", offset = null, color = null) {
            if (texture && texture.bitmap)
                return this.addCmd(FillTextureCmd.create(texture, x, y, width, height, type, offset || Point.EMPTY, color));
            else
                return null;
        }
        clipRect(x, y, width, height) {
            return this.addCmd(ClipRectCmd.create(x, y, width, height));
        }
        fillText(text, x, y, font, color, textAlign) {
            return this.addCmd(FillTextCmd.create(text, x, y, font, color, textAlign, 0, ""));
        }
        fillBorderText(text, x, y, font, fillColor, textAlign, lineWidth, borderColor) {
            return this.addCmd(FillTextCmd.create(text, x, y, font, fillColor, textAlign, lineWidth, borderColor));
        }
        strokeText(text, x, y, font, color, lineWidth, textAlign) {
            return this.addCmd(FillTextCmd.create(text, x, y, font, null, textAlign, lineWidth, color));
        }
        alpha(alpha) {
            return this.addCmd(AlphaCmd.create(alpha));
        }
        transform(matrix, pivotX = 0, pivotY = 0) {
            return this.addCmd(TransformCmd.create(matrix, pivotX, pivotY));
        }
        rotate(angle, pivotX = 0, pivotY = 0) {
            return this.addCmd(RotateCmd.create(angle, pivotX, pivotY));
        }
        scale(scaleX, scaleY, pivotX = 0, pivotY = 0) {
            return this.addCmd(ScaleCmd.create(scaleX, scaleY, pivotX, pivotY));
        }
        translate(tx, ty) {
            return this.addCmd(TranslateCmd.create(tx, ty));
        }
        save() {
            return this.addCmd(SaveCmd.create());
        }
        restore() {
            return this.addCmd(RestoreCmd.create());
        }
        replaceTextColor(color) {
            this._repaint();
            let cmds = this._cmds;
            for (let i = cmds.length - 1; i > -1; i--) {
                let cmd = cmds[i];
                var cmdID = cmd.cmdID;
                switch (cmdID) {
                    case FillTextCmd.ID:
                        cmd.color = color;
                        break;
                    case DrawImageCmd.ID:
                        cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
                        break;
                }
            }
        }
        loadImage(url, x = 0, y = 0, width = null, height = null, complete = null) {
            let tex = ILaya.loader.getRes(url);
            if (tex) {
                this.drawImage(tex, x, y, width, height);
                complete && complete.call(this._sp);
            }
            else {
                ILaya.loader.load(url).then((tex) => {
                    this.drawImage(tex, x, y, width, height);
                    complete && complete.call(this._sp);
                });
            }
        }
        _renderEmpty(sprite, context, x, y) {
        }
        _renderAll(sprite, context, x, y) {
            context.sprite = sprite;
            context._material = this._material;
            var cmds = this._cmds;
            for (let i = 0, n = cmds.length; i < n; i++) {
                cmds[i].run(context, x, y);
            }
            context._material = null;
        }
        _renderOne(sprite, context, x, y) {
            context.sprite = sprite;
            context._material = this._material;
            this._cmds[0].run(context, x, y);
            context._material = null;
        }
        drawLine(fromX, fromY, toX, toY, lineColor, lineWidth = 1) {
            return this.addCmd(DrawLineCmd.create(fromX, fromY, toX, toY, lineColor, lineWidth));
        }
        drawLines(x, y, points, lineColor, lineWidth = 1) {
            if (!points || points.length < 4)
                return null;
            return this.addCmd(DrawLinesCmd.create(x, y, points, lineColor, lineWidth));
        }
        drawCurves(x, y, points, lineColor, lineWidth = 1) {
            return this.addCmd(DrawCurvesCmd.create(x, y, points, lineColor, lineWidth));
        }
        drawRect(x, y, width, height, fillColor, lineColor = null, lineWidth = 1, percent) {
            return this.addCmd(DrawRectCmd.create(x, y, width, height, fillColor, lineColor, lineWidth, percent));
        }
        drawRoundRect(x, y, width, height, lt, rt, lb, rb, fillColor, lineColor = null, lineWidth = 1, percent) {
            return this.addCmd(DrawRoundRectCmd.create(x, y, width, height, lt, rt, lb, rb, fillColor, lineColor, lineWidth, percent));
        }
        drawCircle(x, y, radius, fillColor, lineColor = null, lineWidth = 1) {
            return this.addCmd(DrawCircleCmd.create(x, y, radius, fillColor, lineColor, lineWidth));
        }
        drawEllipse(x, y, width, height, fillColor, lineColor, lineWidth, percent) {
            return this.addCmd(DrawEllipseCmd.create(x, y, width, height, fillColor, lineColor, lineWidth, percent));
        }
        drawPie(x, y, radius, startAngle, endAngle, fillColor, lineColor = null, lineWidth = 1) {
            return this.addCmd(DrawPieCmd.create(x, y, radius, Utils.toRadian(startAngle), Utils.toRadian(endAngle), fillColor, lineColor, lineWidth));
        }
        drawPoly(x, y, points, fillColor, lineColor = null, lineWidth = 1) {
            return this.addCmd(DrawPolyCmd.create(x, y, points, fillColor, lineColor, lineWidth));
        }
        drawPath(x, y, paths, brush = null, pen = null) {
            return this.addCmd(DrawPathCmd.create(x, y, paths, brush, pen));
        }
        draw9Grid(texture, x = 0, y = 0, width = 0, height = 0, sizeGrid, color) {
            this.addCmd(Draw9GridTextureCmd.create(texture, x, y, width, height, sizeGrid, false, color));
        }
    }

    const ARRAY_EMPTY = [];
    class Node extends EventDispatcher {
        get url() {
            return this._url;
        }
        set url(path) {
            this._url = path;
        }
        get hideFlags() {
            return this._hideFlags;
        }
        set hideFlags(value) {
            this._hideFlags = value;
        }
        get is3D() {
            return this._is3D;
        }
        get destroyed() {
            return this._destroyed;
        }
        constructor() {
            super();
            this._bits = 0;
            this._hideFlags = 0;
            this._children = ARRAY_EMPTY;
            this._parent = null;
            this._destroyed = false;
            this.name = "";
            this._initialize();
        }
        _initialize() {
            this._extra = {};
        }
        _setBit(type, value) {
            if (type === NodeFlags.DISPLAY) {
                var preValue = this._getBit(type);
                if (preValue != value)
                    this._updateDisplayedInstage();
            }
            if (value)
                this._bits |= type;
            else
                this._bits &= ~type;
        }
        _getBit(type) {
            return (this._bits & type) != 0;
        }
        _updateDisplayedInstage() {
            var ele;
            ele = this;
            var stage = ILaya.stage;
            var displayedInStage = false;
            while (ele) {
                if (ele._getBit(NodeFlags.DISPLAY)) {
                    displayedInStage = ele._getBit(NodeFlags.DISPLAYED_INSTAGE);
                    break;
                }
                if (ele === stage || ele._getBit(NodeFlags.DISPLAYED_INSTAGE)) {
                    displayedInStage = true;
                    break;
                }
                ele = ele._parent;
            }
            this._setBit(NodeFlags.DISPLAYED_INSTAGE, displayedInStage);
        }
        _setUpNoticeChain() {
            if (this._getBit(NodeFlags.DISPLAY))
                this._setBitUp(NodeFlags.DISPLAY);
        }
        _setBitUp(type) {
            var ele = this;
            ele._setBit(type, true);
            ele = ele._parent;
            while (ele) {
                if (ele._getBit(type))
                    return;
                ele._setBit(type, true);
                ele = ele._parent;
            }
        }
        onStartListeningToType(type) {
            if (type === Event.DISPLAY || type === Event.UNDISPLAY) {
                if (!this._getBit(NodeFlags.DISPLAY))
                    this._setBitUp(NodeFlags.DISPLAY);
            }
        }
        bubbleEvent(type, data) {
            let arr = _bubbleChainPool.length > 0 ? _bubbleChainPool.pop() : [];
            arr.length = 0;
            let obj = this;
            while (obj) {
                if (obj.activeInHierarchy)
                    arr.push(obj);
                obj = obj.parent;
            }
            if (data instanceof Event) {
                data._stopped = false;
                for (let obj of arr) {
                    data.setTo(type, obj, this);
                    obj.event(type, data);
                    if (data._stopped)
                        break;
                }
            }
            else {
                for (let obj of arr)
                    obj.event(type, data);
            }
            _bubbleChainPool.push(arr);
        }
        hasHideFlag(flag) {
            return (this._hideFlags & flag) != 0;
        }
        destroy(destroyChild = true) {
            this._destroyed = true;
            this.destroyAllComponent();
            this._parent && this._parent.removeChild(this);
            if (this._children) {
                if (destroyChild)
                    this.destroyChildren();
                else
                    this.removeChildren();
            }
            this.onDestroy();
            this._children = null;
            this.offAll();
        }
        onDestroy() {
        }
        destroyChildren() {
            if (this._children) {
                for (let i = 0, n = this._children.length; i < n; i++) {
                    this._children[0] && this._children[0].destroy(true);
                }
            }
        }
        addChild(node) {
            if (!node || this._destroyed || node === this)
                return node;
            if (node._zOrder)
                this._setBit(NodeFlags.HAS_ZORDER, true);
            if (node._parent === this) {
                var index = this.getChildIndex(node);
                if (index !== this._children.length - 1) {
                    this._children.splice(index, 1);
                    this._children.push(node);
                    this._childChanged();
                }
            }
            else {
                node._parent && node._parent.removeChild(node);
                this._children === ARRAY_EMPTY && (this._children = []);
                this._children.push(node);
                node._setParent(this);
            }
            return node;
        }
        addChildren(...args) {
            var i = 0, n = args.length;
            while (i < n) {
                this.addChild(args[i++]);
            }
        }
        addChildAt(node, index) {
            if (!node || this._destroyed || node === this)
                return node;
            if (node._zOrder)
                this._setBit(NodeFlags.HAS_ZORDER, true);
            if (index >= 0 && index <= this._children.length) {
                if (node._parent === this) {
                    var oldIndex = this.getChildIndex(node);
                    this._children.splice(oldIndex, 1);
                    this._children.splice(index, 0, node);
                    this._childChanged();
                }
                else {
                    node._parent && node._parent.removeChild(node);
                    this._children === ARRAY_EMPTY && (this._children = []);
                    this._children.splice(index, 0, node);
                    node._setParent(this);
                }
                return node;
            }
            else {
                throw new OutOfRangeError(index);
            }
        }
        getChildIndex(node) {
            return this._children.indexOf(node);
        }
        getChildByName(name) {
            for (let child of this._children) {
                if (child && child.name === name)
                    return child;
            }
            return null;
        }
        getChildAt(index) {
            return this._children[index] || null;
        }
        setChildIndex(node, index) {
            var childs = this._children;
            if (index < 0 || index >= childs.length) {
                throw new OutOfRangeError(index);
            }
            var oldIndex = this.getChildIndex(node);
            if (oldIndex < 0)
                throw new Error("node must be a child of this object.");
            childs.splice(oldIndex, 1);
            childs.splice(index, 0, node);
            this._childChanged();
            return node;
        }
        _childChanged(child = null) {
        }
        removeChild(node) {
            if (!this._children)
                return node;
            var index = this._children.indexOf(node);
            return this.removeChildAt(index);
        }
        removeSelf() {
            this._parent && this._parent.removeChild(this);
            return this;
        }
        removeChildByName(name) {
            var node = this.getChildByName(name);
            node && this.removeChild(node);
            return node;
        }
        removeChildAt(index) {
            var node = this.getChildAt(index);
            if (node) {
                this._children.splice(index, 1);
                node._setParent(null);
            }
            return node;
        }
        removeChildren(beginIndex = 0, endIndex = 0x7fffffff) {
            if (this._children && this._children.length > 0) {
                var childs = this._children;
                if (beginIndex === 0 && endIndex >= childs.length - 1) {
                    var arr = childs;
                    this._children = ARRAY_EMPTY;
                }
                else {
                    arr = childs.splice(beginIndex, endIndex - beginIndex + 1);
                }
                for (var i = 0, n = arr.length; i < n; i++) {
                    arr[i]._setParent(null);
                }
            }
            return this;
        }
        replaceChild(newNode, oldNode) {
            var index = this._children.indexOf(oldNode);
            if (index > -1) {
                this._children.splice(index, 1, newNode);
                oldNode._setParent(null);
                newNode._setParent(this);
                return newNode;
            }
            return null;
        }
        get numChildren() {
            return this._children ? this._children.length : 0;
        }
        get parent() {
            return this._parent;
        }
        isAncestorOf(node) {
            let p = node.parent;
            while (p) {
                if (p == this)
                    return true;
                p = p.parent;
            }
            return false;
        }
        ;
        _setParent(value) {
            if (this._parent !== value) {
                if (value) {
                    this._parent = value;
                    this._onAdded();
                    this.event(Event.ADDED);
                    if (this._getBit(NodeFlags.DISPLAY)) {
                        this._setUpNoticeChain();
                        value.displayedInStage && this._displayChild(this, true);
                    }
                    value._childChanged(this);
                }
                else {
                    this._onRemoved();
                    this.event(Event.REMOVED);
                    let p = this._parent;
                    if (this._getBit(NodeFlags.DISPLAY))
                        this._displayChild(this, false);
                    this._parent = value;
                    p._childChanged(this);
                }
            }
        }
        get displayedInStage() {
            if (this._getBit(NodeFlags.DISPLAY))
                return this._getBit(NodeFlags.DISPLAYED_INSTAGE);
            this._setBitUp(NodeFlags.DISPLAY);
            return this._getBit(NodeFlags.DISPLAYED_INSTAGE);
        }
        _setDisplay(value) {
            if (this._getBit(NodeFlags.DISPLAYED_INSTAGE) !== value) {
                this._setBit(NodeFlags.DISPLAYED_INSTAGE, value);
                if (value)
                    this.event(Event.DISPLAY);
                else
                    this.event(Event.UNDISPLAY);
            }
        }
        _displayChild(node, display) {
            var childs = node._children;
            if (childs) {
                for (var i = 0, n = childs.length; i < n; i++) {
                    var child = childs[i];
                    if (!child)
                        continue;
                    if (!child._getBit(NodeFlags.DISPLAY))
                        continue;
                    if (child._children.length > 0) {
                        this._displayChild(child, display);
                    }
                    else {
                        child._setDisplay(display);
                    }
                }
            }
            node._setDisplay(display);
        }
        contains(node) {
            if (node === this)
                return true;
            while (node) {
                if (node._parent === this)
                    return true;
                node = node._parent;
            }
            return false;
        }
        timerLoop(delay, caller, method, args = null, coverBefore = true, jumpFrame = false) {
            this.timer.loop(delay, caller, method, args, coverBefore, jumpFrame);
        }
        timerOnce(delay, caller, method, args = null, coverBefore = true) {
            this.timer._create(false, false, delay, caller, method, args, coverBefore);
        }
        frameLoop(delay, caller, method, args = null, coverBefore = true) {
            this.timer._create(true, true, delay, caller, method, args, coverBefore);
        }
        frameOnce(delay, caller, method, args = null, coverBefore = true) {
            this.timer._create(true, false, delay, caller, method, args, coverBefore);
        }
        clearTimer(caller, method) {
            this.timer.clear(caller, method);
        }
        callLater(method, args = null) {
            this.timer.callLater(this, method, args);
        }
        runCallLater(method) {
            this.timer.runCallLater(this, method);
        }
        get scene() {
            return this._scene;
        }
        get active() {
            return !this._getBit(NodeFlags.NOT_READY) && !this._getBit(NodeFlags.NOT_ACTIVE);
        }
        set active(value) {
            value = !!value;
            if (!this._getBit(NodeFlags.NOT_ACTIVE) !== value) {
                if (this._activeChangeScripts && this._activeChangeScripts.length !== 0) {
                    throw new Error("recursive set active");
                }
                else {
                    this._setBit(NodeFlags.NOT_ACTIVE, !value);
                    if (this._parent) {
                        if (this._parent.activeInHierarchy) {
                            this._processActive(value, true);
                        }
                    }
                }
            }
        }
        get activeInHierarchy() {
            return this._getBit(NodeFlags.ACTIVE_INHIERARCHY);
        }
        _onActive() {
            Stat.spriteCount++;
        }
        _onInActive() {
            Stat.spriteCount--;
        }
        _onActiveInScene() {
            this.event(Node.EVENT_SET_ACTIVESCENE, this._scene);
        }
        _onInActiveInScene() {
            this.event(Node.EVENT_SET_IN_ACTIVESCENE, this._scene);
        }
        onAwake() {
        }
        onEnable() {
        }
        onDisable() {
        }
        _parse(data, spriteMap) {
        }
        _setBelongScene(scene) {
            if (!this._scene || this.scene != scene) {
                this._scene = scene;
                this._onActiveInScene();
                for (let i = 0, n = this._children.length; i < n; i++)
                    this._children[i]._setBelongScene(scene);
            }
        }
        _setUnBelongScene() {
            if (this._scene !== this) {
                this._onInActiveInScene();
                this._scene = null;
                for (let i = 0, n = this._children.length; i < n; i++)
                    this._children[i]._setUnBelongScene();
            }
        }
        _processActive(active, fromSetter) {
            (this._activeChangeScripts) || (this._activeChangeScripts = []);
            let arr = this._activeChangeScripts;
            if (active)
                this._activeHierarchy(arr, fromSetter);
            else
                this._inActiveHierarchy(arr, fromSetter);
            for (let i = 0, n = arr.length; i < n; i++) {
                let comp = arr[i];
                comp.owner && comp._setActive(active);
            }
            arr.length = 0;
        }
        _activeHierarchy(activeChangeScripts, fromSetter) {
            this._setBit(NodeFlags.ACTIVE_INHIERARCHY, true);
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    let comp = this._components[i];
                    if (comp._isScript())
                        (comp._enabled) && (activeChangeScripts.push(comp));
                    else
                        comp._setActive(true);
                }
            }
            this._onActive();
            for (let i = 0, n = this._children.length; i < n; i++) {
                let child = this._children[i];
                (!child._getBit(NodeFlags.NOT_ACTIVE) && !child._getBit(NodeFlags.NOT_READY)) && (child._activeHierarchy(activeChangeScripts, fromSetter));
            }
            if (!this._getBit(NodeFlags.AWAKED)) {
                this._setBit(NodeFlags.AWAKED, true);
                this.onAwake();
            }
            this.onEnable();
        }
        _inActiveHierarchy(activeChangeScripts, fromSetter) {
            this._onInActive();
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    let comp = this._components[i];
                    if (comp._isScript())
                        comp._enabled && (activeChangeScripts.push(comp));
                    else
                        comp._setActive(false);
                }
            }
            this._setBit(NodeFlags.ACTIVE_INHIERARCHY, false);
            for (let i = 0, n = this._children.length; i < n; i++) {
                let child = this._children[i];
                (child && !child._getBit(NodeFlags.NOT_ACTIVE)) && (child._inActiveHierarchy(activeChangeScripts, fromSetter));
            }
            this.onDisable();
        }
        _onAdded() {
            if (this._activeChangeScripts && this._activeChangeScripts.length !== 0) {
                throw new Error("recursive set active");
            }
            else {
                let parentScene = this._parent.scene;
                parentScene && this._setBelongScene(parentScene);
                (this._parent.activeInHierarchy && this.active) && this._processActive(true);
            }
        }
        _onRemoved() {
            if (this._activeChangeScripts && this._activeChangeScripts.length !== 0) {
                throw new Error("recursive set active");
            }
            else {
                (this._parent.activeInHierarchy && this.active) && this._processActive(false);
                this._parent.scene && this._setUnBelongScene();
            }
        }
        _addComponentInstance(comp) {
            var _a;
            if (!this._components)
                this._components = [];
            this._components.push(comp);
            comp._setOwner(this);
            if (this.activeInHierarchy)
                comp._setActive(true);
            (_a = this._componentsChanged) === null || _a === void 0 ? void 0 : _a.call(this, comp, 0);
        }
        _destroyComponent(comp) {
            var _a;
            if (!this._components)
                return;
            let i = this._components.indexOf(comp);
            if (i != -1) {
                this._components.splice(i, 1);
                comp._destroy();
                (_a = this._componentsChanged) === null || _a === void 0 ? void 0 : _a.call(this, comp, 1);
            }
        }
        destroyAllComponent() {
            var _a;
            if (!this._components)
                return;
            for (let i = 0, n = this._components.length; i < n; i++) {
                let item = this._components[i];
                item && !item.destroyed && item._destroy();
            }
            this._components.length = 0;
            (_a = this._componentsChanged) === null || _a === void 0 ? void 0 : _a.call(this, null, 2);
        }
        _cloneTo(destObject, srcRoot, dstRoot) {
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    var destComponent = destObject.addComponent(this._components[i].constructor);
                    this._components[i]._cloneTo(destComponent);
                }
            }
        }
        addComponentInstance(component) {
            if (component.owner)
                throw new Error("the component is belong to other node.");
            if (component._singleton && this.getComponent(component.constructor))
                console.warn("the component is singleton, can't add the second one.", component);
            else
                this._addComponentInstance(component);
            return component;
        }
        addComponent(componentType) {
            let comp = Pool.createByClass(componentType);
            if (!comp) {
                throw new Error("missing " + componentType.toString());
            }
            if (comp._singleton && this.getComponent(componentType))
                console.warn("the component is singleton, can't add the second one.", comp);
            else
                this._addComponentInstance(comp);
            return comp;
        }
        getComponent(componentType) {
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    let comp = this._components[i];
                    if (comp instanceof componentType)
                        return comp;
                }
            }
            return null;
        }
        get components() {
            return this._components || ARRAY_EMPTY;
        }
        getComponents(componentType) {
            var arr;
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    let comp = this._components[i];
                    if (comp instanceof componentType) {
                        arr = arr || [];
                        arr.push(comp);
                    }
                }
            }
            return arr;
        }
        get timer() {
            return this._scene ? this._scene.timer : ILaya.timer;
        }
        onAfterDeserialize() { }
    }
    Node.EVENT_SET_ACTIVESCENE = "ActiveScene";
    Node.EVENT_SET_IN_ACTIVESCENE = "InActiveScene";
    const _bubbleChainPool = [];

    const HALF_PI = Math.PI * 0.5;
    const PI2 = Math.PI * 2;
    class Ease {
        static linearNone(t, b, c, d) {
            return c * t / d + b;
        }
        static linearIn(t, b, c, d) {
            return c * t / d + b;
        }
        static linearInOut(t, b, c, d) {
            return c * t / d + b;
        }
        static linearOut(t, b, c, d) {
            return c * t / d + b;
        }
        static bounceIn(t, b, c, d) {
            return c - Ease.bounceOut(d - t, 0, c, d) + b;
        }
        static bounceInOut(t, b, c, d) {
            if (t < d * 0.5)
                return Ease.bounceIn(t * 2, 0, c, d) * .5 + b;
            else
                return Ease.bounceOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
        }
        static bounceOut(t, b, c, d) {
            if ((t /= d) < (1 / 2.75))
                return c * (7.5625 * t * t) + b;
            else if (t < (2 / 2.75))
                return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
            else if (t < (2.5 / 2.75))
                return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
            else
                return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
        }
        static backIn(t, b, c, d, s = 1.70158) {
            return c * (t /= d) * t * ((s + 1) * t - s) + b;
        }
        static backInOut(t, b, c, d, s = 1.70158) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
            return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
        }
        static backOut(t, b, c, d, s = 1.70158) {
            return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
        }
        static elasticIn(t, b, c, d, a = 0, p = 0) {
            var s;
            if (t == 0)
                return b;
            if ((t /= d) == 1)
                return b + c;
            if (!p)
                p = d * .3;
            if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
                a = c;
                s = p / 4;
            }
            else
                s = p / PI2 * Math.asin(c / a);
            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * PI2 / p)) + b;
        }
        static elasticInOut(t, b, c, d, a = 0, p = 0) {
            var s;
            if (t == 0)
                return b;
            if ((t /= d * 0.5) == 2)
                return b + c;
            if (!p)
                p = d * (.3 * 1.5);
            if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
                a = c;
                s = p / 4;
            }
            else
                s = p / PI2 * Math.asin(c / a);
            if (t < 1)
                return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * PI2 / p)) + b;
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * PI2 / p) * .5 + c + b;
        }
        static elasticOut(t, b, c, d, a = 0, p = 0) {
            var s;
            if (t == 0)
                return b;
            if ((t /= d) == 1)
                return b + c;
            if (!p)
                p = d * .3;
            if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
                a = c;
                s = p / 4;
            }
            else
                s = p / PI2 * Math.asin(c / a);
            return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * PI2 / p) + c + b);
        }
        static strongIn(t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        }
        static strongInOut(t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t * t * t * t + b;
            return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b;
        }
        static strongOut(t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        }
        static sineInOut(t, b, c, d) {
            return -c * 0.5 * (Math.cos(Math.PI * t / d) - 1) + b;
        }
        static sineIn(t, b, c, d) {
            return -c * Math.cos(t / d * HALF_PI) + c + b;
        }
        static sineOut(t, b, c, d) {
            return c * Math.sin(t / d * HALF_PI) + b;
        }
        static quintIn(t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        }
        static quintInOut(t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t * t * t * t + b;
            return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b;
        }
        static quintOut(t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        }
        static quartIn(t, b, c, d) {
            return c * (t /= d) * t * t * t + b;
        }
        static quartInOut(t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t * t * t + b;
            return -c * 0.5 * ((t -= 2) * t * t * t - 2) + b;
        }
        static quartOut(t, b, c, d) {
            return -c * ((t = t / d - 1) * t * t * t - 1) + b;
        }
        static cubicIn(t, b, c, d) {
            return c * (t /= d) * t * t + b;
        }
        static cubicInOut(t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t * t + b;
            return c * 0.5 * ((t -= 2) * t * t + 2) + b;
        }
        static cubicOut(t, b, c, d) {
            return c * ((t = t / d - 1) * t * t + 1) + b;
        }
        static quadIn(t, b, c, d) {
            return c * (t /= d) * t + b;
        }
        static quadInOut(t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * t * t + b;
            return -c * 0.5 * ((--t) * (t - 2) - 1) + b;
        }
        static quadOut(t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        }
        static expoIn(t, b, c, d) {
            return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b - c * 0.001;
        }
        static expoInOut(t, b, c, d) {
            if (t == 0)
                return b;
            if (t == d)
                return b + c;
            if ((t /= d * 0.5) < 1)
                return c * 0.5 * Math.pow(2, 10 * (t - 1)) + b;
            return c * 0.5 * (-Math.pow(2, -10 * --t) + 2) + b;
        }
        static expoOut(t, b, c, d) {
            return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
        }
        static circIn(t, b, c, d) {
            return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
        }
        static circInOut(t, b, c, d) {
            if ((t /= d * 0.5) < 1)
                return -c * 0.5 * (Math.sqrt(1 - t * t) - 1) + b;
            return c * 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
        }
        static circOut(t, b, c, d) {
            return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
        }
    }

    class Tween {
        constructor() {
            this.gid = 0;
            this.repeat = 1;
            this._count = 0;
        }
        static to(target, props, duration, ease = null, complete = null, delay = 0, coverBefore = false, autoRecover = true) {
            return Pool.getItemByClass("tween", Tween)._create(target, props, duration, ease, complete, delay, coverBefore, true, autoRecover, true);
        }
        static from(target, props, duration, ease = null, complete = null, delay = 0, coverBefore = false, autoRecover = true) {
            return Pool.getItemByClass("tween", Tween)._create(target, props, duration, ease, complete, delay, coverBefore, false, autoRecover, true);
        }
        to(target, props, duration, ease = null, complete = null, delay = 0, coverBefore = false) {
            return this._create(target, props, duration, ease, complete, delay, coverBefore, true, false, true);
        }
        from(target, props, duration, ease = null, complete = null, delay = 0, coverBefore = false) {
            return this._create(target, props, duration, ease, complete, delay, coverBefore, false, false, true);
        }
        _create(target, props, duration, ease, complete, delay, coverBefore, isTo, usePool, runNow) {
            if (!target)
                throw new Error("Tween:target is null");
            this._target = target;
            this._duration = duration;
            this._ease = ease || props.ease || Tween.easeNone;
            this._complete = complete || props.complete;
            this._delay = delay;
            this._props = [];
            this._usedTimer = 0;
            this._startTimer = Browser.now();
            this._usedPool = usePool;
            this._delayParam = null;
            this.update = props.update;
            var gid = (target.$_GID || (target.$_GID = Utils.getGID()));
            if (!Tween.tweenMap[gid]) {
                Tween.tweenMap[gid] = [this];
            }
            else {
                if (coverBefore)
                    Tween.clearTween(target);
                Tween.tweenMap[gid].push(this);
            }
            if (runNow) {
                if (delay <= 0)
                    this.firstStart(target, props, isTo);
                else {
                    this._delayParam = [target, props, isTo];
                    ILaya.timer.once(delay, this, this.firstStart, this._delayParam);
                }
            }
            else {
                this._initProps(target, props, isTo);
            }
            return this;
        }
        firstStart(target, props, isTo) {
            this._delayParam = null;
            if (target.destroyed) {
                this.clear();
                return;
            }
            this._initProps(target, props, isTo);
            this._beginLoop();
        }
        _initProps(target, props, isTo) {
            for (var p in props) {
                if (typeof (target[p]) == 'number') {
                    var start = isTo ? target[p] : props[p];
                    var end = isTo ? props[p] : target[p];
                    this._props.push([p, start, end - start]);
                    if (!isTo)
                        target[p] = start;
                }
            }
        }
        _beginLoop() {
            ILaya.timer.frameLoop(1, this, this._doEase);
        }
        _doEase() {
            this._updateEase(Browser.now());
        }
        _updateEase(time) {
            var target = this._target;
            if (!target)
                return;
            if (target.destroyed)
                return Tween.clearTween(target);
            var usedTimer = this._usedTimer = time - this._startTimer - this._delay;
            if (usedTimer < 0)
                return;
            if (usedTimer >= this._duration)
                return this.complete();
            var ratio = usedTimer > 0 ? this._ease(usedTimer, 0, 1, this._duration) : 0;
            var props = this._props;
            for (var i = 0, n = props.length; i < n; i++) {
                var prop = props[i];
                target[prop[0]] = prop[1] + (ratio * prop[2]);
            }
            if (this.update)
                this.update.run();
        }
        set progress(v) {
            var uTime = v * this._duration;
            this._startTimer = Browser.now() - this._delay - uTime;
        }
        complete() {
            if (!this._target)
                return;
            ILaya.timer.runTimer(this, this.firstStart);
            var target = this._target;
            var props = this._props;
            var handler = this._complete;
            for (var i = 0, n = props.length; i < n; i++) {
                var prop = props[i];
                target[prop[0]] = prop[1] + prop[2];
            }
            if (this.update)
                this.update.run();
            this._count++;
            if (this.repeat != 0 && this._count >= this.repeat) {
                this.clear();
                handler && handler.run();
            }
            else {
                this.restart();
            }
        }
        pause() {
            ILaya.timer.clear(this, this._beginLoop);
            ILaya.timer.clear(this, this._doEase);
            ILaya.timer.clear(this, this.firstStart);
            var time = Browser.now();
            var dTime;
            dTime = time - this._startTimer - this._delay;
            if (dTime < 0) {
                this._usedTimer = dTime;
            }
        }
        setStartTime(startTime) {
            this._startTimer = startTime;
        }
        static clearAll(target) {
            if (!target || !target.$_GID)
                return;
            var tweens = Tween.tweenMap[target.$_GID];
            if (tweens) {
                for (var i = 0, n = tweens.length; i < n; i++) {
                    tweens[i]._clear();
                }
                tweens.length = 0;
            }
        }
        static clear(tween) {
            tween.clear();
        }
        static clearTween(target) {
            Tween.clearAll(target);
        }
        clear() {
            if (this._target) {
                this._remove();
                this._clear();
            }
        }
        _clear() {
            this.pause();
            ILaya.timer.clear(this, this.firstStart);
            this._complete = null;
            this._target = null;
            this._ease = null;
            this._props = null;
            this._delayParam = null;
            this.repeat = 1;
            if (this._usedPool) {
                this.update = null;
                Pool.recover("tween", this);
            }
        }
        recover() {
            this._usedPool = true;
            this._clear();
        }
        _remove() {
            var tweens = Tween.tweenMap[this._target.$_GID];
            if (tweens) {
                for (var i = 0, n = tweens.length; i < n; i++) {
                    if (tweens[i] === this) {
                        tweens.splice(i, 1);
                        break;
                    }
                }
            }
        }
        restart() {
            this.pause();
            this._usedTimer = 0;
            this._startTimer = Browser.now();
            if (this._delayParam) {
                ILaya.timer.once(this._delay, this, this.firstStart, this._delayParam);
                return;
            }
            var props = this._props;
            for (var i = 0, n = props.length; i < n; i++) {
                var prop = props[i];
                this._target[prop[0]] = prop[1];
            }
            ILaya.timer.once(this._delay, this, this._beginLoop);
        }
        resume() {
            if (this._usedTimer >= this._duration)
                return;
            this._startTimer = Browser.now() - this._usedTimer - this._delay;
            if (this._delayParam) {
                if (this._usedTimer < 0) {
                    ILaya.timer.once(-this._usedTimer, this, this.firstStart, this._delayParam);
                }
                else {
                    this.firstStart.apply(this, this._delayParam);
                }
            }
            else {
                this._beginLoop();
            }
        }
        static easeNone(t, b, c, d) {
            return c * t / d + b;
        }
    }
    Tween.tweenMap = [];

    class Dragging {
        constructor() {
            this.ratio = 0.92;
            this.maxOffset = 60;
            this._dragging = false;
            this._clickOnly = true;
        }
        start(target, area, hasInertia, elasticDistance, elasticBackTime, data, ratio = 0.92) {
            this.clearTimer();
            this.target = target;
            this.area = area;
            this.hasInertia = hasInertia;
            this.elasticDistance = area ? elasticDistance : 0;
            this.elasticBackTime = elasticBackTime;
            this.data = data;
            this.ratio = ratio;
            this._parent = target.parent;
            this._clickOnly = true;
            this._dragging = true;
            this._elasticRateX = this._elasticRateY = 1;
            this._lastX = this._parent.mouseX;
            this._lastY = this._parent.mouseY;
            ILaya.stage.on(Event.MOUSE_UP, this, this.onStageMouseUp);
            ILaya.stage.on(Event.MOUSE_OUT, this, this.onStageMouseUp);
            ILaya.systemTimer.frameLoop(1, this, this.loop);
        }
        clearTimer() {
            ILaya.systemTimer.clear(this, this.loop);
            ILaya.systemTimer.clear(this, this.tweenMove);
            if (this._tween) {
                this._tween.recover();
                this._tween = null;
            }
        }
        stop() {
            if (this._dragging) {
                ILaya.stage.off(Event.MOUSE_UP, this, this.onStageMouseUp);
                ILaya.stage.off(Event.MOUSE_OUT, this, this.onStageMouseUp);
                this._dragging = false;
                this.target && this.area && this.backToArea();
                this.clear();
            }
        }
        loop() {
            var point = this._parent.getMousePoint();
            var mouseX = point.x;
            var mouseY = point.y;
            var offsetX = mouseX - this._lastX;
            var offsetY = mouseY - this._lastY;
            if (this._clickOnly) {
                if (Math.abs(offsetX * ILaya.stage._canvasTransform.getScaleX()) > 1 || Math.abs(offsetY * ILaya.stage._canvasTransform.getScaleY()) > 1) {
                    this._clickOnly = false;
                    this._offsets || (this._offsets = []);
                    this._offsets.length = 0;
                    this.target.event(Event.DRAG_START, this.data);
                }
                else
                    return;
            }
            else {
                this._offsets.push(offsetX, offsetY);
            }
            if (offsetX === 0 && offsetY === 0)
                return;
            this._lastX = mouseX;
            this._lastY = mouseY;
            this.target.x += offsetX * this._elasticRateX;
            this.target.y += offsetY * this._elasticRateY;
            this.area && this.checkArea();
            this.target.event(Event.DRAG_MOVE, this.data);
        }
        checkArea() {
            if (this.elasticDistance <= 0) {
                this.backToArea();
            }
            else {
                if (this.target._x < this.area.x) {
                    var offsetX = this.area.x - this.target._x;
                }
                else if (this.target._x > this.area.x + this.area.width) {
                    offsetX = this.target._x - this.area.x - this.area.width;
                }
                else {
                    offsetX = 0;
                }
                this._elasticRateX = Math.max(0, 1 - (offsetX / this.elasticDistance));
                if (this.target._y < this.area.y) {
                    var offsetY = this.area.y - this.target.y;
                }
                else if (this.target._y > this.area.y + this.area.height) {
                    offsetY = this.target._y - this.area.y - this.area.height;
                }
                else {
                    offsetY = 0;
                }
                this._elasticRateY = Math.max(0, 1 - (offsetY / this.elasticDistance));
            }
        }
        backToArea() {
            this.target.x = Math.min(Math.max(this.target._x, this.area.x), this.area.x + this.area.width);
            this.target.y = Math.min(Math.max(this.target._y, this.area.y), this.area.y + this.area.height);
        }
        onStageMouseUp(e) {
            ILaya.stage.off(Event.MOUSE_UP, this, this.onStageMouseUp);
            ILaya.stage.off(Event.MOUSE_OUT, this, this.onStageMouseUp);
            ILaya.systemTimer.clear(this, this.loop);
            if (this._clickOnly || !this.target)
                return;
            if (this.hasInertia) {
                if (this._offsets.length < 1) {
                    this._offsets.push(this._parent.mouseX - this._lastX, this._parent.mouseY - this._lastY);
                }
                this._offsetX = this._offsetY = 0;
                var len = this._offsets.length;
                var n = Math.min(len, 6);
                var m = this._offsets.length - n;
                for (var i = len - 1; i > m; i--) {
                    this._offsetY += this._offsets[i--];
                    this._offsetX += this._offsets[i];
                }
                this._offsetX = this._offsetX / n * 2;
                this._offsetY = this._offsetY / n * 2;
                if (Math.abs(this._offsetX) > this.maxOffset)
                    this._offsetX = this._offsetX > 0 ? this.maxOffset : -this.maxOffset;
                if (Math.abs(this._offsetY) > this.maxOffset)
                    this._offsetY = this._offsetY > 0 ? this.maxOffset : -this.maxOffset;
                ILaya.systemTimer.frameLoop(1, this, this.tweenMove);
            }
            else if (this.elasticDistance > 0) {
                this.checkElastic();
            }
            else {
                this.clear();
            }
        }
        checkElastic() {
            var tx = NaN;
            var ty = NaN;
            if (this.target.x < this.area.x)
                tx = this.area.x;
            else if (this.target._x > this.area.x + this.area.width)
                tx = this.area.x + this.area.width;
            if (this.target.y < this.area.y)
                ty = this.area.y;
            else if (this.target._y > this.area.y + this.area.height)
                ty = this.area.y + this.area.height;
            if (!isNaN(tx) || !isNaN(ty)) {
                var obj = {};
                if (!isNaN(tx))
                    obj.x = tx;
                if (!isNaN(ty))
                    obj.y = ty;
                this._tween = Tween.to(this.target, obj, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.clear), 0, false, false);
            }
            else {
                this.clear();
            }
        }
        tweenMove() {
            this._offsetX *= this.ratio * this._elasticRateX;
            this._offsetY *= this.ratio * this._elasticRateY;
            this.target.x += this._offsetX;
            this.target.y += this._offsetY;
            this.area && this.checkArea();
            this.target.event(Event.DRAG_MOVE, this.data);
            if ((Math.abs(this._offsetX) < 1 && Math.abs(this._offsetY) < 1) || this._elasticRateX < 0.5 || this._elasticRateY < 0.5) {
                ILaya.systemTimer.clear(this, this.tweenMove);
                if (this.elasticDistance > 0)
                    this.checkElastic();
                else
                    this.clear();
            }
        }
        clear() {
            if (this.target) {
                this.clearTimer();
                var sp = this.target;
                this.target = null;
                this._parent = null;
                sp.event(Event.DRAG_END, this.data);
            }
        }
    }

    class SpriteUtils {
        static getGlobalRecByPoints(sprite, x0, y0, x1, y1) {
            var newLTPoint;
            newLTPoint = Point.create().setTo(x0, y0);
            newLTPoint = sprite.localToGlobal(newLTPoint);
            var newRBPoint;
            newRBPoint = Point.create().setTo(x1, y1);
            newRBPoint = sprite.localToGlobal(newRBPoint);
            var rst = Rectangle._getWrapRec([newLTPoint.x, newLTPoint.y, newRBPoint.x, newRBPoint.y]);
            newLTPoint.recover();
            newRBPoint.recover();
            return rst;
        }
        static getGlobalPosAndScale(sprite) {
            return SpriteUtils.getGlobalRecByPoints(sprite, 0, 0, 1, 1);
        }
        static getTransformRelativeToWindow(coordinateSpace, x, y) {
            var stage = ILaya.stage;
            var globalTransform = SpriteUtils.getGlobalPosAndScale(coordinateSpace);
            var canvasMatrix = stage._canvasTransform.clone();
            var canvasLeft = canvasMatrix.tx;
            var canvasTop = canvasMatrix.ty;
            canvasMatrix.rotate(-Math.PI / 180 * stage.canvasDegree);
            canvasMatrix.scale(stage.clientScaleX, stage.clientScaleY);
            var perpendicular = (stage.canvasDegree % 180 != 0);
            var tx, ty;
            if (perpendicular) {
                tx = y + globalTransform.y;
                ty = x + globalTransform.x;
                tx *= canvasMatrix.d;
                ty *= canvasMatrix.a;
                if (stage.canvasDegree == 90) {
                    tx = canvasLeft - tx;
                    ty += canvasTop;
                }
                else {
                    tx += canvasLeft;
                    ty = canvasTop - ty;
                }
            }
            else {
                tx = x + globalTransform.x;
                ty = y + globalTransform.y;
                tx *= canvasMatrix.a;
                ty *= canvasMatrix.d;
                tx += canvasLeft;
                ty += canvasTop;
            }
            ty += stage['_safariOffsetY'];
            var domScaleX, domScaleY;
            if (perpendicular) {
                domScaleX = canvasMatrix.d * globalTransform.height;
                domScaleY = canvasMatrix.a * globalTransform.width;
            }
            else {
                domScaleX = canvasMatrix.a * globalTransform.width;
                domScaleY = canvasMatrix.d * globalTransform.height;
            }
            return { x: tx, y: ty, scaleX: domScaleX, scaleY: domScaleY };
        }
        static fitDOMElementInArea(dom, coordinateSpace, x, y, width, height) {
            if (!dom._fitLayaAirInitialized) {
                dom._fitLayaAirInitialized = true;
                dom.style.transformOrigin = dom.style.webKittransformOrigin = "left top";
                dom.style.position = "absolute";
            }
            var transform = SpriteUtils.getTransformRelativeToWindow(coordinateSpace, x, y);
            dom.style.transform = dom.style.webkitTransform = "scale(" + transform.scaleX + "," + transform.scaleY + ") rotate(" + (ILaya.stage.canvasDegree) + "deg)";
            dom.style.width = width + 'px';
            dom.style.height = height + 'px';
            dom.style.left = transform.x + 'px';
            dom.style.top = transform.y + 'px';
        }
        static updateOrder(array) {
            if (!array || array.length < 2)
                return false;
            var i = 1, j, len = array.length, key, c;
            while (i < len) {
                j = i;
                c = array[j];
                key = array[j]._zOrder;
                while (--j > -1) {
                    if (array[j]._zOrder > key)
                        array[j + 1] = array[j];
                    else
                        break;
                }
                array[j + 1] = c;
                i++;
            }
            return true;
        }
    }

    class Sprite extends Node {
        destroy(destroyChild = true) {
            super.destroy(destroyChild);
            this._style && this._style.recover();
            this._cacheStyle && this._cacheStyle.recover();
            this._boundStyle && this._boundStyle.recover();
            this._transform && this._transform.recover();
            this._style = null;
            this._cacheStyle = null;
            this._boundStyle = null;
            this._transform = null;
            this._texture && this._texture._removeReference();
            this._texture = null;
            this._graphics && this._ownGraphics && this._graphics.destroy();
            this._graphics = null;
        }
        constructor() {
            super();
            this._x = 0;
            this._y = 0;
            this._width = 0;
            this._height = 0;
            this._anchorX = 0;
            this._anchorY = 0;
            this._visible = true;
            this._mouseState = 0;
            this._zOrder = 0;
            this._renderType = 0;
            this._transform = null;
            this._tfChanged = false;
            this._repaint = SpriteConst.REPAINT_NONE;
            this._texture = null;
            this._sizeFlag = 0;
            this._style = SpriteStyle.EMPTY;
            this._cacheStyle = CacheStyle.EMPTY;
            this._filterArr = null;
            this._boundStyle = null;
            this._graphics = null;
            this._renderNode = null;
            this._ownGraphics = false;
            this.mouseThrough = false;
            this.hitTestPrior = false;
            this.autoSize = false;
            this._globalDeltaFlages = 0;
            this._cacheGlobal = false;
            this._globalPosx = 0.0;
            this._globalPosy = 0.0;
            this._globalRotate = 0.0;
            this._globalScalex = 1.0;
            this._globalScaley = 1.0;
        }
        get scene() {
            return this._scene;
        }
        updateZOrder() {
            SpriteUtils.updateOrder(this._children) && this.repaint();
        }
        _getBoundsStyle() {
            if (!this._boundStyle)
                this._boundStyle = BoundsStyle.create();
            return this._boundStyle;
        }
        _setCustomRender() {
        }
        set customRenderEnable(b) {
            if (b) {
                this._renderType |= SpriteConst.CUSTOM;
                this._setCustomRender();
            }
        }
        get cacheAs() {
            return this._getCacheStyle().userSetCache;
        }
        set cacheAs(value) {
            if (value === this._cacheStyle.userSetCache)
                return;
            this._getCacheStyle().userSetCache = value;
            if (this.mask && value === 'normal')
                return;
            if (value == 'bitmap' || value == 'normal') {
                this._renderType |= SpriteConst.CANVAS;
            }
            else {
                this._renderType &= ~SpriteConst.CANVAS;
            }
            this.repaint();
        }
        get staticCache() {
            return this._getCacheStyle().staticCache;
        }
        set staticCache(value) {
            this._getCacheStyle().staticCache = value;
            if (!value)
                this.reCache();
        }
        reCache() {
            this._repaint |= SpriteConst.REPAINT_CACHE;
        }
        get renderNode2D() {
            return this._renderNode;
        }
        set renderNode2D(value) {
            if (value) {
                this._renderType |= SpriteConst.RENDERNODE2D;
                this._renderNode = value;
            }
            else {
                this._renderType &= ~SpriteConst.RENDERNODE2D;
            }
        }
        getRepaint() {
            return this._repaint;
        }
        _setX(value) {
            this._x = value;
        }
        _setY(value) {
            this._y = value;
        }
        get x() {
            return this._x;
        }
        set x(value) {
            if (this._destroyed)
                return;
            if (this._x !== value) {
                this._setX(value);
                if (this.cacheGlobal) {
                    this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Position_X | Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                    this._syncGlobalFlag(Sprite.Sprite_GlobalDeltaFlage_Position_X | Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                }
                this.parentRepaint(SpriteConst.REPAINT_CACHE);
                var p = this._getCacheStyle().maskParent;
                if (p) {
                    p.repaint(SpriteConst.REPAINT_CACHE);
                }
            }
        }
        get y() {
            return this._y;
        }
        set y(value) {
            if (this._destroyed)
                return;
            if (this._y !== value) {
                this._setY(value);
                if (this.cacheGlobal) {
                    this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Position_Y | Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                    this._syncGlobalFlag(Sprite.Sprite_GlobalDeltaFlage_Position_Y | Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                }
                this.parentRepaint(SpriteConst.REPAINT_CACHE);
                var p = this._getCacheStyle().maskParent;
                if (p) {
                    p.repaint(SpriteConst.REPAINT_CACHE);
                }
            }
        }
        get width() {
            return this.get_width();
        }
        set width(value) {
            this.set_width(value);
        }
        set_width(value) {
            let flag = this._sizeFlag;
            if (value == null) {
                value = 0;
                this._sizeFlag &= ~1;
            }
            else if (value == 0)
                this._sizeFlag |= 1;
            else
                this._sizeFlag &= ~1;
            if (this._width !== value || flag != this._sizeFlag) {
                this._width = value;
                this._setWidth(value);
                this._setPivotX(this._anchorX * value);
                if (this._graphics)
                    this._graphics._clearBoundsCache(true);
                this._setTranformChange();
                this._shouldRefreshLayout();
            }
        }
        get_width() {
            if (!this.autoSize)
                return (this._width == 0 && (this._sizeFlag & 1) == 0 && this.texture) ? this.texture.width : this._width;
            if (this.texture)
                return this.texture.width;
            if (!this._graphics && this._children.length === 0)
                return 0;
            return this.getSelfBounds().width;
        }
        get height() {
            return this.get_height();
        }
        set height(value) {
            this.set_height(value);
        }
        set_height(value) {
            let flag = this._sizeFlag;
            if (value == null) {
                value = 0;
                this._sizeFlag &= ~2;
            }
            else if (value == 0)
                this._sizeFlag |= 2;
            else
                this._sizeFlag &= ~2;
            if (this._height !== value || flag != this._sizeFlag) {
                this._height = value;
                this._setHeight(value);
                this._setPivotY(this._anchorY * value);
                if (this._graphics)
                    this._graphics._clearBoundsCache(true);
                this._setTranformChange();
                this._shouldRefreshLayout();
            }
        }
        get_height() {
            if (!this.autoSize)
                return (this._height == 0 && (this._sizeFlag & 2) == 0 && this.texture) ? this.texture.height : this._height;
            if (this.texture)
                return this.texture.height;
            if (!this._graphics && this._children.length === 0)
                return 0;
            return this.getSelfBounds().height;
        }
        get _isWidthSet() {
            return this._width != 0 || (this._sizeFlag & 1) != 0;
        }
        get _isHeightSet() {
            return this._height != 0 || (this._sizeFlag & 2) != 0;
        }
        _setWidth(value) {
        }
        _setHeight(value) {
        }
        _shouldRefreshLayout() {
        }
        get displayWidth() {
            return this.width * this.scaleX;
        }
        get displayHeight() {
            return this.height * this.scaleY;
        }
        setSelfBounds(bound) {
            this._getBoundsStyle().userBounds = bound;
        }
        getBounds() {
            return this._getBoundsStyle().bounds = Rectangle._getWrapRec(this._boundPointsToParent());
        }
        getSelfBounds() {
            if (this._boundStyle && this._boundStyle.userBounds)
                return this._boundStyle.userBounds;
            if (!this._graphics && this._children.length === 0 && !this._texture)
                return Rectangle.TEMP.setTo(0, 0, this.width, this.height);
            return this._getBoundsStyle().bounds = Rectangle._getWrapRec(this._getBoundPointsM(false));
        }
        _boundPointsToParent(ifRotate = false) {
            let pX = 0, pY = 0;
            if (this._style) {
                pX = this.pivotX;
                pY = this.pivotY;
                ifRotate = ifRotate || (this._style.rotation !== 0);
                if (this._style.scrollRect) {
                    pX += this._style.scrollRect.x;
                    pY += this._style.scrollRect.y;
                }
            }
            let pList = this._getBoundPointsM(ifRotate);
            if (!pList || pList.length < 1)
                return pList;
            if (pList.length != 8) {
                pList = ifRotate ? GrahamScan.scanPList(pList) : Rectangle._getWrapRec(pList, Rectangle.TEMP)._getBoundPoints();
            }
            if (!this.transform) {
                Utils.transPointList(pList, this._x - pX, this._y - pY);
                return pList;
            }
            let tPoint = Point.TEMP;
            let len = pList.length;
            for (let i = 0; i < len; i += 2) {
                tPoint.x = pList[i];
                tPoint.y = pList[i + 1];
                this.toParentPoint(tPoint);
                pList[i] = tPoint.x;
                pList[i + 1] = tPoint.y;
            }
            return pList;
        }
        _getBoundPointsM(ifRotate = false) {
            if (this._boundStyle && this._boundStyle.userBounds)
                return this._boundStyle.userBounds._getBoundPoints();
            if (!this._boundStyle)
                this._getBoundsStyle();
            let rst = this._boundStyle.temBM;
            if (!rst)
                rst = this._boundStyle.temBM = [];
            if (this._style.scrollRect && !this._getBit(NodeFlags.DISABLE_INNER_CLIPPING)) {
                rst.length = 0;
                var rec = Rectangle.TEMP;
                rec.copyFrom(this._style.scrollRect);
                rst.push(...rec._getBoundPoints());
                return rst;
            }
            let pList;
            if (this._graphics) {
                pList = this._graphics.getBoundPoints();
            }
            else {
                rst.length = 0;
                pList = rst;
            }
            if (this._renderNode) {
                rec = Rectangle.TEMP;
                rec.setTo(0, 0, this.width, this.height);
                pList.push(...rec._getBoundPoints());
            }
            if (this._texture) {
                rec = Rectangle.TEMP;
                rec.setTo(0, 0, this.width || this._texture.width, this.height || this._texture.height);
                pList.push(...rec._getBoundPoints());
            }
            let chidren = this._children;
            for (let i = 0, n = chidren.length; i < n; i++) {
                let child = chidren[i];
                if (child._visible === true && child._cacheStyle.maskParent != this) {
                    let cList = child._boundPointsToParent(ifRotate);
                    if (cList) {
                        if (pList)
                            pList.push(...cList);
                        else
                            pList = cList;
                    }
                }
            }
            return pList;
        }
        getGraphicBounds(realSize = false) {
            if (!this._graphics)
                return Rectangle.TEMP.setTo(0, 0, 0, 0);
            return this._graphics.getBounds(realSize);
        }
        _getCacheStyle() {
            this._cacheStyle === CacheStyle.EMPTY && (this._cacheStyle = CacheStyle.create());
            return this._cacheStyle;
        }
        getStyle() {
            this._style === SpriteStyle.EMPTY && (this._style = SpriteStyle.create());
            return this._style;
        }
        setStyle(value) {
            this._style = value;
        }
        get scaleX() {
            return this._style.scaleX;
        }
        set scaleX(value) {
            this.set_scaleX(value);
        }
        get scaleY() {
            return this._style.scaleY;
        }
        set scaleY(value) {
            this.set_scaleY(value);
        }
        set_scaleX(value) {
            var style = this.getStyle();
            if (style.scaleX !== value) {
                if (this.cacheGlobal) {
                    this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Scale_X | Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                    this._syncGlobalFlag(Sprite.Sprite_GlobalDeltaFlage_Scale_X | Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                }
                this._setScaleX(value);
                this._setTranformChange();
                this._shouldRefreshLayout();
            }
        }
        get_scaleX() {
            return this._style.scaleX;
        }
        set_scaleY(value) {
            var style = this.getStyle();
            if (style.scaleY !== value) {
                if (this.cacheGlobal) {
                    this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Scale_Y | Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                    this._syncGlobalFlag(Sprite.Sprite_GlobalDeltaFlage_Scale_Y | Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                }
                this._setScaleY(value);
                this._setTranformChange();
                this._shouldRefreshLayout();
            }
        }
        get_scaleY() {
            return this._style.scaleY;
        }
        _setScaleX(value) {
            this._style.scaleX = value;
        }
        _setScaleY(value) {
            this._style.scaleY = value;
        }
        get rotation() {
            return this._style.rotation;
        }
        set rotation(value) {
            var style = this.getStyle();
            if (style.rotation !== value) {
                if (this.cacheGlobal) {
                    this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Rotation | Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                    this._syncGlobalFlag(Sprite.Sprite_GlobalDeltaFlage_Rotation | Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                }
                this._setRotation(value);
                this._setTranformChange();
            }
        }
        _setRotation(value) {
            this.getStyle().rotation = value;
        }
        get skewX() {
            return this._style.skewX;
        }
        set skewX(value) {
            var style = this.getStyle();
            if (style.skewX !== value) {
                this._setSkewX(value);
                this._setTranformChange();
            }
        }
        _setSkewX(value) {
            this._style.skewX = value;
        }
        get skewY() {
            return this._style.skewY;
        }
        set skewY(value) {
            var style = this.getStyle();
            if (style.skewY !== value) {
                this._setSkewY(value);
                this._setTranformChange();
            }
        }
        _setSkewY(value) {
            this._style.skewY = value;
        }
        _createTransform() {
            return Matrix.create();
        }
        _adjustTransform() {
            this._tfChanged = false;
            var style = this._style;
            var sx = style.scaleX, sy = style.scaleY;
            var sskx = style.skewX;
            var ssky = style.skewY;
            var rot = style.rotation;
            var m = this._transform || (this._transform = this._createTransform());
            if (rot || sx !== 1 || sy !== 1 || sskx !== 0 || ssky !== 0) {
                m._bTransform = true;
                var skx = (rot - sskx) * 0.0174532922222222;
                var sky = (rot + ssky) * 0.0174532922222222;
                var cx = Math.cos(sky);
                var ssx = Math.sin(sky);
                var cy = Math.sin(skx);
                var ssy = Math.cos(skx);
                m.a = sx * cx;
                m.b = sx * ssx;
                m.c = -sy * cy;
                m.d = sy * ssy;
                m.tx = m.ty = 0;
            }
            else {
                m.identity();
                this._renderType &= ~SpriteConst.TRANSFORM;
            }
            return m;
        }
        _setTransform(value) {
        }
        get transform() {
            return this._tfChanged ? this._adjustTransform() : this._transform;
        }
        set transform(value) {
            this.set_transform(value);
        }
        get_transform() {
            return this._tfChanged ? this._adjustTransform() : this._transform;
        }
        set_transform(value) {
            this._tfChanged = false;
            var m = this._transform || (this._transform = this._createTransform());
            value.copyTo(m);
            this._setTransform(m);
            if (value) {
                this._x = m.tx;
                this._y = m.ty;
                m.tx = m.ty = 0;
            }
            if (value)
                this._renderType |= SpriteConst.TRANSFORM;
            else {
                this._renderType &= ~SpriteConst.TRANSFORM;
            }
            this.parentRepaint();
        }
        _getPivotX() {
            return this._style.pivotX;
        }
        _setPivotX(value) {
            var style = this.getStyle();
            style.pivotX = value;
        }
        _getPivotY() {
            return this._style.pivotY;
        }
        _setPivotY(value) {
            var style = this.getStyle();
            style.pivotY = value;
        }
        get pivotX() {
            return this._getPivotX();
        }
        set pivotX(value) {
            var style = this.getStyle();
            if (style.pivotX != value) {
                this._setPivotX(value);
                let t = this.width;
                if (t != 0)
                    this._anchorX = value / t;
                this._shouldRefreshLayout();
                this.repaint();
            }
        }
        get pivotY() {
            return this._getPivotY();
        }
        set pivotY(value) {
            var style = this.getStyle();
            if (style.pivotY != value) {
                this._setPivotY(value);
                let t = this.height;
                if (t != 0)
                    this._anchorY = value / t;
                this._shouldRefreshLayout();
                this.repaint();
            }
        }
        get anchorX() {
            return this.get_anchorX();
        }
        get_anchorX() {
            return this._anchorX;
        }
        set anchorX(value) {
            this.set_anchorX(value);
        }
        set_anchorX(value) {
            if (isNaN(value))
                value = null;
            if (this._anchorX != value) {
                this._anchorX = value;
                if (value != null) {
                    this._setPivotX(value * this.width);
                    this._shouldRefreshLayout();
                    this.repaint();
                }
            }
        }
        get anchorY() {
            return this.get_anchorY();
        }
        get_anchorY() {
            return this._anchorY;
        }
        set anchorY(value) {
            this.set_anchorY(value);
        }
        set_anchorY(value) {
            if (isNaN(value))
                value = null;
            if (this._anchorY != value) {
                this._anchorY = value;
                if (value != null) {
                    this._setPivotY(value * this.height);
                    this._shouldRefreshLayout();
                    this.repaint();
                }
            }
        }
        _setAlpha(value) {
            if (this._style.alpha !== value) {
                var style = this.getStyle();
                style.alpha = value;
                if (value !== 1)
                    this._renderType |= SpriteConst.ALPHA;
                else
                    this._renderType &= ~SpriteConst.ALPHA;
                this.parentRepaint();
            }
        }
        _getAlpha() {
            return this._style.alpha;
        }
        get alpha() {
            return this._getAlpha();
        }
        set alpha(value) {
            value = value < 0 ? 0 : (value > 1 ? 1 : value);
            this._setAlpha(value);
        }
        get visible() {
            return this.get_visible();
        }
        set visible(value) {
            this.set_visible(value);
        }
        get_visible() {
            return this._visible;
        }
        set_visible(value) {
            if (this._visible !== value) {
                this._visible = value;
                this.parentRepaint(SpriteConst.REPAINT_ALL);
            }
        }
        get blendMode() {
            return this._style.blendMode;
        }
        set blendMode(value) {
            if (this.getStyle().blendMode != value) {
                this.getStyle().blendMode = value;
                if (value && value != "source-over")
                    this._renderType |= SpriteConst.BLEND;
                else
                    this._renderType &= ~SpriteConst.BLEND;
                this.parentRepaint();
            }
        }
        get graphics() {
            if (!this._graphics) {
                this.graphics = new Graphics();
                this._ownGraphics = true;
            }
            return this._graphics;
        }
        set graphics(value) {
            this.setGraphics(value, false);
        }
        setGraphics(value, transferOwnership) {
            if (this._graphics) {
                this._graphics._sp = null;
                if (this._ownGraphics)
                    this._graphics.destroy();
            }
            this._ownGraphics = transferOwnership;
            this._graphics = value;
            if (value) {
                this._renderType |= SpriteConst.GRAPHICS;
                value._sp = this;
            }
            else {
                this._renderType &= ~SpriteConst.GRAPHICS;
            }
            this.repaint();
        }
        get material() {
            var _a;
            return (_a = this._graphics) === null || _a === void 0 ? void 0 : _a.material;
        }
        set material(value) {
            if (this._graphics == null && value == null)
                return;
            this.graphics.material = value;
        }
        get scrollRect() {
            return this._style.scrollRect;
        }
        set scrollRect(value) {
            if (this.getStyle().scrollRect == null && value == null)
                return;
            this.getStyle().scrollRect = value;
            if (value) {
                this._renderType |= SpriteConst.CLIP;
            }
            else {
                this._renderType &= ~SpriteConst.CLIP;
            }
            this.repaint();
        }
        get viewport() {
            return this._style.viewport;
        }
        set viewport(value) {
            if (typeof (value) == 'string') {
                let recArr = value.split(",");
                if (recArr.length > 3) {
                    value = new Rectangle(parseFloat(recArr[0]), parseFloat(recArr[1]), parseFloat(recArr[2]), parseFloat(recArr[3]));
                }
            }
            this.getStyle().viewport = value;
        }
        pos(x, y, speedMode = false) {
            if (this._x !== x || this._y !== y) {
                if (this._destroyed)
                    return this;
                if (speedMode) {
                    this._setX(x);
                    this._setY(y);
                    this.parentRepaint(SpriteConst.REPAINT_CACHE);
                    var p = this._cacheStyle.maskParent;
                    if (p) {
                        p.repaint(SpriteConst.REPAINT_CACHE);
                    }
                    if (this.cacheGlobal) {
                        let flag = Sprite.Sprite_GlobalDeltaFlage_Position_X | Sprite.Sprite_GlobalDeltaFlage_Position_Y;
                        this._setGlobalCacheFlag(flag, true);
                        this._syncGlobalFlag(flag, true);
                    }
                }
                else {
                    this.x = x;
                    this.y = y;
                }
            }
            return this;
        }
        pivot(x, y) {
            this.pivotX = x;
            this.pivotY = y;
            return this;
        }
        size(width, height) {
            this.width = width;
            this.height = height;
            return this;
        }
        scale(scaleX, scaleY, speedMode) {
            if (this._destroyed)
                return this;
            var style = this.getStyle();
            if (style.scaleX != scaleX || style.scaleY != scaleY) {
                if (speedMode) {
                    this._setScaleX(scaleX);
                    this._setScaleY(scaleY);
                    this._setTranformChange();
                    this._shouldRefreshLayout();
                }
                else {
                    this.scaleX = scaleX;
                    this.scaleY = scaleY;
                }
            }
            return this;
        }
        skew(skewX, skewY) {
            this.skewX = skewX;
            this.skewY = skewY;
            return this;
        }
        render(ctx, x, y) {
            RenderSprite.renders[this._renderType]._fun(this, ctx, x + this._x, y + this._y);
            this._repaint = 0;
        }
        drawToCanvas(canvasWidth, canvasHeight, offsetX, offsetY) {
            return Sprite.drawToCanvas(this, canvasWidth, canvasHeight, offsetX, offsetY);
        }
        static drawToCanvas(sprite, canvasWidth, canvasHeight, offsetX, offsetY, isDrawRenderRect = true) {
            let rt = Sprite.drawToRenderTexture2D(sprite, canvasWidth, canvasHeight, offsetX, offsetY, null);
            var dt = rt.getData(0, 0, canvasWidth, canvasHeight);
            var imgdata = new ImageData(canvasWidth, canvasHeight);
            var lineLen = canvasWidth * 4;
            var dst = imgdata.data;
            var y = canvasHeight - 1;
            var off = y * lineLen;
            var srcoff = 0;
            for (; y >= 0; y--) {
                dst.set(dt.subarray(srcoff, srcoff + lineLen), off);
                off -= lineLen;
                srcoff += lineLen;
            }
            var canv = new HTMLCanvas(true);
            canv.size(canvasWidth, canvasHeight);
            var ctx2d = canv.getContext('2d');
            ctx2d.putImageData(imgdata, 0, 0);
            rt.destroy();
            return canv;
        }
        drawToTexture(canvasWidth, canvasHeight, offsetX, offsetY, rt = null, isDrawRenderRect = true) {
            let res = Sprite.drawToTexture(this, canvasWidth, canvasHeight, offsetX, offsetY, rt, isDrawRenderRect);
            return res;
        }
        static drawToTexture(sprite, canvasWidth, canvasHeight, offsetX, offsetY, rt = null, isDrawRenderRect = true) {
            let renderout = rt || new RenderTexture2D(canvasWidth, canvasHeight, exports.RenderTargetFormat.R8G8B8A8);
            let ctx = new Context();
            if (rt) {
                ctx.size(rt.width, rt.height);
            }
            else {
                ctx.size(canvasWidth, canvasHeight);
            }
            ctx.render2D = ctx.render2D.clone(renderout);
            ctx._drawingToTexture = true;
            let outrt = RenderSprite.RenderToRenderTexture(sprite, ctx, offsetX, offsetY, renderout, isDrawRenderRect);
            ctx._drawingToTexture = false;
            ctx.destroy();
            if (!rt) {
                let outTexture = new Texture(outrt, Texture.INV_UV);
                return outTexture;
            }
            return outrt;
        }
        drawToRenderTexture2D(canvasWidth, canvasHeight, offsetX, offsetY, rt = null, isDrawRenderRect = true, flipY = false) {
            let res = Sprite.drawToRenderTexture2D(this, canvasWidth, canvasHeight, offsetX, offsetY, rt, isDrawRenderRect, flipY);
            return res;
        }
        static drawToRenderTexture2D(sprite, canvasWidth, canvasHeight, offsetX, offsetY, rt = null, isDrawRenderRect = true, flipY = false) {
            let renderout = rt || new RenderTexture2D(canvasWidth, canvasHeight, exports.RenderTargetFormat.R8G8B8A8);
            let ctx = new Context();
            if (rt) {
                ctx.size(rt.width, rt.height);
            }
            else {
                ctx.size(canvasWidth, canvasHeight);
            }
            ctx.render2D = ctx.render2D.clone(renderout);
            ctx._drawingToTexture = true;
            if (flipY) {
                renderout._invertY = true;
            }
            let outrt = RenderSprite.RenderToRenderTexture(sprite, ctx, offsetX, offsetY, renderout, isDrawRenderRect);
            ctx._drawingToTexture = false;
            ctx.destroy();
            return outrt;
        }
        customRender(context, x, y) {
            this._repaint = SpriteConst.REPAINT_ALL;
        }
        _applyFilters() {
        }
        get filters() {
            return this._filterArr;
        }
        set filters(value) {
            value && value.length === 0 && (value = null);
            if (this._filterArr) {
                for (let f of this._filterArr) {
                    f && f.off(Filter.EVENT_CHANGE, this, this.repaint);
                }
            }
            this._filterArr = value ? value.slice() : null;
            if (value) {
                for (let f of value) {
                    f && f.on(Filter.EVENT_CHANGE, this, this.repaint);
                }
            }
            if (value)
                this._renderType |= SpriteConst.FILTERS;
            else
                this._renderType &= ~SpriteConst.FILTERS;
            if (value && value.length > 0) {
                if (!this._getBit(NodeFlags.DISPLAY))
                    this._setBitUp(NodeFlags.DISPLAY);
            }
            this.repaint();
        }
        localToGlobal(point, createNewPoint = false, globalNode = null) {
            if (createNewPoint === true) {
                point = new Point(point.x, point.y);
            }
            var ele = this;
            globalNode = globalNode || ILaya.stage;
            while (ele && !ele._destroyed) {
                if (ele == globalNode)
                    break;
                point = ele.toParentPoint(point);
                ele = ele.parent;
            }
            return point;
        }
        globalToLocal(point, createNewPoint = false, globalNode = null) {
            if (createNewPoint) {
                point = new Point(point.x, point.y);
            }
            var ele = this;
            var list = [];
            globalNode = globalNode || ILaya.stage;
            while (ele && !ele._destroyed) {
                if (ele == globalNode)
                    break;
                list.push(ele);
                ele = ele.parent;
            }
            var i = list.length - 1;
            while (i >= 0) {
                ele = list[i];
                point = ele.fromParentPoint(point);
                i--;
            }
            return point;
        }
        toParentPoint(point) {
            if (!point)
                return point;
            point.x -= this.pivotX;
            point.y -= this.pivotY;
            if (this.transform) {
                this._transform.transformPoint(point);
            }
            point.x += this._x;
            point.y += this._y;
            var scroll = this._style.scrollRect;
            if (scroll) {
                point.x -= scroll.x * this._style.scaleX;
                point.y -= scroll.y * this._style.scaleY;
            }
            return point;
        }
        fromParentPoint(point) {
            if (!point)
                return point;
            point.x -= this._x;
            point.y -= this._y;
            var scroll = this._style.scrollRect;
            if (scroll) {
                point.x += scroll.x * this._style.scaleX;
                point.y += scroll.y * this._style.scaleY;
            }
            if (this.transform) {
                this._transform.invertTransformPoint(point);
            }
            point.x += this.pivotX;
            point.y += this.pivotY;
            return point;
        }
        onStartListeningToType(type) {
            super.onStartListeningToType(type);
            if (this._mouseState !== 1 && Event.isMouseEvent(type)) {
                this.mouseEnabled = true;
                this._setBit(NodeFlags.HAS_MOUSE, true);
                if (this._parent) {
                    this._onDisplay();
                }
            }
        }
        _onDisplay(v) {
            if (this._mouseState !== 1) {
                var ele = this;
                ele = ele.parent;
                while (ele && ele._mouseState !== 1) {
                    if (ele._getBit(NodeFlags.HAS_MOUSE))
                        break;
                    ele.mouseEnabled = true;
                    ele._setBit(NodeFlags.HAS_MOUSE, true);
                    ele = ele.parent;
                }
            }
        }
        _setParent(value) {
            super._setParent(value);
            if (value && this._getBit(NodeFlags.HAS_MOUSE)) {
                this._onDisplay();
            }
        }
        loadImage(url, complete = null) {
            if (!url) {
                this.texture = null;
                this.repaint(SpriteConst.REPAINT_ALL);
                complete && complete.run();
            }
            else {
                let tex = ILaya.loader.getRes(url);
                if (tex) {
                    this.texture = tex;
                    this.repaint(SpriteConst.REPAINT_ALL);
                    complete && complete.run();
                }
                else {
                    if (this._skinBaseUrl)
                        url = URL.formatURL(url, this._skinBaseUrl);
                    ILaya.loader.load(url).then((tex) => {
                        this.texture = tex;
                        this.repaint(SpriteConst.REPAINT_ALL);
                        complete && complete.run();
                    });
                }
            }
            return this;
        }
        static fromImage(url) {
            return new Sprite().loadImage(url);
        }
        repaint(type = SpriteConst.REPAINT_CACHE) {
            if (!(this._repaint & type)) {
                this._repaint |= type;
                this.parentRepaint(type);
            }
            this._getCacheStyle();
            if (this._cacheStyle) {
                this._cacheStyle.renderTexture = null;
            }
            if (this._cacheStyle && this._cacheStyle.maskParent) {
                this._cacheStyle.maskParent.repaint(type);
            }
        }
        _needRepaint() {
            return !!(this._repaint & SpriteConst.REPAINT_CACHE);
        }
        _childChanged(child = null) {
            super._childChanged(child);
            if (this._children.length)
                this._renderType |= SpriteConst.CHILDS;
            else
                this._renderType &= ~SpriteConst.CHILDS;
            if (child && this._getBit(NodeFlags.HAS_ZORDER))
                ILaya.systemTimer.callLater(this, this.updateZOrder);
            this.repaint(SpriteConst.REPAINT_ALL);
        }
        parentRepaint(type = SpriteConst.REPAINT_CACHE) {
            var p = this._parent;
            if (p && !(p._repaint & type)) {
                p._repaint |= type;
                p.parentRepaint(type);
            }
        }
        get stage() {
            return ILaya.stage;
        }
        get hitArea() {
            return this._style.hitArea;
        }
        set hitArea(value) {
            this.getStyle().hitArea = value;
        }
        _setMask(value) {
        }
        get mask() {
            return this._cacheStyle.mask;
        }
        set mask(value) {
            if (value == this || (value && this.mask == value && value._cacheStyle.maskParent == this))
                return;
            if (this.mask)
                this.mask._getCacheStyle().maskParent = null;
            this._getCacheStyle().mask = value;
            this._setMask(value);
            if (value) {
                value._getCacheStyle().maskParent = this;
                this._renderType |= SpriteConst.MASK;
            }
            else
                this._renderType &= ~SpriteConst.MASK;
            this.repaint();
        }
        get mouseEnabled() {
            return this._mouseState > 1;
        }
        set mouseEnabled(value) {
            this._mouseState = value ? 2 : 1;
        }
        startDrag(area = null, hasInertia = false, elasticDistance = 0, elasticBackTime = 300, data = null, ratio = 0.92) {
            this._style.dragging || (this.getStyle().dragging = new Dragging());
            this._style.dragging.start(this, area, hasInertia, elasticDistance, elasticBackTime, data, ratio);
        }
        stopDrag() {
            this._style.dragging && this._style.dragging.stop();
        }
        _setDisplay(value) {
            this._getCacheStyle();
            if (!value) {
                this._cacheStyle.onInvisible();
            }
            super._setDisplay(value);
        }
        hitTestPoint(x, y) {
            var point = this.globalToLocal(Point.TEMP.setTo(x, y));
            x = point.x;
            y = point.y;
            var rect = this._style.hitArea ? this._style.hitArea : (this._isWidthSet && this._isHeightSet) ? Rectangle.TEMP.setTo(0, 0, this._width, this._height) : this.getSelfBounds();
            return rect.contains(x, y, this);
        }
        getMousePoint() {
            return this.globalToLocal(Point.TEMP.setTo(ILaya.stage.mouseX, ILaya.stage.mouseY));
        }
        get mouseX() {
            return this.getMousePoint().x;
        }
        get mouseY() {
            return this.getMousePoint().y;
        }
        get zOrder() {
            return this._zOrder;
        }
        set zOrder(value) {
            if (this._zOrder != value) {
                this._zOrder = value;
                if (this._parent) {
                    value && this._parent._setBit(NodeFlags.HAS_ZORDER, true);
                    ILaya.systemTimer.callLater(this._parent, this.updateZOrder);
                }
            }
        }
        get texture() {
            return this._texture;
        }
        _setTexture(value) {
        }
        set texture(value) {
            if (typeof (value) == 'string') {
                this.loadImage(value);
            }
            else if (this._texture != value) {
                this._texture && this._texture._removeReference();
                this._texture = value;
                value && value._addReference();
                this._setTexture(value);
                this._setWidth(this.width);
                this._setHeight(this.height);
                if (value)
                    this._renderType |= SpriteConst.TEXTURE;
                else
                    this._renderType &= ~SpriteConst.TEXTURE;
                this.repaint();
            }
        }
        _setTranformChange() {
            this._tfChanged = true;
            this._renderType |= SpriteConst.TRANSFORM;
            this.parentRepaint(SpriteConst.REPAINT_CACHE);
        }
        set drawCallOptimize(value) {
            this._setBit(NodeFlags.DRAWCALL_OPTIMIZE, value);
        }
        get drawCallOptimize() {
            return this._getBit(NodeFlags.DRAWCALL_OPTIMIZE);
        }
        onAfterDeserialize() {
            super.onAfterDeserialize();
            if (LayaEnv.isPlaying) {
                if (this._gcmds) {
                    this.graphics.cmds = this._gcmds;
                    delete this._gcmds;
                }
                if (this._filters) {
                    this.filters = this._filters;
                    delete this._filters;
                }
            }
        }
        get cacheGlobal() {
            return this._cacheGlobal;
        }
        set cacheGlobal(value) {
            if (this._cacheGlobal == value)
                return;
            this._cacheGlobal = value;
            if (value) {
                this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Position_X, true);
                this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Position_Y, true);
                this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Scale_X, true);
                this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Scale_Y, true);
                this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Rotation, true);
                this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                if (this._parent == ILaya.stage || !this._parent) {
                    return;
                }
                else {
                    this._parent.cacheGlobal = value;
                }
            }
            else {
                this._children.forEach(element => {
                    element.cacheGlobal = value;
                });
            }
        }
        getGlobalMatrix() {
            if (this._globalMatrix == null)
                this._globalMatrix = Matrix.create();
            if (this._getGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Matrix)) {
                this._globalMatrix.identity();
                this._globalMatrix.translate(-this.pivotX, -this.pivotY);
                this._globalMatrix.scale(this.globalScaleX, this.globalScaleY);
                this._globalMatrix.rotate(Utils.toRadian(this.globalRotation));
                this._globalMatrix.translate(this.globalPosX, this.globalPosY);
                this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Matrix, false);
            }
            return this._globalMatrix;
        }
        set globalPosX(value) {
            this.setGlobalPos(value, this._globalPosy);
        }
        setGlobalPos(globalx, globaly) {
            if (globalx == this.globalPosX && globaly == this.globalPosY) {
                return;
            }
            if (!this._cacheGlobal) {
                Point.TEMP.setTo(globalx, globaly);
                let point = this.globalToLocal(Point.TEMP, false, null);
                point = this.toParentPoint(point);
                this.x = point.x;
                this.y = point.y;
            }
            else {
                let point = this.parent.getGlobalMatrix().invertTransformPoint(Point.TEMP.setTo(globalx, globaly));
                this._setX(point.x);
                this._setY(point.y);
                this._globalPosx = globalx;
                this._globalPosy = globaly;
                let flag = Sprite.Sprite_GlobalDeltaFlage_Position_X | Sprite.Sprite_GlobalDeltaFlage_Position_Y;
                this._setGlobalCacheFlag(flag, false);
                this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                this._syncGlobalFlag(flag | Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
            }
        }
        get globalPosX() {
            if (!this._cacheGlobal) {
                let point = this.localToGlobal(Point.TEMP.setTo(0, 0), false, null);
                return point.x;
            }
            else {
                if (this._getGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Matrix | Sprite.Sprite_GlobalDeltaFlage_Position_X)) {
                    this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Position_X, false);
                    let mat = this.parent.getGlobalMatrix();
                    let point = this.toParentPoint(Point.TEMP.setTo(this.pivotX, this.pivotY));
                    point = mat.transformPoint(point);
                    this._globalPosx = point.x;
                    this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                    this._syncGlobalFlag(Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                }
                return this._globalPosx;
            }
        }
        get globalPosY() {
            if (!this._cacheGlobal) {
                let point = this.localToGlobal(Point.TEMP.setTo(0, 0), false, null);
                return point.y;
            }
            else {
                if (this._getGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Matrix | Sprite.Sprite_GlobalDeltaFlage_Position_Y)) {
                    this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Position_Y, false);
                    let mat = this.parent.getGlobalMatrix();
                    let point = this.toParentPoint(Point.TEMP.setTo(this.pivotX, this.pivotY));
                    point = mat.transformPoint(point);
                    this._globalPosy = point.y;
                    this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                    this._syncGlobalFlag(Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                }
                return this._globalPosy;
            }
        }
        set globalPosY(value) {
            this.setGlobalPos(this._globalPosx, value);
        }
        get globalRotation() {
            if (!this._cacheGlobal) {
                var angle = 0;
                var ele = this;
                while (ele) {
                    if (ele === ILaya.stage)
                        break;
                    angle += ele.rotation;
                    ele = ele.parent;
                }
                return angle;
            }
            else {
                if (this._getGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Rotation)) {
                    this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Rotation, false);
                    if (this._parent == ILaya.stage || !this._parent)
                        this._globalRotate = this.rotation;
                    else {
                        this._globalRotate = this.rotation + this.parent.globalRotation;
                    }
                }
                return this._globalRotate;
            }
        }
        set globalRotation(value) {
            if (value == this.globalRotation) {
                return;
            }
            if (this._parent == ILaya.stage || !this._parent) {
                this._setRotation(value);
                this._setTranformChange();
            }
            else {
                this._setRotation(value - this.parent.globalRotation);
                this._setTranformChange();
            }
            if (this._cacheGlobal) {
                this._globalRotate = value;
                this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Rotation, false);
                this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                this._syncGlobalFlag(Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
            }
        }
        get globalScaleX() {
            if (!this._cacheGlobal) {
                var scale = 1;
                var ele = this;
                while (ele) {
                    if (ele === ILaya.stage)
                        break;
                    scale *= ele.scaleX;
                    ele = ele.parent;
                }
                return scale;
            }
            else {
                if (this._getGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Scale_X)) {
                    this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Scale_X, false);
                    this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                    if (this._parent == ILaya.stage || !this._parent)
                        this._globalScalex = this.scaleX;
                    else {
                        this._globalScalex = this.scaleX * this.parent.globalScaleX;
                    }
                    this._syncGlobalFlag(Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                }
                return this._globalScalex;
            }
        }
        get globalScaleY() {
            if (!this._cacheGlobal) {
                var scale = 1;
                var ele = this;
                while (ele) {
                    if (ele === ILaya.stage)
                        break;
                    scale *= ele.scaleY;
                    ele = ele.parent;
                }
                return scale;
            }
            else {
                if (this._getGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Scale_Y)) {
                    this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Scale_Y, false);
                    this._setGlobalCacheFlag(Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                    if (this._parent == ILaya.stage || !this._parent)
                        this._globalScaley = this.scaleY;
                    else {
                        this._globalScaley = this.scaleY * this.parent.globalScaleY;
                    }
                    this._syncGlobalFlag(Sprite.Sprite_GlobalDeltaFlage_Matrix, true);
                }
                return this._globalScaley;
            }
        }
        _getGlobalCacheFlag(type) {
            return (this._globalDeltaFlages & type) != 0;
        }
        _getGlobalCacheLocalToGlobal(x, y) {
            if (this._cacheGlobal) {
                return this.getGlobalMatrix().transformPoint(Point.TEMP.setTo(this.pivotX + x, this.pivotY + y));
            }
            else {
                return this.localToGlobal(Point.TEMP.setTo(x, y), false, null);
            }
        }
        _getGlobalCacheGlobalToLocal(x, y) {
            if (this._cacheGlobal) {
                let point = this.getGlobalMatrix().invertTransformPoint(Point.TEMP.setTo(x, y));
                point.x -= this.pivotX;
                point.y -= this.pivotY;
                return point;
            }
            else {
                return this.globalToLocal(Point.TEMP.setTo(x, y), false, null);
            }
        }
        _setGlobalCacheFlag(type, value) {
            if (value)
                this._globalDeltaFlages |= type;
            else
                this._globalDeltaFlages &= ~type;
            if (value) {
                this.event("GlobaChange", type);
            }
        }
        get globalDeltaFlages() {
            return this._globalDeltaFlages;
        }
        _syncGlobalFlag(flag, value) {
            if (this.cacheGlobal) {
                this._children.forEach(element => {
                    element._setGlobalCacheFlag(flag, value);
                    element._syncGlobalFlag(flag, value);
                });
            }
        }
    }
    Sprite.Sprite_GlobalDeltaFlage_Position_X = 0x01;
    Sprite.Sprite_GlobalDeltaFlage_Position_Y = 0x02;
    Sprite.Sprite_GlobalDeltaFlage_Rotation = 0x04;
    Sprite.Sprite_GlobalDeltaFlage_Scale_X = 0x08;
    Sprite.Sprite_GlobalDeltaFlage_Scale_Y = 0x10;
    Sprite.Sprite_GlobalDeltaFlage_Matrix = 0x20;

    class AnimationBase extends Sprite {
        constructor() {
            super();
            this.wrapMode = 0;
            this._interval = Config.animationInterval;
            this._isReverse = false;
            this._frameRateChanged = false;
            this._setBitUp(NodeFlags.DISPLAY);
        }
        play(start = 0, loop = true, name = "") {
            this._isPlaying = true;
            this._actionName = name;
            this.index = (typeof (start) == 'string') ? this._getFrameByLabel(start) : start;
            this.loop = loop;
            this._isReverse = this.wrapMode === AnimationBase.WRAP_REVERSE;
            if (this.index == 0 && this._isReverse) {
                this.index = this.count - 1;
            }
            if (this.interval > 0)
                this.timerLoop(this.interval, this, this._frameLoop, null, true, true);
        }
        get interval() {
            return this._interval;
        }
        set interval(value) {
            if (this._interval != value) {
                this._frameRateChanged = true;
                this._interval = value;
                if (this._isPlaying && value > 0) {
                    this.timerLoop(value, this, this._frameLoop, null, true, true);
                }
            }
        }
        _getFrameByLabel(label) {
            for (var i = 0; i < this._count; i++) {
                var item = this._labels[i];
                if (item && item.indexOf(label) > -1)
                    return i;
            }
            return 0;
        }
        _frameLoop() {
            if (!this._controlNode || this._controlNode._destroyed) {
                this.clearTimer(this, this._frameLoop);
                return;
            }
            if (this._isReverse) {
                this._index--;
                if (this._index < 0) {
                    if (this.loop) {
                        if (this.wrapMode == AnimationBase.WRAP_PINGPONG) {
                            this._index = this._count > 0 ? 1 : 0;
                            this._isReverse = false;
                        }
                        else {
                            this._index = this._count - 1;
                        }
                        this.event(Event.COMPLETE);
                    }
                    else {
                        this._index = 0;
                        this.stop();
                        this.event(Event.COMPLETE);
                        return;
                    }
                }
            }
            else {
                this._index++;
                if (this._index >= this._count) {
                    if (this.loop) {
                        if (this.wrapMode == AnimationBase.WRAP_PINGPONG) {
                            this._index = this._count - 2 >= 0 ? this._count - 2 : 0;
                            this._isReverse = true;
                        }
                        else {
                            this._index = 0;
                        }
                        this.event(Event.COMPLETE);
                    }
                    else {
                        this._index--;
                        this.stop();
                        this.event(Event.COMPLETE);
                        return;
                    }
                }
            }
            this.index = this._index;
        }
        _setControlNode(node) {
            if (this._controlNode) {
                this._controlNode.off(Event.DISPLAY, this, this._resumePlay);
                this._controlNode.off(Event.UNDISPLAY, this, this._resumePlay);
            }
            this._controlNode = node;
            if (node && node != this) {
                node.on(Event.DISPLAY, this, this._resumePlay);
                node.on(Event.UNDISPLAY, this, this._resumePlay);
            }
        }
        _setDisplay(value) {
            super._setDisplay(value);
            this._resumePlay();
        }
        _resumePlay() {
            if (this._isPlaying) {
                if (this._controlNode.displayedInStage)
                    this.play(this._index, this.loop, this._actionName);
                else
                    this.clearTimer(this, this._frameLoop);
            }
        }
        stop() {
            this._isPlaying = false;
            this.clearTimer(this, this._frameLoop);
        }
        get isPlaying() {
            return this._isPlaying;
        }
        addLabel(label, index) {
            if (!this._labels)
                this._labels = {};
            if (!this._labels[index])
                this._labels[index] = [];
            this._labels[index].push(label);
        }
        removeLabel(label) {
            if (!label)
                this._labels = null;
            else if (this._labels) {
                for (var name in this._labels) {
                    this._removeLabelFromList(this._labels[name], label);
                }
            }
        }
        _removeLabelFromList(list, label) {
            if (!list)
                return;
            for (var i = list.length - 1; i >= 0; i--) {
                if (list[i] == label) {
                    list.splice(i, 1);
                }
            }
        }
        gotoAndStop(position) {
            this.index = (typeof (position) == 'string') ? this._getFrameByLabel(position) : position;
            this.stop();
        }
        get index() {
            return this._index;
        }
        set index(value) {
            this._index = value;
            this._displayToIndex(value);
            if (this._labels && this._labels[value]) {
                var tArr = this._labels[value];
                for (var i = 0, len = tArr.length; i < len; i++) {
                    this.event(Event.LABEL, tArr[i]);
                }
            }
        }
        _displayToIndex(value) {
        }
        get count() {
            return this._count;
        }
        clear() {
            this.stop();
            this._labels = null;
            return this;
        }
    }
    AnimationBase.WRAP_POSITIVE = 0;
    AnimationBase.WRAP_REVERSE = 1;
    AnimationBase.WRAP_PINGPONG = 2;

    class MathUtil {
        static subtractVector3(l, r, o) {
            o[0] = l[0] - r[0];
            o[1] = l[1] - r[1];
            o[2] = l[2] - r[2];
        }
        static lerp(left, right, amount) {
            return left * (1 - amount) + right * amount;
        }
        static scaleVector3(f, b, e) {
            e[0] = f[0] * b;
            e[1] = f[1] * b;
            e[2] = f[2] * b;
        }
        static lerpVector3(l, r, t, o) {
            var ax = l[0], ay = l[1], az = l[2];
            o[0] = ax + t * (r[0] - ax);
            o[1] = ay + t * (r[1] - ay);
            o[2] = az + t * (r[2] - az);
        }
        static lerpVector4(l, r, t, o) {
            var ax = l[0], ay = l[1], az = l[2], aw = l[3];
            o[0] = ax + t * (r[0] - ax);
            o[1] = ay + t * (r[1] - ay);
            o[2] = az + t * (r[2] - az);
            o[3] = aw + t * (r[3] - aw);
        }
        static slerpQuaternionArray(a, Offset1, b, Offset2, t, out, Offset3) {
            var ax = a[Offset1 + 0], ay = a[Offset1 + 1], az = a[Offset1 + 2], aw = a[Offset1 + 3], bx = b[Offset2 + 0], by = b[Offset2 + 1], bz = b[Offset2 + 2], bw = b[Offset2 + 3];
            var omega, cosom, sinom, scale0, scale1;
            cosom = ax * bx + ay * by + az * bz + aw * bw;
            if (cosom < 0.0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
            }
            if ((1.0 - cosom) > 0.000001) {
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
            }
            else {
                scale0 = 1.0 - t;
                scale1 = t;
            }
            out[Offset3 + 0] = scale0 * ax + scale1 * bx;
            out[Offset3 + 1] = scale0 * ay + scale1 * by;
            out[Offset3 + 2] = scale0 * az + scale1 * bz;
            out[Offset3 + 3] = scale0 * aw + scale1 * bw;
            return out;
        }
        static getRotation(x0, y0, x1, y1) {
            return Math.atan2(y1 - y0, x1 - x0) / Math.PI * 180;
        }
        static sortBigFirst(a, b) {
            if (a == b)
                return 0;
            return b > a ? 1 : -1;
        }
        static sortSmallFirst(a, b) {
            if (a == b)
                return 0;
            return b > a ? -1 : 1;
        }
        static sortNumBigFirst(a, b) {
            return parseFloat(b) - parseFloat(a);
        }
        static sortNumSmallFirst(a, b) {
            return parseFloat(a) - parseFloat(b);
        }
        static sortByKey(key, bigFirst = false, forceNum = true) {
            var _sortFun;
            if (bigFirst) {
                _sortFun = forceNum ? MathUtil.sortNumBigFirst : MathUtil.sortBigFirst;
            }
            else {
                _sortFun = forceNum ? MathUtil.sortNumSmallFirst : MathUtil.sortSmallFirst;
            }
            return function (a, b) {
                return _sortFun(a[key], b[key]);
            };
        }
    }

    class FrameAnimation extends AnimationBase {
        static _sortIndexFun(objpre, objnext) {
            return objpre.index - objnext.index;
        }
        constructor() {
            super();
            if (FrameAnimation._sortIndexFun === undefined) {
                FrameAnimation._sortIndexFun = MathUtil.sortByKey("index", false, true);
            }
        }
        _setUp(targetDic, animationData) {
            this._targetDic = targetDic;
            this._animationData = animationData;
            this.interval = 1000 / animationData.frameRate;
            if (animationData.parsed) {
                this._count = animationData.count;
                this._labels = animationData.labels;
                this._usedFrames = animationData.animationNewFrames;
            }
            else {
                this._usedFrames = [];
                this._calculateDatas();
                animationData.parsed = true;
                animationData.labels = this._labels;
                animationData.count = this._count;
                animationData.animationNewFrames = this._usedFrames;
            }
        }
        clear() {
            super.clear();
            this._targetDic = null;
            this._animationData = null;
            return this;
        }
        _displayToIndex(value) {
            if (!this._animationData)
                return;
            if (value < 0)
                value = 0;
            if (value > this._count)
                value = this._count;
            var nodes = this._animationData.nodes, i, len = nodes.length;
            for (i = 0; i < len; i++) {
                this._displayNodeToFrame(nodes[i], value);
            }
        }
        _displayNodeToFrame(node, frame, targetDic = null) {
            if (!targetDic)
                targetDic = this._targetDic;
            var target = targetDic[node.target];
            if (!target) {
                return;
            }
            var frames = node.frames, key, propFrames, value;
            var keys = node.keys, i, len = keys.length;
            for (i = 0; i < len; i++) {
                key = keys[i];
                propFrames = frames[key];
                if (propFrames.length > frame) {
                    value = propFrames[frame];
                }
                else {
                    value = propFrames[propFrames.length - 1];
                }
                target[key] = value;
            }
            var funkeys = node.funkeys;
            len = funkeys.length;
            var funFrames;
            if (len == 0)
                return;
            for (i = 0; i < len; i++) {
                key = funkeys[i];
                funFrames = frames[key];
                if (funFrames[frame] !== undefined) {
                    target[key] && target[key].apply(target, funFrames[frame]);
                }
            }
        }
        _calculateDatas() {
            if (!this._animationData)
                return;
            var nodes = this._animationData.nodes, i, len = nodes.length, tNode;
            this._count = 0;
            for (i = 0; i < len; i++) {
                tNode = nodes[i];
                this._calculateKeyFrames(tNode);
            }
            this._count += 1;
        }
        _calculateKeyFrames(node) {
            var keyFrames = node.keyframes, key, tKeyFrames, target = node.target;
            if (!node.frames)
                node.frames = {};
            if (!node.keys)
                node.keys = [];
            else
                node.keys.length = 0;
            if (!node.funkeys)
                node.funkeys = [];
            else
                node.funkeys.length = 0;
            if (!node.initValues)
                node.initValues = {};
            for (key in keyFrames) {
                var isFun = key.indexOf("()") != -1;
                tKeyFrames = keyFrames[key];
                if (isFun)
                    key = key.substr(0, key.length - 2);
                if (!node.frames[key]) {
                    node.frames[key] = [];
                }
                if (!isFun) {
                    if (this._targetDic && this._targetDic[target]) {
                        node.initValues[key] = this._targetDic[target][key];
                    }
                    tKeyFrames.sort(FrameAnimation._sortIndexFun);
                    node.keys.push(key);
                    this._calculateNodePropFrames(tKeyFrames, node.frames[key], key, target);
                }
                else {
                    node.funkeys.push(key);
                    var map = node.frames[key];
                    for (var i = 0; i < tKeyFrames.length; i++) {
                        var temp = tKeyFrames[i];
                        map[temp.index] = temp.value;
                        if (temp.index > this._count)
                            this._count = temp.index;
                    }
                }
            }
        }
        resetNodes() {
            if (!this._targetDic)
                return;
            if (!this._animationData)
                return;
            var nodes = this._animationData.nodes, i, len = nodes.length;
            var tNode;
            var initValues;
            for (i = 0; i < len; i++) {
                tNode = nodes[i];
                initValues = tNode.initValues;
                if (!initValues)
                    continue;
                var target = this._targetDic[tNode.target];
                if (!target)
                    continue;
                var key;
                for (key in initValues) {
                    target[key] = initValues[key];
                }
            }
        }
        _calculateNodePropFrames(keyframes, frames, key, target) {
            var i, len = keyframes.length - 1;
            frames.length = keyframes[len].index + 1;
            for (i = 0; i < len; i++) {
                this._dealKeyFrame(keyframes[i]);
                this._calculateFrameValues(keyframes[i], keyframes[i + 1], frames);
            }
            if (len == 0) {
                frames[0] = keyframes[0].value;
                if (this._usedFrames)
                    this._usedFrames[keyframes[0].index] = true;
            }
            this._dealKeyFrame(keyframes[i]);
        }
        _dealKeyFrame(keyFrame) {
            if (keyFrame.label && keyFrame.label != "")
                this.addLabel(keyFrame.label, keyFrame.index);
        }
        _calculateFrameValues(startFrame, endFrame, result) {
            var i, easeFun;
            var start = startFrame.index, end = endFrame.index;
            var startValue = startFrame.value;
            var dValue = endFrame.value - startFrame.value;
            var dLen = end - start;
            var frames = this._usedFrames;
            if (end > this._count)
                this._count = end;
            if (startFrame.tween) {
                easeFun = Ease[startFrame.tweenMethod];
                if (easeFun == null)
                    easeFun = Ease.linearNone;
                for (i = start; i < end; i++) {
                    result[i] = easeFun(i - start, startValue, dValue, dLen);
                    if (frames)
                        frames[i] = true;
                }
            }
            else {
                for (i = start; i < end; i++) {
                    result[i] = startValue;
                }
            }
            if (frames) {
                frames[startFrame.index] = true;
                frames[endFrame.index] = true;
            }
            result[endFrame.index] = endFrame.value;
        }
    }

    class GraphicAnimation extends FrameAnimation {
        constructor() {
            super(...arguments);
            this._nodeIDAniDic = {};
        }
        _parseNodeList(uiView) {
            if (!this._nodeList)
                this._nodeList = [];
            this._nodeDefaultProps[uiView.compId] = uiView.props;
            if (uiView.compId)
                this._nodeList.push(uiView.compId);
            var childs = uiView.child;
            if (childs) {
                var i, len = childs.length;
                for (i = 0; i < len; i++) {
                    this._parseNodeList(childs[i]);
                }
            }
        }
        _calGraphicData(aniData) {
            this._setUp(null, aniData);
            this._createGraphicData();
            if (this._nodeIDAniDic) {
                var key;
                for (key in this._nodeIDAniDic) {
                    this._nodeIDAniDic[key] = null;
                }
            }
        }
        _createGraphicData() {
            var gList = [];
            var i, len = this.count;
            var animationDataNew = this._usedFrames;
            if (!animationDataNew)
                animationDataNew = [];
            var preGraphic;
            for (i = 0; i < len; i++) {
                if (animationDataNew[i] || !preGraphic) {
                    preGraphic = this._createFrameGraphic(i);
                }
                gList.push(preGraphic);
            }
            this._gList = gList;
        }
        _createFrameGraphic(frame) {
            var g = new Graphics();
            if (!GraphicAnimation._rootMatrix)
                GraphicAnimation._rootMatrix = new Matrix();
            this._updateNodeGraphic(this._rootNode, frame, GraphicAnimation._rootMatrix, g);
            return g;
        }
        _updateNodeGraphic(node, frame, parentTransfrom, g, alpha = 1) {
            var tNodeG;
            tNodeG = this._nodeGDic[node.compId] = this._getNodeGraphicData(node.compId, frame, this._nodeGDic[node.compId]);
            if (!tNodeG.resultTransform)
                tNodeG.resultTransform = new Matrix();
            var tResultTransform;
            tResultTransform = tNodeG.resultTransform;
            Matrix.mul(tNodeG.transform, parentTransfrom, tResultTransform);
            var tTex;
            var tGraphicAlpha = tNodeG.alpha * alpha;
            if (tGraphicAlpha < 0.01)
                return;
            if (tNodeG.skin) {
                tTex = this._getTextureByUrl(tNodeG.skin);
                if (tTex) {
                    if (tResultTransform._checkTransform()) {
                        g.drawTexture(tTex, 0, 0, tNodeG.width, tNodeG.height, tResultTransform, tGraphicAlpha);
                        tNodeG.resultTransform = null;
                    }
                    else {
                        g.drawTexture(tTex, tResultTransform.tx, tResultTransform.ty, tNodeG.width, tNodeG.height, null, tGraphicAlpha);
                    }
                }
            }
            var childs = node.child;
            if (!childs)
                return;
            var i, len;
            len = childs.length;
            for (i = 0; i < len; i++) {
                this._updateNodeGraphic(childs[i], frame, tResultTransform, g, tGraphicAlpha);
            }
        }
        _updateNoChilds(tNodeG, g) {
            if (!tNodeG.skin)
                return;
            var tTex = this._getTextureByUrl(tNodeG.skin);
            if (!tTex)
                return;
            var tTransform = tNodeG.transform;
            tTransform._checkTransform();
            var onlyTranslate;
            onlyTranslate = !tTransform._bTransform;
            if (!onlyTranslate) {
                g.drawTexture(tTex, 0, 0, tNodeG.width, tNodeG.height, tTransform.clone(), tNodeG.alpha);
            }
            else {
                g.drawTexture(tTex, tTransform.tx, tTransform.ty, tNodeG.width, tNodeG.height, null, tNodeG.alpha);
            }
        }
        _updateNodeGraphic2(node, frame, g) {
            var tNodeG;
            tNodeG = this._nodeGDic[node.compId] = this._getNodeGraphicData(node.compId, frame, this._nodeGDic[node.compId]);
            if (!node.child) {
                this._updateNoChilds(tNodeG, g);
                return;
            }
            var tTransform = tNodeG.transform;
            tTransform._checkTransform();
            var onlyTranslate;
            onlyTranslate = !tTransform._bTransform;
            var hasTrans;
            hasTrans = onlyTranslate && (tTransform.tx != 0 || tTransform.ty != 0);
            var ifSave;
            ifSave = (tTransform._bTransform) || tNodeG.alpha != 1;
            if (ifSave)
                g.save();
            if (tNodeG.alpha != 1)
                g.alpha(tNodeG.alpha);
            if (!onlyTranslate)
                g.transform(tTransform.clone());
            else if (hasTrans)
                g.translate(tTransform.tx, tTransform.ty);
            var childs = node.child;
            var tTex;
            if (tNodeG.skin) {
                tTex = this._getTextureByUrl(tNodeG.skin);
                if (tTex) {
                    g.drawImage(tTex, 0, 0, tNodeG.width, tNodeG.height);
                }
            }
            if (childs) {
                var i, len;
                len = childs.length;
                for (i = 0; i < len; i++) {
                    this._updateNodeGraphic2(childs[i], frame, g);
                }
            }
            if (ifSave) {
                g.restore();
            }
            else {
                if (!onlyTranslate) {
                    g.transform(tTransform.clone().invert());
                }
                else if (hasTrans) {
                    g.translate(-tTransform.tx, -tTransform.ty);
                }
            }
        }
        _calculateKeyFrames(node) {
            super._calculateKeyFrames(node);
            this._nodeIDAniDic[node.target] = node;
        }
        getNodeDataByID(nodeID) {
            return this._nodeIDAniDic[nodeID];
        }
        _getParams(obj, params, frame, obj2) {
            var rst = GraphicAnimation._temParam;
            rst.length = params.length;
            var i, len = params.length;
            for (i = 0; i < len; i++) {
                rst[i] = this._getObjVar(obj, params[i][0], frame, params[i][1], obj2);
            }
            return rst;
        }
        _getObjVar(obj, key, frame, noValue, obj2) {
            if (key in obj) {
                var vArr = obj[key];
                if (frame >= vArr.length)
                    frame = vArr.length - 1;
                return obj[key][frame];
            }
            if (key in obj2) {
                return obj2[key];
            }
            return noValue;
        }
        _getNodeGraphicData(nodeID, frame, rst) {
            if (!rst)
                rst = new GraphicNode();
            if (!rst.transform) {
                rst.transform = new Matrix();
            }
            else {
                rst.transform.identity();
            }
            var node = this.getNodeDataByID(nodeID);
            if (!node)
                return rst;
            var frameData = node.frames;
            var params = this._getParams(frameData, GraphicAnimation._drawTextureCmd, frame, this._nodeDefaultProps[nodeID]);
            var url = params[0];
            var width, height;
            var px = params[5], py = params[6];
            var aX = params[13], aY = params[14];
            var sx = params[7], sy = params[8];
            var rotate = params[9];
            var skewX = params[11], skewY = params[12];
            width = params[3];
            height = params[4];
            if (width == 0 || height == 0)
                url = null;
            if (width == -1)
                width = 0;
            if (height == -1)
                height = 0;
            var tex;
            rst.skin = url;
            rst.width = width;
            rst.height = height;
            if (url) {
                tex = this._getTextureByUrl(url);
                if (tex) {
                    if (!width)
                        width = tex.sourceWidth;
                    if (!height)
                        height = tex.sourceHeight;
                }
                else {
                    console.warn("lost skin:", url, ",you may load pics first");
                }
            }
            rst.alpha = params[10];
            var m = rst.transform;
            if (aX != 0) {
                px = aX * width;
            }
            if (aY != 0) {
                py = aY * height;
            }
            if (px != 0 || py != 0) {
                m.translate(-px, -py);
            }
            var tm = null;
            if (rotate || sx !== 1 || sy !== 1 || skewX || skewY) {
                tm = GraphicAnimation._tempMt;
                tm.identity();
                tm._bTransform = true;
                var skx = (rotate - skewX) * 0.0174532922222222;
                var sky = (rotate + skewY) * 0.0174532922222222;
                var cx = Math.cos(sky);
                var ssx = Math.sin(sky);
                var cy = Math.sin(skx);
                var ssy = Math.cos(skx);
                tm.a = sx * cx;
                tm.b = sx * ssx;
                tm.c = -sy * cy;
                tm.d = sy * ssy;
                tm.tx = tm.ty = 0;
            }
            if (tm) {
                m = Matrix.mul(m, tm, m);
            }
            m.translate(params[1], params[2]);
            return rst;
        }
        _getTextureByUrl(url) {
            return Loader.getRes(url);
        }
        setAniData(uiView, aniName = null) {
            if (uiView.animations) {
                this._nodeDefaultProps = {};
                this._nodeGDic = {};
                if (this._nodeList)
                    this._nodeList.length = 0;
                this._rootNode = uiView;
                this._parseNodeList(uiView);
                var aniDic = {};
                var anilist = [];
                var animations = uiView.animations;
                var i, len = animations.length;
                var tAniO;
                for (i = 0; i < len; i++) {
                    tAniO = animations[i];
                    this._labels = null;
                    if (aniName && aniName != tAniO.name) {
                        continue;
                    }
                    if (!tAniO)
                        continue;
                    try {
                        this._calGraphicData(tAniO);
                    }
                    catch (e) {
                        console.warn("parse animation fail:" + tAniO.name + ",empty animation created");
                        this._gList = [];
                    }
                    var frameO = {};
                    frameO.interval = 1000 / tAniO["frameRate"];
                    frameO.frames = this._gList;
                    frameO.labels = this._labels;
                    frameO.name = tAniO.name;
                    anilist.push(frameO);
                    aniDic[tAniO.name] = frameO;
                }
                this.animationList = anilist;
                this.animationDic = aniDic;
            }
            GraphicAnimation._temParam.length = 0;
        }
        parseByData(aniData) {
            var rootNode, aniO;
            rootNode = aniData.nodeRoot;
            aniO = aniData.aniO;
            delete aniData.nodeRoot;
            delete aniData.aniO;
            this._nodeDefaultProps = {};
            this._nodeGDic = {};
            if (this._nodeList)
                this._nodeList.length = 0;
            this._rootNode = rootNode;
            this._parseNodeList(rootNode);
            this._labels = null;
            try {
                this._calGraphicData(aniO);
            }
            catch (e) {
                console.warn("parse animation fail:" + aniO.name + ",empty animation created");
                this._gList = [];
            }
            var frameO = aniData;
            frameO.interval = 1000 / aniO["frameRate"];
            frameO.frames = this._gList;
            frameO.labels = this._labels;
            frameO.name = aniO.name;
            return frameO;
        }
        setUpAniData(uiView) {
            if (uiView.animations) {
                var aniDic = {};
                var anilist = [];
                var animations = uiView.animations;
                var i, len = animations.length;
                var tAniO;
                for (i = 0; i < len; i++) {
                    tAniO = animations[i];
                    if (!tAniO)
                        continue;
                    var frameO = {};
                    frameO.name = tAniO.name;
                    frameO.aniO = tAniO;
                    frameO.nodeRoot = uiView;
                    anilist.push(frameO);
                    aniDic[tAniO.name] = frameO;
                }
                this.animationList = anilist;
                this.animationDic = aniDic;
            }
        }
        _clear() {
            this.animationList = null;
            this.animationDic = null;
            this._gList = null;
            this._nodeGDic = null;
        }
        static parseAnimationByData(animationObject) {
            if (!GraphicAnimation._I)
                GraphicAnimation._I = new GraphicAnimation();
            var rst;
            rst = GraphicAnimation._I.parseByData(animationObject);
            GraphicAnimation._I._clear();
            return rst;
        }
        static parseAnimationData(aniData) {
            if (!GraphicAnimation._I)
                GraphicAnimation._I = new GraphicAnimation();
            GraphicAnimation._I.setUpAniData(aniData);
            var rst;
            rst = {};
            rst.animationList = GraphicAnimation._I.animationList;
            rst.animationDic = GraphicAnimation._I.animationDic;
            GraphicAnimation._I._clear();
            return rst;
        }
    }
    GraphicAnimation._drawTextureCmd = [["skin", null], ["x", 0], ["y", 0], ["width", -1], ["height", -1], ["pivotX", 0], ["pivotY", 0], ["scaleX", 1], ["scaleY", 1], ["rotation", 0], ["alpha", 1], ["skewX", 0], ["skewY", 0], ["anchorX", 0], ["anchorY", 0]];
    GraphicAnimation._temParam = [];
    GraphicAnimation._tempMt = new Matrix();
    class GraphicNode {
        constructor() {
            this.alpha = 1;
        }
    }

    class Animation extends AnimationBase {
        constructor() {
            super();
            this._autoPlay = false;
            this._setControlNode(this);
        }
        destroy(destroyChild = true) {
            this.stop();
            super.destroy(destroyChild);
            if (this._atlasCatch) {
                for (let alias of this._atlasCatch) {
                    alias._removeReference();
                    if (0 == alias.referenceCount) {
                        alias.destroy();
                    }
                }
            }
            this._atlasCatch = null;
            this._frames = null;
            this._labels = null;
        }
        play(start = 0, loop = true, name = "") {
            if (name)
                this._setFramesFromCache(name, true);
            super.play(start, loop, name);
        }
        _setFramesFromCache(name, showWarn = false) {
            if (this._url)
                name = this._url + "#" + name;
            if (name && Animation.framesMap[name]) {
                var tAniO = Animation.framesMap[name];
                if (tAniO instanceof Array) {
                    this._frames = Animation.framesMap[name];
                    this._count = this._frames.length;
                }
                else {
                    if (tAniO.nodeRoot) {
                        Animation.framesMap[name] = GraphicAnimation.parseAnimationByData(tAniO);
                        tAniO = Animation.framesMap[name];
                    }
                    this._frames = tAniO.frames;
                    this._count = this._frames.length;
                    if (!this._frameRateChanged)
                        this._interval = tAniO.interval;
                    this._labels = this._copyLabels(tAniO.labels);
                }
                return true;
            }
            else {
                if (showWarn)
                    console.log("ani not found:", name);
            }
            return false;
        }
        _copyLabels(labels) {
            if (!labels)
                return null;
            var rst;
            rst = {};
            var key;
            for (key in labels) {
                rst[key] = Utils.copyArray([], labels[key]);
            }
            return rst;
        }
        _frameLoop() {
            if (this._visible && this._style.alpha > 0.01 && this._frames) {
                super._frameLoop();
            }
        }
        _displayToIndex(value) {
            if (this._frames)
                this.graphics = this._frames[value];
        }
        get frames() {
            return this._frames;
        }
        set frames(value) {
            this._frames = value;
            if (value) {
                this._count = value.length;
                if (this._actionName)
                    this._setFramesFromCache(this._actionName, true);
                this.index = this._index;
            }
        }
        get source() {
            return this._source;
        }
        set source(value) {
            this._source = value;
            if (!value)
                this.clear();
            else if (value.indexOf(".ani") > -1)
                this.loadAnimation(value);
            else if (value.startsWith("res://") || value.indexOf(".json") > -1 || value.indexOf("als") > -1 || value.indexOf("atlas") > -1)
                this.loadAtlas(value);
            else
                this.loadImages(value.split(","));
        }
        set autoPlay(value) {
            this._autoPlay = value;
            if (value)
                this.play();
            else
                this.stop();
        }
        get autoPlay() {
            return this._autoPlay;
        }
        clear() {
            super.clear();
            this.stop();
            this.graphics = null;
            this._frames = null;
            this._labels = null;
            return this;
        }
        loadImages(urls, cacheName = "") {
            this._url = "";
            if (!this._setFramesFromCache(cacheName)) {
                this.frames = Animation.framesMap[cacheName] ? Animation.framesMap[cacheName] : Animation.createFrames(urls, cacheName);
            }
            if (!this._isPlaying && this._autoPlay)
                this.play();
            return this;
        }
        loadAtlas(url, loaded = null, cacheName = "") {
            this._url = "";
            if (!this._setFramesFromCache(cacheName)) {
                let onLoaded = (loadUrl, data) => {
                    if (null == this._atlasCatch)
                        this._atlasCatch = [];
                    if (0 > this._atlasCatch.indexOf(data)) {
                        this._atlasCatch.push(data);
                        data._addReference();
                    }
                    if (url === loadUrl) {
                        this.frames = Animation.framesMap[cacheName] ? Animation.framesMap[cacheName] : Animation.createFrames(url, cacheName);
                        if (!this._isPlaying && this._autoPlay)
                            this.play();
                        if (loaded)
                            loaded.run();
                    }
                };
                let atlas = Loader.getAtlas(url);
                if (atlas)
                    onLoaded(url, atlas);
                else
                    ILaya.loader.load(url, Handler.create(null, onLoaded, [url]), null, Loader.ATLAS);
            }
            return this;
        }
        loadAnimation(url, loaded = null, atlas = null) {
            this._url = url;
            var _this = this;
            if (!this._actionName)
                this._actionName = "";
            if (!_this._setFramesFromCache(this._actionName)) {
                if (!atlas || Loader.getAtlas(atlas)) {
                    this._loadAnimationData(url, loaded, atlas);
                }
                else {
                    ILaya.loader.load(atlas, Handler.create(this, this._loadAnimationData, [url, loaded, atlas]), null, Loader.ATLAS);
                }
            }
            else {
                _this._setFramesFromCache(this._actionName, true);
                this.index = 0;
                if (loaded)
                    loaded.run();
            }
            return this;
        }
        _loadAnimationData(url, loaded = null, atlas = null) {
            if (atlas && !Loader.getAtlas(atlas)) {
                console.warn("atlas load fail:" + atlas);
                return;
            }
            ILaya.loader.fetch(url, "json").then(data => {
                if (this._url !== url)
                    return;
                if (!data) {
                    if (Animation.framesMap[url + "#"]) {
                        this._setFramesFromCache(this._actionName, true);
                        this.index = 0;
                        this._resumePlay();
                        if (loaded)
                            loaded.run();
                    }
                    return;
                }
                let tAniO;
                if (!Animation.framesMap[url + "#"]) {
                    let aniData = GraphicAnimation.parseAnimationData(data);
                    if (!aniData)
                        return;
                    let aniList = aniData.animationList;
                    let len = aniList.length;
                    let defaultO;
                    for (let i = 0; i < len; i++) {
                        tAniO = aniList[i];
                        Animation.framesMap[url + "#" + tAniO.name] = tAniO;
                        if (!defaultO)
                            defaultO = tAniO;
                    }
                    if (defaultO) {
                        Animation.framesMap[url + "#"] = defaultO;
                        this._setFramesFromCache(this._actionName, true);
                        this.index = 0;
                    }
                    this._resumePlay();
                }
                else {
                    this._setFramesFromCache(this._actionName, true);
                    this.index = 0;
                    this._resumePlay();
                }
                if (loaded)
                    loaded.run();
            });
        }
        static createFrames(url, name) {
            var arr;
            if (typeof (url) == 'string') {
                var atlas = Loader.getAtlas(url);
                if (atlas && atlas.frames.length) {
                    let frames = atlas.frames;
                    arr = [];
                    for (var i = 0, n = frames.length; i < n; i++) {
                        var g = new Graphics();
                        g.drawImage(frames[i], 0, 0);
                        arr.push(g);
                    }
                }
            }
            else if (url instanceof Array) {
                arr = [];
                for (i = 0, n = url.length; i < n; i++) {
                    g = new Graphics();
                    g.loadImage(url[i], 0, 0);
                    arr.push(g);
                }
            }
            if (name)
                Animation.framesMap[name] = arr;
            return arr;
        }
        static clearCache(key) {
            var cache = Animation.framesMap;
            var val;
            var key2 = key + "#";
            for (val in cache) {
                if (val === key || val.indexOf(key2) === 0) {
                    delete Animation.framesMap[val];
                }
            }
        }
        onAfterDeserialize() {
            super.onAfterDeserialize();
            if (this.images) {
                if (!this._source)
                    this.loadImages(this.images);
                delete this.images;
            }
        }
    }
    Animation.framesMap = {};

    class BitmapFont extends Resource {
        static loadFont(path, complete) {
            ILaya.loader.load(path, Loader.FONT).then(font => {
                complete && complete.runWith(font);
            });
        }
        constructor() {
            super(false);
            this.dict = {};
            this.fontSize = 12;
            this.autoScaleSize = false;
            this.tint = true;
            this.maxWidth = 0;
            this.lineHeight = 12;
            this.letterSpacing = 0;
        }
        parseFont(xml, texture) {
            var _a;
            if (xml == null || texture == null)
                return;
            this.texture = texture;
            texture._addReference();
            let scale = 1;
            let info = xml.getNode("info");
            this.fontSize = info.getAttrInt("size", 12);
            this.autoScaleSize = info.getAttrBool("autoScaleSize");
            this.lineHeight = info.getAttrInt("lineHeight", this.fontSize);
            if (this.lineHeight == 0)
                this.lineHeight = this.fontSize;
            let padding = info.getAttrString("padding", "");
            let paddingArray = padding.split(",");
            this.padding = [parseInt(paddingArray[0]), parseInt(paddingArray[1]), parseInt(paddingArray[2]), parseInt(paddingArray[3])];
            let chars = ((_a = xml.getNode("chars")) === null || _a === void 0 ? void 0 : _a.elements("char")) || [];
            let maxWidth = 0;
            let dict = this.dict;
            for (let i = 0, n = chars.length; i < n; i++) {
                let ct = chars[i];
                let id = ct.getAttrInt("id");
                let xOffset = ct.getAttrInt("xoffset") / scale;
                let yOffset = ct.getAttrInt("yoffset") / scale;
                let advance = ct.getAttrInt("xadvance") / scale;
                let x = ct.getAttrInt("x");
                let y = ct.getAttrInt("y");
                let width = ct.getAttrInt("width");
                let height = ct.getAttrInt("height");
                let tex = Texture.create(texture, x, y, width, height, xOffset, yOffset);
                if (advance == 0)
                    advance = width;
                advance += this.letterSpacing;
                maxWidth = Math.max(maxWidth, advance);
                dict[id] = { x: 0, y: 0, width, height, advance, texture: tex };
            }
            if (maxWidth > 0)
                this.maxWidth = maxWidth;
            else
                this.maxWidth = this.fontSize;
            if (!dict[32])
                dict[32] = { x: 0, y: 0, advance: Math.floor(this.fontSize * 0.5) + this.letterSpacing };
        }
        _disposeResource() {
            var _a;
            if (this.texture) {
                for (let k in this.dict) {
                    (_a = this.dict[k].texture) === null || _a === void 0 ? void 0 : _a.destroy();
                }
                this.texture._removeReference();
                this.dict = null;
                this.texture = null;
                this.padding = null;
            }
        }
        getTextWidth(text, fontSize) {
            let w = 0;
            for (let i = 0, n = text.length; i < n; i++) {
                let g = this.dict[text.charCodeAt(i)];
                if (g) {
                    let scale = this.autoScaleSize ? (fontSize / this.fontSize) : 1;
                    w += Math.round(g.advance * scale);
                }
            }
            return w;
        }
        getMaxWidth(fontSize) {
            if (fontSize != null && this.autoScaleSize)
                return Math.round(this.maxWidth * (fontSize / this.fontSize));
            else
                return this.maxWidth;
        }
        getMaxHeight(fontSize) {
            if (fontSize != null && this.autoScaleSize)
                return Math.round(this.lineHeight * (fontSize / this.fontSize));
            else
                return this.lineHeight;
        }
    }

    class EffectAnimation extends FrameAnimation {
        constructor() {
            super(...arguments);
            this._initData = {};
        }
        get target() {
            return this._target;
        }
        set target(v) {
            if (this._target)
                this._target.off(EffectAnimation.EFFECT_BEGIN, this, this._onOtherBegin);
            this._target = v;
            if (this._target)
                this._target.on(EffectAnimation.EFFECT_BEGIN, this, this._onOtherBegin);
            this._addEvent();
        }
        _onOtherBegin(effect) {
            if (effect === this)
                return;
            this.stop();
        }
        set playEvent(event) {
            this._playEvent = event;
            if (!event)
                return;
            this._addEvent();
        }
        _addEvent() {
            if (!this._target || !this._playEvent)
                return;
            this._setControlNode(this._target);
            this._target.on(this._playEvent, this, this._onPlayAction);
        }
        _onPlayAction() {
            this.play(0, false);
        }
        play(start = 0, loop = true, name = "") {
            if (!this._target)
                return;
            this._target.event(EffectAnimation.EFFECT_BEGIN, [this]);
            this._recordInitData();
            super.play(start, loop, name);
        }
        _recordInitData() {
            if (!this._aniKeys)
                return;
            var i, len;
            len = this._aniKeys.length;
            var key;
            for (i = 0; i < len; i++) {
                key = this._aniKeys[i];
                this._initData[key] = this._target[key];
            }
        }
        set effectClass(classStr) {
            this._effectClass = ClassUtils.getClass(classStr);
            if (this._effectClass) {
                var uiData = this._effectClass["uiView"];
                if (uiData) {
                    var aniData = uiData["animations"];
                    if (aniData && aniData[0]) {
                        var data = aniData[0];
                        this._setUp({}, data);
                        if (data.nodes && data.nodes[0]) {
                            this._aniKeys = data.nodes[0].keys;
                        }
                    }
                }
            }
        }
        set effectData(uiData) {
            if (uiData) {
                var aniData = uiData["animations"];
                if (aniData && aniData[0]) {
                    var data = aniData[0];
                    this._setUp({}, data);
                    if (data.nodes && data.nodes[0]) {
                        this._aniKeys = data.nodes[0].keys;
                    }
                }
            }
        }
        _displayToIndex(value) {
            if (!this._animationData)
                return;
            if (value < 0)
                value = 0;
            if (value > this._count)
                value = this._count;
            var nodes = this._animationData.nodes, i, len = nodes.length;
            len = len > 1 ? 1 : len;
            for (i = 0; i < len; i++) {
                this._displayNodeToFrame(nodes[i], value);
            }
        }
        _displayNodeToFrame(node, frame, targetDic = null) {
            if (!this._target)
                return;
            var target = this._target;
            var frames = node.frames, key, propFrames, value;
            var keys = node.keys, i, len = keys.length;
            var secondFrames = node.secondFrames;
            var tSecondFrame;
            var easeFun;
            var tKeyFrames;
            var startFrame;
            var endFrame;
            for (i = 0; i < len; i++) {
                key = keys[i];
                propFrames = frames[key];
                tSecondFrame = secondFrames[key];
                if (tSecondFrame == -1) {
                    value = this._initData[key];
                }
                else {
                    if (frame < tSecondFrame) {
                        tKeyFrames = node.keyframes[key];
                        startFrame = tKeyFrames[0];
                        if (startFrame.tween) {
                            easeFun = Ease[startFrame.tweenMethod];
                            if (easeFun == null)
                                easeFun = Ease.linearNone;
                            endFrame = tKeyFrames[1];
                            value = easeFun(frame, this._initData[key], endFrame.value - this._initData[key], endFrame.index);
                        }
                        else {
                            value = this._initData[key];
                        }
                    }
                    else {
                        if (propFrames.length > frame)
                            value = propFrames[frame];
                        else
                            value = propFrames[propFrames.length - 1];
                    }
                }
                target[key] = value;
            }
        }
        _calculateKeyFrames(node) {
            super._calculateKeyFrames(node);
            var keyFrames = node.keyframes, key, tKeyFrames; node.target;
            var secondFrames = {};
            node.secondFrames = secondFrames;
            for (key in keyFrames) {
                tKeyFrames = keyFrames[key];
                if (tKeyFrames.length <= 1)
                    secondFrames[key] = -1;
                else
                    secondFrames[key] = tKeyFrames[1].index;
            }
        }
    }
    EffectAnimation.EFFECT_BEGIN = "effectbegin";

    class TextStyle {
        constructor() {
            this.font = "";
            this.fontSize = 12;
            this.color = "#000000";
            this.bold = false;
            this.italic = false;
            this.underline = false;
            this.underlineColor = null;
            this.strikethrough = false;
            this.strikethroughColor = null;
            this.align = 'left';
            this.valign = 'top';
            this.leading = 2;
            this.stroke = 0;
            this.strokeColor = '#000000';
            this.font = "";
            this.fontSize = 12;
            this.color = "#000000";
            this.bold = false;
            this.italic = false;
            this.underline = false;
            this.underlineColor = null;
            this.align = "left";
            this.valign = "top";
            this.alignItems = "middle";
            this.leading = 2;
            this.stroke = 0;
            this.strokeColor = "#000000";
        }
    }

    exports.HtmlElementType = void 0;
    (function (HtmlElementType) {
        HtmlElementType[HtmlElementType["Text"] = 0] = "Text";
        HtmlElementType[HtmlElementType["Link"] = 1] = "Link";
        HtmlElementType[HtmlElementType["Image"] = 2] = "Image";
        HtmlElementType[HtmlElementType["Input"] = 3] = "Input";
        HtmlElementType[HtmlElementType["Select"] = 4] = "Select";
        HtmlElementType[HtmlElementType["Object"] = 5] = "Object";
        HtmlElementType[HtmlElementType["LinkEnd"] = 6] = "LinkEnd";
    })(exports.HtmlElementType || (exports.HtmlElementType = {}));
    class HtmlElement {
        constructor() {
            this.style = new TextStyle();
        }
        getAttr(attrName) {
            if (this._attrs == null)
                return null;
            return this._attrs[attrName];
        }
        setAttr(attrName, attrValue) {
            if (this._attrs == null)
                this._attrs = {};
            this._attrs[attrName] = attrValue;
        }
        getAttrString(attrName, defValue) {
            return XMLUtils.getString(this._attrs, attrName, defValue);
        }
        getAttrInt(attrName, defValue) {
            return XMLUtils.getInt(this._attrs, attrName, defValue);
        }
        getAttrFloat(attrName, defValue) {
            return XMLUtils.getFloat(this._attrs, attrName, defValue);
        }
        getAttrBool(attrName, defValue) {
            return XMLUtils.getBool(this._attrs, attrName, defValue);
        }
        fetchAttributes() {
            this._attrs = Object.assign({}, XMLIterator.attributes);
        }
        reset() {
            this.name = null;
            this.text = null;
            if (this.obj) {
                this.obj.release();
                Pool.recoverByClass(this.obj);
                this.obj = null;
            }
            this._attrs = null;
        }
        static getFromPool(type) {
            let ele;
            if (this.pool.length > 0)
                ele = this.pool.pop();
            else
                ele = new HtmlElement();
            ele.type = type;
            if (ele.type != exports.HtmlElementType.Text && !ele._attrs)
                ele._attrs = {};
            return ele;
        }
        static returnToPool(ele) {
            if (Array.isArray(ele)) {
                for (let e of ele)
                    e.reset();
                this.pool.push(...ele);
                ele.length = 0;
            }
            else {
                ele.reset();
                this.pool.push(ele);
            }
        }
    }
    HtmlElement.pool = [];

    class HtmlImage {
        constructor() {
            this._v = 0;
            this.obj = new Sprite();
        }
        get element() {
            return this._element;
        }
        get width() {
            return this.obj.width;
        }
        get height() {
            return this.obj.height;
        }
        create(owner, element) {
            this._owner = owner;
            this._element = element;
            this._owner.objContainer.addChild(this.obj);
            let src = this._element.getAttrString("src");
            if (src)
                this.loadTexture(src);
        }
        loadTexture(src) {
            let width = this._element.getAttrInt("width", -1);
            let height = this._element.getAttrInt("height", -1);
            if (width != -1)
                this.obj.width = width;
            if (height != -1)
                this.obj.height = height;
            let tex = Loader.getRes(src);
            if (tex) {
                this.obj.texture = tex;
                if (width == -1)
                    this.obj.width = tex.sourceWidth;
                if (height == -1)
                    this.obj.height = tex.sourceHeight;
            }
            else {
                let ver = this._v;
                ILaya.loader.load(src, { silent: true }).then(tex => {
                    if (this.obj.destroyed || ver != this._v)
                        return;
                    let w = this.obj.width;
                    let h = this.obj.height;
                    this.obj.texture = tex;
                    if (width == -1)
                        this.obj.width = tex ? tex.sourceWidth : 0;
                    if (height == -1)
                        this.obj.height = tex ? tex.sourceHeight : 0;
                    if (this._owner && (w != this.obj.width || h != this.obj.height))
                        this._owner.refreshLayout();
                });
            }
        }
        pos(x, y) {
            this.obj.pos(x, y);
        }
        release() {
            this.obj.removeSelf();
            this.obj.offAll();
            this.obj.texture = null;
            this._owner = null;
            this._element = null;
            this._v++;
        }
        destroy() {
            this.obj.destroy();
        }
    }

    class HtmlLink {
        constructor() {
            this._shape = new Sprite();
            this._shape.hitArea = this;
            this._shape.on(Event.CLICK, () => {
                this._owner.bubbleEvent(Event.LINK, this._element.getAttrString("href"));
            });
            this._rects = [];
            this._rectCnt = 0;
        }
        get element() {
            return this._element;
        }
        get width() {
            return 0;
        }
        get height() {
            return 0;
        }
        create(owner, element) {
            this._owner = owner;
            this._element = element;
            this._owner.objContainer.addChild(this._shape);
        }
        resetArea() {
            this._rectCnt = 0;
        }
        addRect(x, y, width, height) {
            let rect = this._rects[this._rectCnt];
            if (!rect)
                rect = this._rects[this._rectCnt] = new Rectangle();
            this._rectCnt++;
            rect.setTo(x, y, width, height);
        }
        contains(x, y) {
            for (let i = 0; i < this._rectCnt; i++) {
                if (this._rects[i].contains(x, y))
                    return true;
            }
            return false;
        }
        pos(x, y) {
        }
        release() {
            this._shape.removeSelf();
            this._owner = null;
            this._element = null;
        }
        destroy() {
            this._shape.destroy();
        }
    }

    class HtmlParseOptions {
        constructor() {
            this.linkUnderline = HtmlParseOptions.defaultLinkUnderline;
            this.linkColor = HtmlParseOptions.defaultLinkColor;
        }
    }
    HtmlParseOptions.defaultLinkUnderline = true;
    HtmlParseOptions.defaultLinkColor = null;
    ClassUtils.regClass("HtmlParseOptions", HtmlParseOptions);

    const s_list1 = new Array();
    const s_list2 = new Array();
    class HtmlParser {
        constructor() {
            this._styleStack = new Array();
            this._style = new TextStyle();
            this._options = new HtmlParseOptions();
        }
        parse(aSource, style, out, options) {
            if (options == null)
                options = this._options;
            this._elements = out;
            this._styleStackTop = 0;
            Object.assign(this._style, style);
            this._style.colorChanged = false;
            let skipText = 0;
            let ignoreWhiteSpace = options.ignoreWhiteSpace;
            let skipNextCR = false;
            let text;
            XMLIterator.begin(aSource, true);
            while (XMLIterator.nextTag()) {
                if (skipText == 0) {
                    text = XMLIterator.getText(ignoreWhiteSpace);
                    if (text.length > 0) {
                        if (skipNextCR && text[0] == '\n')
                            text = text.substring(1);
                        this.appendText(text);
                    }
                }
                skipNextCR = false;
                switch (XMLIterator.tagName) {
                    case "b":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.bold = true;
                        }
                        else
                            this.popStyle();
                        break;
                    case "i":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.italic = true;
                        }
                        else
                            this.popStyle();
                        break;
                    case "u":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.underline = true;
                        }
                        else
                            this.popStyle();
                        break;
                    case "strike":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.strikethrough = true;
                        }
                        else
                            this.popStyle();
                        break;
                    case "font":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.fontSize = XMLUtils.getInt(XMLIterator.attributes, "size", this._style.fontSize);
                            let color = XMLIterator.getAttribute("color");
                            if (color != null) {
                                this._style.color = color;
                                this._style.colorChanged = true;
                            }
                        }
                        else if (XMLIterator.tagType == exports.XMLTagType.End)
                            this.popStyle();
                        break;
                    case "br":
                        this.appendText("\n");
                        break;
                    case "img":
                        if (XMLIterator.tagType == exports.XMLTagType.Start || XMLIterator.tagType == exports.XMLTagType.Void) {
                            let element = HtmlElement.getFromPool(exports.HtmlElementType.Image);
                            element.fetchAttributes();
                            element.name = element.getAttrString("name");
                            element.style.align = this._style.align;
                            element.style.underline = this._style.underline;
                            element.style.underlineColor = this._style.underlineColor;
                            this._elements.push(element);
                        }
                        break;
                    case "a":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.underline = this._style.underline || options.linkUnderline;
                            if (!this._style.colorChanged && options.linkColor != null)
                                this._style.color = options.linkColor;
                            let element = HtmlElement.getFromPool(exports.HtmlElementType.Link);
                            element.fetchAttributes();
                            element.name = element.getAttrString("name");
                            element.style.align = this._style.align;
                            this._elements.push(element);
                        }
                        else if (XMLIterator.tagType == exports.XMLTagType.End) {
                            this.popStyle();
                            let element = HtmlElement.getFromPool(exports.HtmlElementType.LinkEnd);
                            this._elements.push(element);
                        }
                        break;
                    case "input":
                        {
                            let element = HtmlElement.getFromPool(exports.HtmlElementType.Input);
                            element.fetchAttributes();
                            element.name = element.getAttrString("name");
                            Object.assign(element.style, this._style);
                            this._elements.push(element);
                        }
                        break;
                    case "select":
                        {
                            if (XMLIterator.tagType == exports.XMLTagType.Start || XMLIterator.tagType == exports.XMLTagType.Void) {
                                let element = HtmlElement.getFromPool(exports.HtmlElementType.Select);
                                element.fetchAttributes();
                                if (XMLIterator.tagType == exports.XMLTagType.Start) {
                                    s_list1.length = 0;
                                    s_list2.length = 0;
                                    while (XMLIterator.nextTag()) {
                                        if (XMLIterator.tagName == "select")
                                            break;
                                        if (XMLIterator.tagName == "option") {
                                            if (XMLIterator.tagType == exports.XMLTagType.Start || XMLIterator.tagType == exports.XMLTagType.Void)
                                                s_list2.push(XMLUtils.getString(XMLIterator.attributes, "value", ""));
                                            else
                                                s_list1.push(XMLIterator.getText());
                                        }
                                    }
                                    element.setAttr("items", s_list1.slice());
                                    element.setAttr("values", s_list2.slice());
                                }
                                element.name = element.getAttrString("name");
                                Object.assign(element.style, this._style);
                                this._elements.push(element);
                            }
                        }
                        break;
                    case "p":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.align = XMLIterator.getAttribute("align");
                            if (!this.isNewLine())
                                this.appendText("\n");
                        }
                        else if (XMLIterator.tagType == exports.XMLTagType.End) {
                            this.appendText("\n");
                            skipNextCR = true;
                            this.popStyle();
                        }
                        break;
                    case "ui":
                    case "div":
                    case "li":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            if (!this.isNewLine())
                                this.appendText("\n");
                        }
                        else {
                            this.appendText("\n");
                            skipNextCR = true;
                        }
                        break;
                    case "html":
                    case "body":
                        ignoreWhiteSpace = true;
                        break;
                    case "head":
                    case "style":
                    case "script":
                    case "form":
                        if (XMLIterator.tagType == exports.XMLTagType.Start)
                            skipText++;
                        else if (XMLIterator.tagType == exports.XMLTagType.End)
                            skipText--;
                        break;
                }
            }
            if (skipText == 0) {
                text = XMLIterator.getText(ignoreWhiteSpace);
                if (text.length > 0) {
                    if (skipNextCR && text[0] == '\n')
                        text = text.substring(1);
                    this.appendText(text);
                }
            }
            this._elements = null;
        }
        pushStyle() {
            let tf;
            if (this._styleStack.length <= this._styleStackTop) {
                tf = new TextStyle();
                this._styleStack.push(tf);
            }
            else
                tf = this._styleStack[this._styleStackTop];
            Object.assign(tf, this._style);
            this._styleStackTop++;
        }
        popStyle() {
            if (this._styleStackTop > 0) {
                let tf = this._styleStack[this._styleStackTop - 1];
                Object.assign(this._style, tf);
                this._styleStackTop--;
            }
        }
        isNewLine() {
            if (this._elements.length > 0) {
                let element = this._elements[this._elements.length - 1];
                if (element && element.type == exports.HtmlElementType.Text)
                    return element.text.endsWith("\n");
                else
                    return false;
            }
            return true;
        }
        appendText(text) {
            let element;
            if (this._elements.length > 0) {
                element = this._elements[this._elements.length - 1];
                if (element.type == exports.HtmlElementType.Text && equalStyle(element.style, this._style)) {
                    element.text += text;
                    return;
                }
            }
            element = HtmlElement.getFromPool(exports.HtmlElementType.Text);
            element.text = text;
            Object.assign(element.style, this._style);
            this._elements.push(element);
        }
    }
    HtmlParser.defaultParser = new HtmlParser();
    HtmlParser.classMap = {
        [exports.HtmlElementType.Image]: HtmlImage,
        [exports.HtmlElementType.Link]: HtmlLink
    };
    function equalStyle(s1, s2) {
        for (let k in s1) {
            if (!k.startsWith("_") && s1[k] != s2[k])
                return false;
        }
        return true;
    }

    class UBBParser {
        constructor() {
            this._readPos = 0;
            this.defaultImgWidth = 0;
            this.defaultImgHeight = 0;
            this._handlers = {};
            this._handlers["url"] = this.onTag_URL;
            this._handlers["img"] = this.onTag_IMG;
            this._handlers["b"] = this.onTag_B;
            this._handlers["i"] = this.onTag_I;
            this._handlers["u"] = this.onTag_U;
            this._handlers["sup"] = this.onTag_Simple;
            this._handlers["sub"] = this.onTag_Simple;
            this._handlers["color"] = this.onTag_COLOR;
            this._handlers["font"] = this.onTag_FONT;
            this._handlers["size"] = this.onTag_SIZE;
        }
        onTag_URL(tagName, end, attr) {
            if (!end) {
                if (attr != null)
                    return "<a href=\"" + attr + "\">";
                else {
                    var href = this.getTagText();
                    return "<a href=\"" + href + "\">";
                }
            }
            else
                return "</a>";
        }
        onTag_IMG(tagName, end, attr) {
            if (!end) {
                var src = this.getTagText(true);
                if (!src)
                    return null;
                if (this.defaultImgWidth)
                    return "<img src=\"" + src + "\" width=\"" + this.defaultImgWidth + "\" height=\"" + this.defaultImgHeight + "\"/>";
                else
                    return "<img src=\"" + src + "\"/>";
            }
            else
                return null;
        }
        onTag_B(tagName, end, attr) {
            return end ? ("</b>") : ("<b>");
        }
        onTag_I(tagName, end, attr) {
            return end ? ("</i>") : ("<i>");
        }
        onTag_U(tagName, end, attr) {
            return end ? ("</u>") : ("<u>");
        }
        onTag_Simple(tagName, end, attr) {
            return end ? ("</" + tagName + ">") : ("<" + tagName + ">");
        }
        onTag_COLOR(tagName, end, attr) {
            if (!end) {
                this.lastColor = attr;
                return "<font color=\"" + attr + "\">";
            }
            else
                return "</font>";
        }
        onTag_FONT(tagName, end, attr) {
            if (!end)
                return "<font face=\"" + attr + "\">";
            else
                return "</font>";
        }
        onTag_SIZE(tagName, end, attr) {
            if (!end) {
                this.lastSize = attr;
                return "<font size=\"" + attr + "\">";
            }
            else
                return "</font>";
        }
        getTagText(remove) {
            var pos1 = this._readPos;
            var pos2;
            var result = "";
            while ((pos2 = this._text.indexOf("[", pos1)) != -1) {
                if (this._text.charCodeAt(pos2 - 1) == 92) {
                    result += this._text.substring(pos1, pos2 - 1);
                    result += "[";
                    pos1 = pos2 + 1;
                }
                else {
                    result += this._text.substring(pos1, pos2);
                    break;
                }
            }
            if (pos2 == -1)
                return null;
            if (remove)
                this._readPos = pos2;
            return result;
        }
        parse(text, remove) {
            this._text = text;
            this.lastColor = null;
            this.lastSize = null;
            var pos1 = 0, pos2, pos3;
            var end;
            var tag, attr;
            var repl;
            var func;
            var result = "";
            while ((pos2 = text.indexOf("[", pos1)) != -1) {
                if (pos2 > 0 && text.charCodeAt(pos2 - 1) == 92) {
                    result += text.substring(pos1, pos2 - 1);
                    result += "[";
                    pos1 = pos2 + 1;
                    continue;
                }
                result += text.substring(pos1, pos2);
                pos1 = pos2;
                pos2 = text.indexOf("]", pos1);
                if (pos2 == -1)
                    break;
                end = text.charAt(pos1 + 1) == '/';
                tag = text.substring(end ? pos1 + 2 : pos1 + 1, pos2);
                this._readPos = pos2 + 1;
                attr = null;
                repl = null;
                pos3 = tag.indexOf("=");
                if (pos3 != -1) {
                    attr = tag.substring(pos3 + 1);
                    tag = tag.substring(0, pos3);
                }
                tag = tag.toLowerCase();
                func = this._handlers[tag];
                if (func != null) {
                    if (!remove) {
                        repl = func.call(this, tag, end, attr);
                        if (repl != null)
                            result += repl;
                    }
                }
                else
                    result += text.substring(pos1, this._readPos);
                pos1 = this._readPos;
            }
            if (pos1 < text.length)
                result += text.substring(pos1);
            this._text = null;
            return result;
        }
    }
    UBBParser.defaultParser = new UBBParser();

    class Text extends Sprite {
        constructor() {
            super();
            this._overflow = Text.VISIBLE;
            this._singleCharRender = false;
            this._prompt = '';
            this._textWidth = 0;
            this._textHeight = 0;
            this._textStyle = new TextStyle();
            this._textStyle.fontSize = Config.defaultFontSize;
            this._text = "";
            this.font = "";
            this._elements = [];
            this._lines = [];
            this._padding = [0, 0, 0, 0];
            this._fontSizeScale = 1;
        }
        static registerBitmapFont(name, bitmapFont) {
            bitmapFont._addReference();
            Text._bitmapFonts[name] = bitmapFont;
        }
        static unregisterBitmapFont(name, destroy = true) {
            let font = Text._bitmapFonts[name];
            if (font) {
                font._removeReference();
                if (destroy)
                    font.destroy();
                delete Text._bitmapFonts[name];
            }
        }
        destroy(destroyChild = true) {
            recoverLines(this._lines);
            HtmlElement.returnToPool(this._elements);
            super.destroy(destroyChild);
        }
        _getBoundPointsM(ifRotate = false) {
            var rec = Rectangle.TEMP;
            rec.setTo(0, 0, this.width, this.height);
            return rec._getBoundPoints();
        }
        getGraphicBounds(realSize = false) {
            var rec = Rectangle.TEMP;
            rec.setTo(0, 0, this.width, this.height);
            return rec;
        }
        get_width() {
            if (this._isWidthSet)
                return this._width;
            return this.textWidth;
        }
        _setWidth(value) {
            super._setWidth(value);
            if (!this._updatingLayout)
                this.markChanged();
            else
                this.drawBg();
        }
        get_height() {
            if (this._isHeightSet)
                return this._height;
            return this.textHeight;
        }
        _setHeight(value) {
            super._setHeight(value);
            if (!this._updatingLayout)
                this.markChanged();
            else
                this.drawBg();
        }
        get textWidth() {
            this.typeset();
            return this._textWidth;
        }
        get textHeight() {
            this.typeset();
            return this._textHeight;
        }
        get text() {
            return this._text;
        }
        set text(value) {
            if (value == null)
                value = "";
            else if (typeof (value) !== "string")
                value = '' + value;
            if (!this.ignoreLang && Text.langPacks)
                value = Text.langPacks[value] || value;
            if (this._text != value) {
                this._text = value;
                this.markChanged();
                this.event(Event.CHANGE);
            }
        }
        changeText(text) {
            this.text = text;
        }
        get font() {
            return this._textStyle.font;
        }
        set font(value) {
            this._textStyle.font = value;
            if (!value) {
                value = Config.defaultFont;
                if (!value)
                    value = "Arial";
            }
            this._realFont = value;
            this._bitmapFont = Text._bitmapFonts[value];
            if (this._bitmapFont) {
                if (this._text)
                    this.markChanged();
            }
            else if (value && (Utils.getFileExtension(value) || value.startsWith("res://"))) {
                let t = value;
                let fontObj = ILaya.loader.getRes(value);
                if (!fontObj || fontObj.obsolute) {
                    ILaya.loader.load(value).then(fontObj => {
                        if (!fontObj || this._realFont != t)
                            return;
                        if (fontObj instanceof BitmapFont)
                            this._bitmapFont = fontObj;
                        else
                            this._realFont = fontObj.family;
                        if (this._text)
                            this.markChanged();
                    });
                }
                else {
                    if (fontObj instanceof BitmapFont)
                        this._bitmapFont = fontObj;
                    else
                        this._realFont = fontObj.family;
                    if (this._text)
                        this.markChanged();
                }
            }
            else {
                this._realFont = (Browser.onIPhone ? (Config.fontFamilyMap[value] || value) : value);
                if (this._text)
                    this.markChanged();
            }
        }
        get fontSize() {
            return this._textStyle.fontSize;
        }
        set fontSize(value) {
            if (this._textStyle.fontSize != value) {
                this._textStyle.fontSize = value;
                this.markChanged();
            }
        }
        get color() {
            return this._textStyle.color;
        }
        set color(value) {
            this.set_color(value);
        }
        set_color(value) {
            if (this._textStyle.color != value) {
                this._textStyle.color = value;
                if (!this._isChanged && this._graphics && this._elements.length == 0)
                    this._graphics.replaceTextColor(this._textStyle.color);
                else
                    this.markChanged();
            }
        }
        get bold() {
            return this._textStyle.bold;
        }
        set bold(value) {
            if (this._textStyle.bold != value) {
                this._textStyle.bold = value;
                this.markChanged();
            }
        }
        get italic() {
            return this._textStyle.italic;
        }
        set italic(value) {
            if (this._textStyle.italic != value) {
                this._textStyle.italic = value;
                this.markChanged();
            }
        }
        get align() {
            return this._textStyle.align;
        }
        set align(value) {
            if (this._textStyle.align != value) {
                this._textStyle.align = value;
                this.markChanged();
            }
        }
        get valign() {
            return this._textStyle.valign;
        }
        set valign(value) {
            if (this._textStyle.valign != value) {
                this._textStyle.valign = value;
                this.markChanged();
            }
        }
        get alignItems() {
            return this._textStyle.alignItems;
        }
        set alignItems(value) {
            if (this._textStyle.alignItems != value) {
                this._textStyle.alignItems = value;
                this.markChanged();
            }
        }
        get wordWrap() {
            return this._wordWrap;
        }
        set wordWrap(value) {
            if (this._wordWrap != value) {
                this._wordWrap = value;
                this.markChanged();
            }
        }
        get leading() {
            return this._textStyle.leading;
        }
        set leading(value) {
            if (this._textStyle.leading != value) {
                this._textStyle.leading = value;
                this.markChanged();
            }
        }
        get padding() {
            return this._padding;
        }
        set padding(value) {
            if (typeof (value) == 'string') {
                let arr = value.split(",");
                this._padding.length = 0;
                for (let i = 0; i < 4; i++) {
                    let v = parseFloat(arr[i]);
                    if (isNaN(v))
                        v = 0;
                    this._padding.push(v);
                }
            }
            else
                this._padding = value;
            this.markChanged();
        }
        get bgColor() {
            return this._bgColor;
        }
        set bgColor(value) {
            this._bgColor = value;
            this.drawBg();
        }
        get borderColor() {
            return this._borderColor;
        }
        set borderColor(value) {
            this._borderColor = value;
            this.drawBg();
        }
        get stroke() {
            return this._textStyle.stroke;
        }
        set stroke(value) {
            if (this._textStyle.stroke != value) {
                this._textStyle.stroke = value;
                this.markChanged();
            }
        }
        get strokeColor() {
            return this._textStyle.strokeColor;
        }
        set strokeColor(value) {
            if (this._textStyle.strokeColor != value) {
                this._textStyle.strokeColor = value;
                this.markChanged();
            }
        }
        get overflow() {
            return this._overflow;
        }
        set overflow(value) {
            if (this._overflow != value) {
                this._overflow = value;
                this.markChanged();
            }
        }
        get underline() {
            return this._textStyle.underline;
        }
        set underline(value) {
            if (this._textStyle.underline != value) {
                this._textStyle.underline = value;
                this.markChanged();
            }
        }
        get underlineColor() {
            return this._textStyle.underlineColor;
        }
        set underlineColor(value) {
            if (this._textStyle.underlineColor != value) {
                this._textStyle.underlineColor = value;
                this.markChanged();
            }
        }
        get strikethrough() {
            return this._textStyle.strikethrough;
        }
        set strikethrough(value) {
            if (this._textStyle.strikethrough != value) {
                this._textStyle.strikethrough = value;
                this.markChanged();
            }
        }
        get strikethroughColor() {
            return this._textStyle.strikethroughColor;
        }
        set strikethroughColor(value) {
            if (this._textStyle.strikethroughColor != value) {
                this._textStyle.strikethroughColor = value;
                this.markChanged();
            }
        }
        get singleCharRender() {
            return this._singleCharRender;
        }
        set singleCharRender(value) {
            this._singleCharRender = value;
        }
        get html() {
            return this._html;
        }
        set html(value) {
            if (this._html != value) {
                this._html = value;
                this.markChanged();
            }
        }
        get ubb() {
            return this._ubb;
        }
        set ubb(value) {
            if (this._ubb != value) {
                this._ubb = value;
                this.markChanged();
            }
        }
        get maxWidth() {
            return this._maxWidth;
        }
        set maxWidth(value) {
            if (this._maxWidth != value) {
                this._maxWidth = value;
                this.markChanged();
            }
        }
        get htmlParseOptions() {
            return this._htmlParseOptions;
        }
        set htmlParseOptions(value) {
            this._htmlParseOptions = value;
        }
        parseTemplate(template) {
            let pos1 = 0, pos2, pos3;
            let tag;
            let value;
            let result = "";
            while ((pos2 = template.indexOf("{", pos1)) != -1) {
                if (pos2 > 0 && template.charCodeAt(pos2 - 1) == 92) {
                    result += template.substring(pos1, pos2 - 1);
                    result += "{";
                    pos1 = pos2 + 1;
                    continue;
                }
                result += template.substring(pos1, pos2);
                pos1 = pos2;
                pos2 = template.indexOf("}", pos1);
                if (pos2 == -1)
                    break;
                if (pos2 == pos1 + 1) {
                    result += template.substring(pos1, pos1 + 2);
                    pos1 = pos2 + 1;
                    continue;
                }
                tag = template.substring(pos1 + 1, pos2);
                pos3 = tag.indexOf("=");
                if (pos3 != -1) {
                    value = this._templateVars[tag.substring(0, pos3)];
                    if (value == null)
                        result += tag.substring(pos3 + 1);
                    else
                        result += value;
                }
                else {
                    value = this._templateVars[tag];
                    if (value != null)
                        result += value;
                }
                pos1 = pos2 + 1;
            }
            if (pos1 < template.length)
                result += template.substring(pos1);
            return result;
        }
        get templateVars() {
            return this._templateVars;
        }
        set templateVars(value) {
            if (!this._templateVars && !value)
                return;
            if (value === true)
                this._templateVars = {};
            else if (value === false)
                this._templateVars = null;
            else
                this._templateVars = value;
            this.markChanged();
        }
        setVar(name, value) {
            if (!this._templateVars)
                this._templateVars = {};
            this._templateVars[name] = value;
            this.markChanged();
            return this;
        }
        get scrollX() {
            if (!this._scrollPos)
                return 0;
            return this._scrollPos.x;
        }
        set scrollX(value) {
            this.typeset();
            if (!this._scrollPos)
                return;
            let maxScrollX = this.maxScrollX;
            value = value < 0 ? 0 : value;
            value = value > maxScrollX ? maxScrollX : value;
            this._scrollPos.x = value;
            this.renderText();
        }
        get scrollY() {
            if (!this._scrollPos)
                return 0;
            return this._scrollPos.y;
        }
        set scrollY(value) {
            this.typeset();
            if (!this._scrollPos)
                return;
            let maxScrollY = this.maxScrollY;
            value = value < 0 ? 0 : value;
            value = value > maxScrollY ? maxScrollY : value;
            this._scrollPos.y = value;
            this.renderText();
        }
        get maxScrollX() {
            let r = this.textWidth - this._width;
            return r < 0 ? 0 : r;
        }
        get maxScrollY() {
            let r = this.textHeight - this._height;
            return r < 0 ? 0 : r;
        }
        get lines() {
            this.typeset();
            return this._lines;
        }
        markChanged() {
            if (!this._isChanged) {
                this._isChanged = true;
                ILaya.systemTimer.callLater(this, this._typeset);
            }
        }
        typeset() {
            this._isChanged && ILaya.systemTimer.runCallLater(this, this._typeset);
        }
        refreshLayout() {
            ILaya.systemTimer.callLater(this, this.doLayout);
        }
        get objContainer() {
            if (!this._objContainer) {
                this._objContainer = new Sprite();
                this._objContainer.hideFlags |= HideFlags.HideAndDontSave;
                this.addChild(this._objContainer);
            }
            return this._objContainer;
        }
        _typeset() {
            this._isChanged = false;
            if (this._hideText || this._destroyed)
                return;
            HtmlElement.returnToPool(this._elements);
            if (this._objContainer)
                this._objContainer.removeChildren();
            let text = this._text;
            let isPrompt;
            if (!text && this._prompt) {
                text = this._prompt;
                isPrompt = true;
            }
            if (!text) {
                if (this._bgDrawCmd)
                    this.graphics.removeCmd(this._bgDrawCmd);
                this.graphics.clear(true);
                this.drawBg();
                this._textWidth = this._textHeight = 0;
                this._scrollPos = null;
                if (this._onPostLayout) {
                    this._updatingLayout = true;
                    this._onPostLayout();
                    this._updatingLayout = false;
                }
                return;
            }
            let html = this._html;
            text = text.replace(normalizeCR, "\n");
            if (this._parseEscapeChars)
                text = text.replace(escapeCharsPattern, getReplaceStr);
            if (!isPrompt && this._templateVars)
                text = this.parseTemplate(text);
            if (this._ubb) {
                text = UBBParser.defaultParser.parse(text);
                html = true;
            }
            if (!isPrompt && this._asPassword)
                text = Text._passwordChar.repeat(text.length);
            let saveColor;
            if (isPrompt) {
                saveColor = this._textStyle.color;
                this._textStyle.color = this._promptColor;
            }
            if (html)
                HtmlParser.defaultParser.parse(text, this._textStyle, this._elements, this._htmlParseOptions);
            else {
                let ele = HtmlElement.getFromPool(exports.HtmlElementType.Text);
                Object.assign(ele.style, this._textStyle);
                ele.text = text;
                this._elements.push(ele);
            }
            if (isPrompt)
                this._textStyle.color = saveColor;
            this.doLayout();
        }
        doLayout() {
            if (this._destroyed)
                return;
            this._updatingLayout = true;
            this._fontSizeScale = 1;
            let wordWrap = this._wordWrap || this._overflow == Text.ELLIPSIS;
            let padding = this._padding;
            let rectWidth;
            if (this._isWidthSet)
                rectWidth = this._width - padding[3] - padding[1];
            else
                rectWidth = Number.MAX_VALUE;
            if (this._maxWidth > 0) {
                let m = this._maxWidth - padding[3] - padding[1];
                if (!wordWrap || m < rectWidth)
                    rectWidth = m;
                wordWrap = true;
            }
            let rectHeight = this._isHeightSet ? (this._height - padding[0] - padding[2]) : Number.MAX_VALUE;
            let bfont = this._bitmapFont;
            let alignItems = this._textStyle.alignItems == "middle" ? 1 : (this._textStyle.alignItems == "bottom" ? 2 : 0);
            let lineX, lineY;
            let curLine;
            let lastCmd;
            let charWidth, charHeight;
            let fontSize;
            let ctxFont;
            let getTextWidth = (text) => {
                if (bfont)
                    return bfont.getTextWidth(text, fontSize);
                else {
                    let ret = Browser.context.measureText(text);
                    return ret ? ret.width : 100;
                }
            };
            let getTextWidth2 = (text, font, fontSize) => {
                if (bfont) {
                    return bfont.getTextWidth(text, fontSize);
                }
                else {
                    let t = Browser.context.font;
                    Browser.context.font = font;
                    let ret = Browser.context.measureText(text);
                    Browser.context.font = t;
                    return ret ? ret.width : 100;
                }
            };
            let buildLines = (text, style) => {
                fontSize = Math.floor(style.fontSize * this._fontSizeScale);
                if (fontSize == 0)
                    fontSize = 1;
                if (bfont) {
                    charWidth = bfont.getMaxWidth(fontSize);
                    charHeight = bfont.getMaxHeight(fontSize);
                }
                else {
                    Browser.context.font = ctxFont = (style.italic ? "italic " : "") + (style.bold ? "bold " : "") + fontSize + "px " + this._realFont;
                    let mr = Browser.context.measureText(Text._testWord);
                    if (mr) {
                        charWidth = mr.width;
                        charHeight = Math.ceil(mr.height || fontSize);
                    }
                    else {
                        charWidth = 100;
                        charHeight = fontSize;
                    }
                }
                let lines = text.split("\n");
                if (wordWrap) {
                    for (let i = 0, n = lines.length; i < n; i++) {
                        let line = lines[i];
                        if (line.length > 0)
                            wrapText(line, style);
                        if (i != n - 1) {
                            addLine();
                        }
                    }
                }
                else {
                    for (let i = 0, n = lines.length; i < n; i++) {
                        let line = lines[i];
                        if (line.length > 0)
                            addCmd(line, style, null);
                        if (i != n - 1) {
                            addLine();
                        }
                    }
                }
            };
            let addCmd = (target, style, width) => {
                let cmd = cmdPool.length > 0 ? cmdPool.pop() : {};
                cmd.x = lineX;
                cmd.y = lineY;
                if (typeof (target) === "string") {
                    if (!width)
                        width = getTextWidth(target);
                    if (!cmd.wt)
                        cmd.wt = new WordText$1();
                    cmd.wt.setText(target);
                    cmd.wt.width = width;
                    cmd.wt.splitRender = this._singleCharRender;
                    cmd.ctxFont = ctxFont;
                    cmd.fontSize = fontSize;
                    cmd.width = width;
                    cmd.height = charHeight;
                }
                else {
                    cmd.obj = target;
                    cmd.width = target.width;
                    cmd.height = target.height;
                    if (target.width > 0) {
                        cmd.x++;
                        cmd.width += 2;
                    }
                }
                cmd.style = style;
                cmd.linkEnd = false;
                cmd.next = null;
                cmd.prev = lastCmd;
                lineX += Math.round(cmd.width);
                if (lastCmd)
                    lastCmd.next = cmd;
                else
                    curLine.cmd = cmd;
                lastCmd = cmd;
            };
            let moveCmds = (cmd) => {
                while (cmd.linkEnd) {
                    cmd = cmd.next;
                }
                if (!cmd)
                    return;
                cmd.prev.next = null;
                while (cmd) {
                    let next = cmd.next;
                    cmd.x = lineX;
                    cmd.y = lineY;
                    cmd.next = null;
                    cmd.prev = lastCmd;
                    lineX += Math.round(cmd.width);
                    if (lastCmd)
                        lastCmd.next = cmd;
                    else
                        curLine.cmd = cmd;
                    lastCmd = cmd;
                    cmd = next;
                }
            };
            let splitCmd = (cmd, pos) => {
                let ccode = cmd.wt.text.charCodeAt(pos);
                if (isLowSurrogate(ccode))
                    pos--;
                if (pos == 0)
                    return false;
                let str = cmd.wt.text.substring(pos);
                cmd.wt.setText(cmd.wt.text.substring(0, pos));
                cmd.width = cmd.wt.width = getTextWidth2(cmd.wt.text, cmd.ctxFont, cmd.fontSize);
                let cmd2 = cmdPool.length > 0 ? cmdPool.pop() : {};
                if (!cmd2.wt)
                    cmd2.wt = new WordText$1();
                cmd2.wt.setText(str);
                cmd2.style = cmd.style;
                cmd2.ctxFont = cmd.ctxFont;
                cmd2.fontSize = cmd.fontSize;
                cmd2.width = cmd2.wt.width = getTextWidth2(str, cmd.ctxFont, cmd.fontSize);
                cmd2.height = cmd.height;
                cmd2.next = cmd.next;
                cmd2.prev = cmd;
                cmd.next = cmd2;
                return true;
            };
            let addLine = (last) => {
                lineX = 0;
                if (curLine) {
                    let lineHeight = 0;
                    let lineWidth = 0;
                    let cmd = curLine.cmd;
                    while (cmd) {
                        if (cmd.height > lineHeight)
                            lineHeight = cmd.height;
                        lineWidth += cmd.width;
                        cmd = cmd.next;
                    }
                    cmd = curLine.cmd;
                    while (cmd) {
                        if (alignItems == 1)
                            cmd.y = Math.floor((lineHeight - cmd.height) * 0.5);
                        else if (alignItems == 2)
                            cmd.y = Math.floor((lineHeight - cmd.height));
                        else
                            cmd.y = 0;
                        cmd = cmd.next;
                    }
                    if (lineHeight == 0)
                        lineHeight = charHeight;
                    lineHeight++;
                    curLine.height = lineHeight;
                    curLine.width = Math.round(lineWidth);
                    lineY += curLine.height + Math.floor(this._textStyle.leading * this._fontSizeScale);
                }
                if (last)
                    return null;
                curLine = linePool.length > 0 ? linePool.pop() : {};
                curLine.x = 0;
                curLine.y = lineY;
                this._lines.push(curLine);
                lastCmd = null;
                return curLine;
            };
            let wrapText = (text, style) => {
                let remainWidth = Math.max(0, rectWidth - lineX);
                let tw = getTextWidth(text);
                if (tw <= remainWidth) {
                    addCmd(text, style, tw);
                    return;
                }
                let maybeIndex = 0;
                let wordWidth = 0;
                let startIndex = 0;
                let isPunc;
                let testResult;
                let isEmoji = emojiTest.test(text);
                if (!bfont && !isEmoji) {
                    maybeIndex = Math.floor(remainWidth / charWidth);
                    if (maybeIndex != 0)
                        wordWidth = getTextWidth(text.substring(0, maybeIndex));
                }
                let len = text.length;
                for (let j = maybeIndex; j < len; j++) {
                    let cc = text.charAt(j);
                    let ccode = cc.charCodeAt(0);
                    if (isEmoji && isHighSurrogate(ccode) && j + 1 < len)
                        cc += text.charAt(j + 1);
                    tw = getTextWidth(cc);
                    wordWidth += tw;
                    if (wordWidth <= remainWidth || j === startIndex && lineX === 0) {
                        if (cc.length > 1)
                            j++;
                        continue;
                    }
                    let part = text.substring(startIndex, j);
                    wordWidth -= tw;
                    if ((ccode >= 65 && ccode <= 90) || (ccode >= 97 && ccode <= 122)
                        || (ccode >= 48 && ccode <= 57)
                        || (isPunc = punctuationChars.includes(ccode))) {
                        let wb = part.length > 0 ? ((testResult = wordBoundaryTest.exec(part)) ? testResult.index : null) : 0;
                        if (wb > 0) {
                            if (wb > part.length - maxWordLength) {
                                j = startIndex + wb;
                                part = text.substring(startIndex, j);
                                wordWidth = null;
                                tw = null;
                            }
                        }
                        else if (wb != null && lastCmd != null) {
                            let cmd = lastCmd;
                            let totalLen = part.length;
                            let newLine = false;
                            while (cmd) {
                                if (cmd.width > 0) {
                                    if (cmd.obj != null)
                                        break;
                                    testResult = wordBoundaryTest.exec(cmd.wt.text);
                                    let textLen = cmd.wt.text.length;
                                    if (testResult == null) {
                                        addLine();
                                        if (isPunc && totalLen == 0) {
                                            if (splitCmd(cmd, textLen - 1))
                                                moveCmds(cmd.next);
                                            else if (cmd.x > 0)
                                                moveCmds(cmd);
                                        }
                                        else if (cmd.next != null)
                                            moveCmds(cmd.next);
                                        newLine = true;
                                        break;
                                    }
                                    else if (testResult.index > 0) {
                                        if (testResult.index > textLen - (maxWordLength - totalLen)) {
                                            addLine();
                                            splitCmd(cmd, testResult.index);
                                            moveCmds(cmd.next);
                                            newLine = true;
                                        }
                                        break;
                                    }
                                    else {
                                        totalLen += textLen;
                                        if (totalLen >= maxWordLength)
                                            break;
                                    }
                                }
                                cmd = cmd.prev;
                            }
                            if (newLine) {
                                remainWidth = rectWidth - lineX;
                                if (wordWidth + tw < remainWidth) {
                                    wordWidth += tw;
                                    continue;
                                }
                            }
                        }
                        else {
                            if (isPunc) {
                                let b = (isEmoji && j >= 1 && isLowSurrogate(text.charCodeAt(j - 1))) ? 2 : 1;
                                if (j - b > startIndex || lineX > 0) {
                                    j -= b;
                                    part = text.substring(startIndex, j);
                                    wordWidth = null;
                                    tw = null;
                                }
                            }
                        }
                    }
                    if (part.length > 0)
                        addCmd(part, style, wordWidth);
                    addLine();
                    startIndex = j;
                    remainWidth = rectWidth;
                    wordWidth = null;
                    if (maybeIndex > 1)
                        j += maybeIndex - 1;
                    else if (tw != null) {
                        wordWidth = tw;
                        if (cc.length > 1)
                            j++;
                    }
                    else if (isEmoji && isHighSurrogate(text.charCodeAt(j)))
                        j++;
                    if (wordWidth == null && j < len - 1)
                        wordWidth = getTextWidth(text.substring(startIndex, j + 1));
                }
                addCmd(text.substring(startIndex, len), style);
            };
            let calcTextSize = () => {
                let nw = 0, nh = 0;
                for (let line of this._lines) {
                    if (line.width > nw)
                        nw = line.width;
                }
                if (nw > 0)
                    nw += padding[1] + padding[3];
                this._textWidth = nw;
                let lastLine = this._lines[this._lines.length - 1];
                if (lastLine)
                    nh = lastLine.y + lastLine.height;
                if (nh > 0)
                    nh += padding[0] + padding[2];
                this._textHeight = nh;
            };
            let run = () => {
                lineX = lineY = charWidth = charHeight = 0;
                curLine = null;
                lastCmd = null;
                recoverLines(this._lines);
                addLine();
                let elements = this._elements;
                for (let i = 0, n = elements.length; i < n; i++) {
                    let ele = elements[i];
                    if (ele.type == exports.HtmlElementType.Text) {
                        buildLines(ele.text, ele.style);
                    }
                    else if (ele.type == exports.HtmlElementType.LinkEnd) {
                        if (lastCmd)
                            lastCmd.linkEnd = true;
                    }
                    else {
                        let htmlObj = ele.obj;
                        if (!htmlObj) {
                            let cls = HtmlParser.classMap[ele.type];
                            if (cls) {
                                htmlObj = Pool.createByClass(cls);
                                htmlObj.create(this, ele);
                                ele.obj = htmlObj;
                            }
                        }
                        if (htmlObj) {
                            if (wordWrap) {
                                let remainWidth = rectWidth - lineX;
                                if (htmlObj.width > 0 && remainWidth < htmlObj.width + 1) {
                                    if (lineX > 0) {
                                        addLine();
                                    }
                                }
                            }
                            addCmd(htmlObj, ele.style);
                        }
                    }
                }
                addLine(true);
                calcTextSize();
            };
            run();
            if (this._overflow == Text.SHRINK) {
                if (this._lines.length > 1 && this._textHeight > rectHeight) {
                    let low = 0;
                    let high = this._textStyle.fontSize;
                    this._fontSizeScale = Math.sqrt(rectHeight / this._textHeight);
                    let cur = Math.floor(this._fontSizeScale * this._textStyle.fontSize);
                    while (true) {
                        run();
                        if (this._textWidth > rectWidth || this._textHeight > rectHeight)
                            high = cur;
                        else
                            low = cur;
                        if (high - low > 1 || high != low && cur == high) {
                            cur = low + (high - low) / 2;
                            this._fontSizeScale = cur / this._textStyle.fontSize;
                        }
                        else
                            break;
                    }
                }
                else if (this._textWidth > rectWidth) {
                    this._fontSizeScale = rectWidth / this._textWidth;
                    run();
                    if (this._textWidth > rectWidth) {
                        let size = Math.floor(this._textStyle.fontSize * this._fontSizeScale);
                        size--;
                        this._fontSizeScale = size / this._textStyle.fontSize;
                        run();
                    }
                }
            }
            else if (this._overflow == Text.ELLIPSIS
                && (this._textWidth > rectWidth || this._textHeight > rectHeight || !this._wordWrap && this._lines.length > 1)) {
                let i;
                if (!this._wordWrap && this._lines.length > 1)
                    i = 1;
                else {
                    i = this._lines.findIndex(line => line.y + line.height > rectHeight);
                    if (i == 0)
                        i = 1;
                }
                let linesDeleted = false;
                if (i != -1 && this._lines.length > i) {
                    recoverLines(this._lines.splice(i, this._lines.length - i), true);
                    linesDeleted = true;
                }
                curLine = this._lines[this._lines.length - 1];
                let cmd = curLine.cmd;
                let next;
                let textCmd;
                let done = false;
                while (cmd) {
                    next = cmd.next;
                    if (!cmd.obj)
                        textCmd = cmd;
                    if (done) {
                        cleanCmd(cmd, true);
                        cmdPool.push(cmd);
                    }
                    else if ((!next && linesDeleted) || cmd.x + cmd.width > rectWidth) {
                        if (cmd.obj) {
                            cleanCmd(cmd, true);
                            cmd.wt = new WordText$1();
                            cmd.wt.setText(ellipsisStr);
                            if (textCmd) {
                                cmd.ctxFont = textCmd.ctxFont;
                                cmd.fontSize = textCmd.fontSize;
                                cmd.height = textCmd.height;
                                cmd.style = textCmd.style;
                            }
                            else {
                                cmd.ctxFont = ctxFont;
                                cmd.fontSize = fontSize;
                                cmd.height = charHeight;
                                cmd.style = this._textStyle;
                            }
                            cmd.wt.splitRender = this._singleCharRender;
                        }
                        else {
                            let i = cmd.wt.text.length - 2;
                            if (i > 0 && isLowSurrogate(cmd.wt.text.charCodeAt(i)))
                                i--;
                            cmd.wt.setText(cmd.wt.text.substring(0, Math.max(0, i)) + ellipsisStr);
                        }
                        cmd.width = cmd.wt.width = getTextWidth2(cmd.wt.text, cmd.ctxFont, cmd.fontSize);
                        cmd.next = null;
                        done = true;
                        addLine(true);
                    }
                    cmd = next;
                }
                if (done || linesDeleted)
                    calcTextSize();
            }
            if (this._onPostLayout)
                this._onPostLayout();
            let align = this._textStyle.align == "center" ? 1 : (this._textStyle.align == "right" ? 2 : 0);
            if (align != 0 && this._isWidthSet) {
                let rectWidth = this._width - padding[3] - padding[1];
                for (let line of this._lines) {
                    let offsetX = 0;
                    if (align == 1)
                        offsetX = Math.floor((rectWidth - line.width) * 0.5);
                    else if (align == 2)
                        offsetX = rectWidth - line.width;
                    if (offsetX > 0)
                        line.x = offsetX;
                }
            }
            if (this._isHeightSet && this._textHeight < this._height) {
                let offsetY = 0;
                if (this._textStyle.valign === "middle")
                    offsetY = Math.floor((this._height - this._textHeight) * 0.5);
                else if (this._textStyle.valign === "bottom")
                    offsetY = this._height - this._textHeight;
                if (offsetY > 0) {
                    for (let line of this._lines) {
                        line.y += offsetY;
                    }
                }
            }
            if (this._overflow == Text.SCROLL
                && (this._isWidthSet && this._textWidth > this._width || this._isHeightSet && this._textHeight > this._height)) {
                if (!this._scrollPos)
                    this._scrollPos = new Point(0, 0);
                else {
                    let maxScrollX = this.maxScrollX;
                    let maxScrollY = this.maxScrollY;
                    if (this._scrollPos.x > maxScrollX)
                        this._scrollPos.x = maxScrollX;
                    if (this._scrollPos.y > maxScrollY)
                        this._scrollPos.y = maxScrollY;
                }
            }
            else
                this._scrollPos = null;
            if (this._objContainer) {
                this._objContainer.size(this._width, this._height);
                if (this._scrollPos || this._overflow == Text.HIDDEN && this._objContainer.numChildren > 0) {
                    if (!this._objContainer.scrollRect)
                        this._objContainer.scrollRect = new Rectangle();
                    this._objContainer.scrollRect.setTo(0, 0, this._width, this._height);
                }
                else
                    this._objContainer.scrollRect = null;
            }
            this._updatingLayout = false;
            this.renderText();
        }
        renderText() {
            let graphics = this.graphics;
            if (this._bgDrawCmd)
                this.graphics.removeCmd(this._bgDrawCmd);
            graphics.clear(true);
            this.drawBg();
            let padding = this._padding;
            let paddingLeft = padding[3];
            let paddingTop = padding[0];
            let bfont = this._bitmapFont;
            let scrollPos = this._scrollPos;
            let rectWidth = this._isWidthSet ? this._width : this._textWidth;
            let rectHeight = this._isHeightSet ? this._height : this._textHeight;
            let bottom = rectHeight - padding[2];
            let clipped = this._overflow == Text.HIDDEN || this._overflow == Text.SCROLL;
            if (clipped) {
                graphics.save();
                graphics.clipRect(0, 0, rectWidth, rectHeight);
                this.repaint();
            }
            rectWidth -= (padding[3] + padding[1]);
            rectHeight -= (padding[0] + padding[2]);
            let x = 0, y = 0;
            let lines = this._lines;
            let lineCnt = lines.length;
            let curLink;
            let linkStartX;
            for (let i = 0; i < lineCnt; i++) {
                let line = lines[i];
                x = paddingLeft + line.x;
                y = paddingTop + line.y;
                if (scrollPos) {
                    x -= scrollPos.x;
                    y -= scrollPos.y;
                }
                let lineClipped = clipped && ((y + line.height) <= paddingTop || y >= bottom);
                let cmd = line.cmd;
                while (cmd) {
                    if (cmd.linkEnd) {
                        if (curLink) {
                            curLink.addRect(linkStartX, y, x + cmd.x + cmd.width - linkStartX, line.height);
                            curLink = null;
                        }
                    }
                    if (cmd.obj) {
                        cmd.obj.pos(x + cmd.x, y + cmd.y);
                        if (cmd.obj.element.type == exports.HtmlElementType.Link) {
                            curLink = cmd.obj;
                            curLink.resetArea();
                            linkStartX = x + cmd.x;
                        }
                    }
                    else if (!lineClipped) {
                        if (bfont) {
                            let tx = 0;
                            let str = cmd.wt.text;
                            let color = bfont.tint ? cmd.style.color : "#FFFFFF";
                            let scale = Math.floor((bfont.autoScaleSize ? cmd.style.fontSize : bfont.fontSize) * this._fontSizeScale) / bfont.fontSize;
                            for (let i = 0, n = str.length; i < n; i++) {
                                let c = str.charCodeAt(i);
                                let g = bfont.dict[c];
                                if (g) {
                                    if (g.texture)
                                        graphics.drawImage(g.texture, x + cmd.x + tx + g.x * scale, y + cmd.y + g.y * scale, g.width * scale, g.height * scale, color);
                                    tx += Math.round(g.advance * scale);
                                }
                            }
                        }
                        else {
                            if (cmd.style.stroke)
                                graphics.fillBorderText(cmd.wt, x + cmd.x, y + cmd.y, cmd.ctxFont, cmd.style.color, null, cmd.style.stroke, cmd.style.strokeColor);
                            else
                                graphics.fillText(cmd.wt, x + cmd.x, y + cmd.y, cmd.ctxFont, cmd.style.color, null);
                        }
                    }
                    if (!lineClipped && cmd.width > 0) {
                        if (cmd.style.underline) {
                            let thickness = Math.max(1, cmd.fontSize / 16);
                            graphics.drawLine(x + cmd.x, y + line.height - thickness, x + cmd.x + cmd.width, y + line.height - thickness, cmd.style.underlineColor || cmd.style.color, thickness);
                        }
                        if (cmd.style.strikethrough) {
                            let thickness = Math.max(1, cmd.fontSize / 16);
                            let stx = x + cmd.x;
                            let sty = (y + line.height / 2 - thickness) | 0;
                            let ext = 4;
                            graphics.drawLine(stx - ext, sty, stx + cmd.width + ext, sty, cmd.style.strikethroughColor || cmd.style.color, thickness);
                        }
                    }
                    cmd = cmd.next;
                }
                if (curLink) {
                    curLink.addRect(linkStartX, y, rectWidth - linkStartX + paddingLeft, line.height);
                    linkStartX = paddingLeft;
                }
            }
            if (clipped)
                graphics.restore();
        }
        drawBg() {
            let cmd = this._bgDrawCmd;
            if (this._bgColor || this._borderColor) {
                if (!cmd) {
                    cmd = new DrawRectCmd();
                    cmd.x = cmd.y = 0;
                    cmd.width = cmd.height = 1;
                    cmd.percent = true;
                    this._bgDrawCmd = cmd;
                }
                cmd.fillColor = this._bgColor;
                cmd.lineColor = this._borderColor;
                cmd.lineWidth = this._borderColor ? 1 : 0;
                let cmds = this.graphics.cmds;
                let i = cmds.indexOf(cmd);
                if (i != 0) {
                    if (i != -1)
                        cmds.splice(i, 1);
                    cmds.unshift(cmd);
                    this.graphics.cmds = cmds;
                }
            }
            else if (cmd) {
                this.graphics.removeCmd(cmd);
            }
        }
    }
    Text.VISIBLE = "visible";
    Text.SCROLL = "scroll";
    Text.HIDDEN = "hidden";
    Text.SHRINK = "shrink";
    Text.ELLIPSIS = "ellipsis";
    Text.RightToLeft = false;
    Text._testWord = "游";
    Text._passwordChar = "●";
    Text._bitmapFonts = {};
    const cmdPool = [];
    const linePool = [];
    function recoverLines(lines, releaseObjs) {
        for (let line of lines) {
            let cmd = line.cmd;
            while (cmd) {
                cleanCmd(cmd, releaseObjs);
                cmdPool.push(cmd);
                cmd = cmd.next;
            }
            line.cmd = null;
        }
        linePool.push(...lines);
        lines.length = 0;
    }
    function cleanCmd(cmd, releaseObj) {
        if (cmd.obj) {
            if (releaseObj) {
                cmd.obj.element.obj = null;
                cmd.obj.release();
                Pool.recoverByClass(cmd.obj);
            }
            cmd.obj = null;
        }
        else if (cmd.wt)
            cmd.wt.cleanCache();
    }
    const emojiTest = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
    const wordBoundaryTest = /[a-zA-Z0-9\!-\+\/_]+$/;
    const punctuationChars = Array.from(".,，。、!！；;”’)）]】}》").map(char => char.charCodeAt(0));
    const normalizeCR = /\r\n/g;
    const escapeCharsPattern = /\\(\w)/g;
    const escapeSequence = { "\\n": "\n", "\\t": "\t" };
    const ellipsisStr = "…";
    const maxWordLength = 20;
    function getReplaceStr(word) {
        return escapeSequence[word];
    }
    function isHighSurrogate(c) {
        return c >= 0xD800 && c <= 0xDBFF;
    }
    function isLowSurrogate(c) {
        return c >= 0xDC00 && c <= 0xDFFF;
    }

    var _isFirstTouch = true;
    const _tempPoint = new Point();
    const _tempRect = new Rectangle();
    const _rollOverChain = [];
    const _rollOutChain = [];
    var _inst;
    class InputManager {
        constructor() {
            this._lastTouchId = 0;
            this._touches = [];
            this._touchPool = [];
            this._mouseTouch = new TouchInfo(this._touches);
            this._pressKeys = new Set();
            this._keyEvent = new Event();
            this._keyEvent._touches = this._touches;
        }
        static get inst() {
            return _inst;
        }
        static getTouchPos(touchId) {
            var _a;
            if (touchId == null)
                touchId = _inst._lastTouchId;
            return ((_a = _inst.getTouch(touchId)) === null || _a === void 0 ? void 0 : _a.pos) || _inst._mouseTouch.pos;
        }
        static get touchTarget() {
            return _inst._touchTarget;
        }
        static get touches() {
            return _inst._touches;
        }
        static get touchCount() {
            return _inst._touches.length;
        }
        static cancelClick(touchId) {
            if (touchId == null)
                touchId = _inst._lastTouchId;
            let touch = _inst.getTouch(touchId);
            if (touch)
                touch.clickCancelled = true;
        }
        static hasKeyDown(key) {
            return _inst._pressKeys.has(key);
        }
        static __init__(stage, canvas) {
            let inst = _inst = new InputManager();
            inst._stage = stage;
            canvas.oncontextmenu = () => {
                return false;
            };
            canvas.addEventListener("mousedown", ev => {
                if (!Browser.onIE)
                    (ev.cancelable) && (ev.preventDefault());
                inst.handleMouse(ev, 0);
            }, { passive: false });
            canvas.addEventListener("mouseup", ev => {
                (ev.cancelable) && (ev.preventDefault());
                inst.handleMouse(ev, 1);
            }, { passive: false });
            canvas.addEventListener("mousemove", ev => {
                (ev.cancelable) && (ev.preventDefault());
                inst.handleMouse(ev, 2);
            }, { passive: false });
            canvas.addEventListener("mouseout", ev => {
                inst.handleMouse(ev, 3);
            }, { passive: false });
            canvas.addEventListener("touchstart", ev => {
                if (!_isFirstTouch && !InputManager.isTextInputting)
                    (ev.cancelable) && (ev.preventDefault());
                inst.handleTouch(ev, 0);
            }, { passive: false });
            canvas.addEventListener("touchend", ev => {
                if (!_isFirstTouch && !InputManager.isTextInputting)
                    (ev.cancelable) && (ev.preventDefault());
                _isFirstTouch = false;
                inst.handleTouch(ev, 1);
            }, { passive: false });
            canvas.addEventListener("touchmove", ev => {
                (ev.cancelable) && (ev.preventDefault());
                inst.handleTouch(ev, 2);
            }, { passive: false });
            canvas.addEventListener("touchcancel", ev => {
                (ev.cancelable) && (ev.preventDefault());
                inst.handleTouch(ev, 3);
            }, { passive: false });
            canvas.addEventListener("wheel", ev => {
                inst.handleMouse(ev, 4);
            }, { passive: false });
            canvas.addEventListener("pointerdown", ev => {
                canvas.setPointerCapture(ev.pointerId);
            });
            canvas.addEventListener("pointerup", ev => {
                canvas.releasePointerCapture(ev.pointerId);
            }, true);
            let document = Browser.document;
            document.addEventListener("keydown", ev => {
                inst.handleKeys(ev);
            }, true);
            document.addEventListener("keypress", ev => {
                inst.handleKeys(ev);
            }, true);
            document.addEventListener("keyup", ev => {
                inst.handleKeys(ev);
            }, true);
        }
        handleMouse(ev, type) {
            var _a, _b, _c, _d, _e;
            this._eventType = type;
            this._nativeEvent = ev;
            this._lastTouchId = 0;
            let now = Browser.now();
            if (this._lastTouchTime != null && now - this._lastTouchTime < 100)
                return;
            let touch = this._mouseTouch;
            _tempPoint.setTo(ev.pageX || ev.clientX, ev.pageY || ev.clientY);
            if (this._stage._canvasTransform)
                this._stage._canvasTransform.invertTransformPoint(_tempPoint);
            InputManager.mouseX = _tempPoint.x;
            InputManager.mouseY = _tempPoint.y;
            let x = _tempPoint.x / this._stage.clientScaleX;
            let y = _tempPoint.y / this._stage.clientScaleY;
            touch.event.nativeEvent = ev;
            if (type == 3 || !InputManager.mouseEventsEnabled)
                touch.target = this._touchTarget = null;
            else {
                touch.target = this._touchTarget = this.getNodeUnderPoint(x, y);
                let ix = Math.round(x);
                let iy = Math.round(y);
                if (ix != touch.pos.x || iy != touch.pos.y) {
                    this._stage._mouseMoveTime = now;
                    touch.pos.setTo(ix, iy);
                    touch.move();
                    if (InputManager.mouseEventsEnabled) {
                        touch.target.bubbleEvent(Event.MOUSE_MOVE, touch.event);
                        for (let t of touch.downTargets)
                            t.event(Event.MOUSE_DRAG, touch.event);
                    }
                }
            }
            if (touch.lastRollOver != touch.target)
                this.handleRollOver(touch);
            if (type == 0) {
                if (!touch.began) {
                    touch.begin();
                    this._touches[0] = touch;
                    touch.event.button = ev.button;
                    touch.downButton = ev.button;
                    if (InputManager.mouseEventsEnabled) {
                        this.handleFocus();
                        if (ev.button == 0)
                            (_a = touch.target) === null || _a === void 0 ? void 0 : _a.bubbleEvent(Event.MOUSE_DOWN, touch.event);
                        else
                            (_b = touch.target) === null || _b === void 0 ? void 0 : _b.bubbleEvent(Event.RIGHT_MOUSE_DOWN, touch.event);
                    }
                }
            }
            else if (type == 1) {
                if (touch.began && ev.button == touch.downButton) {
                    touch.end();
                    this._touches.length = 0;
                    touch.event.button = ev.button;
                    if (InputManager.mouseEventsEnabled) {
                        if (ev.button == 0)
                            (_c = touch.target) === null || _c === void 0 ? void 0 : _c.bubbleEvent(Event.MOUSE_UP, touch.event);
                        else
                            (_d = touch.target) === null || _d === void 0 ? void 0 : _d.bubbleEvent(Event.RIGHT_MOUSE_UP, touch.event);
                        if (touch.moved) {
                            for (let t of touch.downTargets)
                                t.event(Event.MOUSE_DRAG_END, touch.event);
                        }
                        let clickTarget = touch.clickTest();
                        if (clickTarget) {
                            if (ev.button == 0) {
                                touch.event.isDblClick = touch.clickCount == 2;
                                clickTarget.bubbleEvent(Event.CLICK, touch.event);
                                if (touch.clickCount == 2)
                                    clickTarget.bubbleEvent(Event.DOUBLE_CLICK, touch.event);
                                touch.event.isDblClick = false;
                            }
                            else {
                                touch.event.isDblClick = touch.clickCount == 2;
                                clickTarget.bubbleEvent(Event.RIGHT_CLICK, touch.event);
                                touch.event.isDblClick = false;
                            }
                        }
                    }
                    touch.event.button = 0;
                }
            }
            else if (type == 4) {
                if (InputManager.mouseEventsEnabled) {
                    touch.event.delta = ev.deltaY * 0.025;
                    (_e = touch.target) === null || _e === void 0 ? void 0 : _e.bubbleEvent(Event.MOUSE_WHEEL, touch.event);
                    touch.event.delta = 0;
                }
            }
        }
        handleTouch(ev, type) {
            var _a, _b;
            this._eventType = type;
            this._nativeEvent = ev;
            this._lastTouchTime = Browser.now();
            let touches = ev.changedTouches;
            for (let i = 0; i < touches.length; ++i) {
                let uTouch = touches[i];
                if (!InputManager.multiTouchEnabled
                    && this._touches.length > 0
                    && this._touches[0].touchId != uTouch.identifier)
                    continue;
                _tempPoint.setTo(uTouch.pageX, uTouch.pageY);
                if (this._stage._canvasTransform)
                    this._stage._canvasTransform.invertTransformPoint(_tempPoint);
                InputManager.mouseX = _tempPoint.x;
                InputManager.mouseY = _tempPoint.y;
                let x = _tempPoint.x / this._stage.clientScaleX;
                let y = _tempPoint.y / this._stage.clientScaleY;
                let touch = this.getTouch(uTouch.identifier, type == 0);
                if (!touch)
                    continue;
                touch.event.nativeEvent = ev;
                touch.event.touchId = touch.touchId;
                this._lastTouchId = touch.touchId;
                if (type == 3 || !InputManager.mouseEventsEnabled)
                    touch.target = this._touchTarget = null;
                else {
                    touch.target = this._touchTarget = this.getNodeUnderPoint(x, y);
                    this._stage._mouseMoveTime = this._lastTouchTime;
                    let ix = Math.round(x);
                    let iy = Math.round(y);
                    if (Math.abs(ix - touch.pos.x) > 1.5 || Math.abs(iy - touch.pos.y) > 1.5) {
                        touch.pos.setTo(ix, iy);
                        if (type == 2) {
                            touch.move();
                            if (InputManager.mouseEventsEnabled) {
                                touch.target.bubbleEvent(Event.MOUSE_MOVE, touch.event);
                                for (let t of touch.downTargets)
                                    t.event(Event.MOUSE_DRAG, touch.event);
                            }
                        }
                    }
                }
                if (touch.lastRollOver != touch.target)
                    this.handleRollOver(touch);
                if (type == 0) {
                    if (!touch.began) {
                        touch.begin();
                        if (InputManager.mouseEventsEnabled) {
                            this.handleFocus();
                            (_a = touch.target) === null || _a === void 0 ? void 0 : _a.bubbleEvent(Event.MOUSE_DOWN, touch.event);
                        }
                    }
                }
                else if (type == 1 || type == 3) {
                    if (touch.began) {
                        touch.end();
                        if (InputManager.mouseEventsEnabled) {
                            (_b = touch.target) === null || _b === void 0 ? void 0 : _b.bubbleEvent(Event.MOUSE_UP, touch.event);
                            if (touch.moved) {
                                for (let t of touch.downTargets)
                                    t.event(Event.MOUSE_DRAG_END, touch.event);
                            }
                            if (type != 3) {
                                let clickTarget = touch.clickTest();
                                if (clickTarget != null) {
                                    touch.event.isDblClick = touch.clickCount == 2;
                                    clickTarget.bubbleEvent(Event.CLICK, touch.event);
                                    if (touch.clickCount == 2)
                                        clickTarget.bubbleEvent(Event.DOUBLE_CLICK, touch.event);
                                    touch.event.isDblClick = false;
                                }
                            }
                        }
                        touch.target = null;
                        this.handleRollOver(touch);
                    }
                    touch.reset();
                    this._touches.splice(this._touches.indexOf(touch), 1);
                    this._touchPool.push(touch);
                }
            }
        }
        getTouch(touchId, shouldCreate) {
            let touch = this._touches.find(e => e.touchId == touchId);
            if (touch || !shouldCreate)
                return touch;
            touch = this._touchPool.length > 0 ? this._touchPool.pop() : new TouchInfo(this._touches);
            touch.touchId = touchId;
            this._touches.push(touch);
            return touch;
        }
        handleFocus() {
            if (InputManager.isTextInputting
                && this._stage.focus && this._stage.focus["focus"]
                && !this._stage.focus.contains(this._touchTarget)) {
                let pre_input = this._stage.focus['_tf'] || this._stage.focus;
                let new_input = this._touchTarget['_tf'] || this._touchTarget;
                if (new_input.nativeInput && new_input.multiline == pre_input.multiline)
                    pre_input['_focusOut']();
                else
                    pre_input.focus = false;
            }
        }
        handleKeys(ev) {
            let type = ev.type;
            let keyCode = ev.keyCode;
            if (type === "keydown") {
                if (keyCode != 0)
                    this._pressKeys.add(keyCode);
                this._pressKeys.add(ev.key);
            }
            else if (type === "keyup") {
                if (keyCode != 0)
                    this._pressKeys.delete(keyCode);
                this._pressKeys.delete(ev.key);
            }
            this._keyEvent.nativeEvent = ev;
            if (InputManager.keyEventsEnabled) {
                let target = (this._stage.focus && (this._stage.focus.event != null) && this._stage.focus.displayedInStage) ? this._stage.focus : this._stage;
                let ct = target;
                while (ct) {
                    ct.event(type, this._keyEvent.setTo(type, ct, target));
                    ct = ct._parent;
                }
            }
            this._keyEvent.nativeEvent = null;
        }
        getNodeUnderPoint(x, y) {
            let target = this.getSpriteUnderPoint(this._stage, x, y);
            if (!target)
                target = this.getSprite3DUnderPoint(x, y);
            return target || this._stage;
        }
        getSpriteUnderPoint(sp, x, y) {
            let scrollRect = sp._style.scrollRect;
            if (scrollRect && !sp._getBit(NodeFlags.DISABLE_INNER_CLIPPING)) {
                _tempRect.setTo(scrollRect.x, scrollRect.y, scrollRect.width, scrollRect.height);
                if (!_tempRect.contains(x, y))
                    return null;
            }
            let editing = sp._getBit(NodeFlags.EDITING_NODE);
            if (!editing && sp.hitTestPrior && !sp.mouseThrough && sp != this._stage && !this.hitTest(sp, x, y))
                return null;
            for (let i = sp._children.length - 1; i > -1; i--) {
                let child = sp._children[i];
                let childEditing = editing || child._getBit(NodeFlags.EDITING_NODE);
                if (!child._destroyed
                    && (childEditing ? ((!child.hasHideFlag(HideFlags.HideInHierarchy) || child.mouseThrough) && !child._getBit(NodeFlags.HIDE_BY_EDITOR)) : child._mouseState > 1)
                    && (child._visible || child._getBit(NodeFlags.DISABLE_VISIBILITY))) {
                    _tempPoint.setTo(x, y);
                    child.fromParentPoint(_tempPoint);
                    let ret = this.getSpriteUnderPoint(child, _tempPoint.x, _tempPoint.y);
                    if (ret)
                        return ret;
                }
            }
            if (editing) {
                if (!sp._getBit(NodeFlags.LOCK_BY_EDITOR)
                    && !sp.hasHideFlag(HideFlags.HideInHierarchy)
                    && this.hitTest(sp, x, y, editing))
                    return sp;
            }
            else if (sp != this._stage) {
                if (sp.hitTestPrior && !sp.mouseThrough || this.hitTest(sp, x, y))
                    return sp;
            }
            return null;
        }
        getSprite3DUnderPoint(x, y) {
            return null;
        }
        hitTest(sp, x, y, editing) {
            let isHit = false;
            if (sp.scrollRect) {
                x -= sp._style.scrollRect.x;
                y -= sp._style.scrollRect.y;
            }
            let hitArea = sp._style.hitArea;
            let mouseThrough = sp.mouseThrough;
            if (editing) {
                hitArea = null;
                mouseThrough = false;
            }
            if (hitArea) {
                return hitArea.contains(x, y, sp);
            }
            if (sp.width > 0 && sp.height > 0 || mouseThrough || hitArea) {
                if (!mouseThrough)
                    isHit = (hitArea ? hitArea : _tempRect.setTo(0, 0, sp.width, sp.height)).contains(x, y, sp);
                else
                    isHit = sp.getGraphicBounds().contains(x, y);
            }
            return isHit;
        }
        handleRollOver(touch) {
            if (!InputManager.mouseEventsEnabled) {
                touch.lastRollOver = touch.target;
                return;
            }
            _rollOverChain.length = 0;
            _rollOutChain.length = 0;
            let ele = touch.lastRollOver;
            while (ele) {
                _rollOutChain.push(ele);
                ele = ele._parent;
            }
            touch.lastRollOver = touch.target;
            ele = touch.target;
            while (ele) {
                let i = _rollOutChain.indexOf(ele);
                if (i != -1) {
                    _rollOutChain.splice(i, _rollOutChain.length - i);
                    break;
                }
                _rollOverChain.push(ele);
                ele = ele._parent;
            }
            let cnt = _rollOutChain.length;
            if (cnt > 0) {
                for (let i = 0; i < cnt; i++) {
                    ele = _rollOutChain[i];
                    if (!ele._destroyed)
                        ele.event(Event.MOUSE_OUT, touch.event.setTo(Event.MOUSE_OUT, ele, ele));
                }
                _rollOutChain.length = 0;
            }
            cnt = _rollOverChain.length;
            if (cnt > 0) {
                for (let i = 0; i < cnt; i++) {
                    ele = _rollOverChain[i];
                    if (ele.activeInHierarchy)
                        ele.event(Event.MOUSE_OVER, touch.event.setTo(Event.MOUSE_OVER, ele, ele));
                }
                _rollOverChain.length = 0;
            }
        }
    }
    InputManager.multiTouchEnabled = true;
    InputManager.mouseEventsEnabled = true;
    InputManager.keyEventsEnabled = true;
    InputManager.clickTestThreshold = 10;
    InputManager.mouseX = 0;
    InputManager.mouseY = 0;
    InputManager.isTextInputting = false;
    InputManager.isiOSWKwebView = false;
    const clickTrack = {};
    class TouchInfo {
        constructor(touches) {
            this.downPos = new Point();
            this.downTargets = [];
            this.event = new Event();
            this.event._touches = touches;
            this.pos = this.event.touchPos;
            this.touchId = 0;
            this.reset();
        }
        begin() {
            this.began = true;
            this.clickCancelled = false;
            this.moved = false;
            this.downPos.copy(this.pos);
            this.downTargets.length = 0;
            if (this.target) {
                let ele = this.target;
                while (ele) {
                    this.downTargets.push(ele);
                    ele = ele._parent;
                }
            }
        }
        move() {
            this.moved = true;
            if (Math.abs(this.pos.x - this.downPos.x) > InputManager.clickTestThreshold
                || Math.abs(this.pos.y - this.downPos.y) > InputManager.clickTestThreshold)
                this.clickCancelled = true;
        }
        end() {
            this.began = false;
            let now = performance.now();
            let lastClick = clickTrack[this.touchId];
            if (!lastClick) {
                lastClick = { pos: new Point(), time: 0, button: 0 };
                clickTrack[this.touchId] = lastClick;
            }
            if (this.downTargets.length == 0
                || this.clickCancelled
                || Math.abs(this.pos.x - this.downPos.x) > InputManager.clickTestThreshold
                || Math.abs(this.pos.y - this.downPos.y) > InputManager.clickTestThreshold) {
                this.clickCancelled = true;
                lastClick.time = 0;
                this.clickCount = 1;
            }
            else {
                if (now - lastClick.time < 350
                    && Math.abs(this.pos.x - lastClick.pos.x) < InputManager.clickTestThreshold
                    && Math.abs(this.pos.y - lastClick.pos.y) < InputManager.clickTestThreshold
                    && lastClick.button == this.event.button) {
                    this.clickCount = 2;
                }
                else
                    this.clickCount = 1;
                lastClick.time = now;
                lastClick.pos.copy(this.pos);
                lastClick.button = this.event.button;
            }
        }
        clickTest() {
            if (this.clickCancelled) {
                this.downTargets.length = 0;
                return null;
            }
            let obj = this.downTargets[0];
            if (obj.activeInHierarchy) {
                this.downTargets.length = 0;
                return obj;
            }
            obj = this.target;
            while (obj) {
                let i = this.downTargets.indexOf(obj);
                if (i != -1 && obj.activeInHierarchy)
                    break;
                obj = obj._parent;
            }
            this.downTargets.length = 0;
            return obj;
        }
        reset() {
            this.pos.setTo(0, 0);
            this.touchId = 0;
            this.clickCount = 0;
            this.began = false;
            this.moved = false;
            this.target = null;
            this.downTargets.length = 0;
            this.lastRollOver = null;
            this.clickCancelled = false;
            this.downButton = 0;
        }
    }

    class Timer {
        constructor(autoActive = true) {
            this.scale = 1;
            this.currFrame = 0;
            this._delta = 0;
            this._map = {};
            this._handlers = [];
            this._temp = [];
            this._count = 0;
            autoActive && Timer.gSysTimer && Timer.gSysTimer.frameLoop(1, this, this._update);
            this.currTimer = this._getNowData();
            this._lastTimer = this._getNowData();
        }
        get delta() {
            return this._delta;
        }
        _update() {
            if (this.scale <= 0) {
                this._lastTimer = this._getNowData();
                this._delta = 0;
                return;
            }
            var frame = this.currFrame = this.currFrame + this.scale;
            var now = this._getNowData();
            var awake = (now - this._lastTimer) > 30000;
            this._delta = (now - this._lastTimer) * this.scale;
            var timer = this.currTimer = this.currTimer + this._delta;
            this._lastTimer = now;
            var handlers = this._handlers;
            this._count = 0;
            for (var i = 0, n = handlers.length; i < n; i++) {
                var handler = handlers[i];
                if (handler.method !== null) {
                    var t = handler.userFrame ? frame : timer;
                    if (t >= handler.exeTime) {
                        if (handler.repeat) {
                            if (!handler.jumpFrame || awake) {
                                handler.exeTime += handler.delay;
                                handler.run(false);
                                if (t > handler.exeTime) {
                                    handler.exeTime += Math.ceil((t - handler.exeTime) / handler.delay) * handler.delay;
                                }
                            }
                            else {
                                while (t >= handler.exeTime) {
                                    handler.exeTime += handler.delay;
                                    handler.run(false);
                                }
                            }
                        }
                        else {
                            handler.run(true);
                        }
                    }
                }
                else {
                    this._count++;
                }
            }
            if (this._count > 30 || frame % 200 === 0)
                this._clearHandlers();
        }
        _clearHandlers() {
            var handlers = this._handlers;
            for (var i = 0, n = handlers.length; i < n; i++) {
                var handler = handlers[i];
                if (handler.method !== null)
                    this._temp.push(handler);
                else
                    this._recoverHandler(handler);
            }
            this._handlers = this._temp;
            handlers.length = 0;
            this._temp = handlers;
        }
        _recoverHandler(handler) {
            if (this._map[handler.key] == handler)
                delete this._map[handler.key];
            handler.clear();
            Timer._pool.push(handler);
        }
        _getNowData() {
            return Date.now();
        }
        _create(useFrame, repeat, delay, caller, method, args, coverBefore) {
            if (!delay) {
                method.apply(caller, args);
                return null;
            }
            if (coverBefore) {
                var handler = this._getHandler(caller, method);
                if (handler) {
                    handler.repeat = repeat;
                    handler.userFrame = useFrame;
                    handler.delay = delay;
                    handler.caller = caller;
                    handler.method = method;
                    handler.args = args;
                    handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + this._getNowData() - this._lastTimer);
                    return handler;
                }
            }
            handler = Timer._pool.length > 0 ? Timer._pool.pop() : new TimerHandler();
            handler.repeat = repeat;
            handler.userFrame = useFrame;
            handler.delay = delay;
            handler.caller = caller;
            handler.method = method;
            handler.args = args;
            handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + this._getNowData() - this._lastTimer);
            this._indexHandler(handler);
            this._handlers.push(handler);
            return handler;
        }
        _indexHandler(handler) {
            var caller = handler.caller;
            var method = handler.method;
            var cid = caller ? caller.$_GID || (caller.$_GID = Utils.getGID()) : 0;
            var mid = method.$_TID || (method.$_TID = Timer._mid++);
            handler.key = cid + "_" + mid;
            this._map[handler.key] = handler;
        }
        once(delay, caller, method, args = null, coverBefore = true) {
            this._create(false, false, delay, caller, method, args, coverBefore);
        }
        loop(delay, caller, method, args = null, coverBefore = true, jumpFrame = false) {
            var handler = this._create(false, true, delay, caller, method, args, coverBefore);
            if (handler)
                handler.jumpFrame = jumpFrame;
        }
        frameOnce(delay, caller, method, args = null, coverBefore = true) {
            this._create(true, false, delay, caller, method, args, coverBefore);
        }
        frameLoop(delay, caller, method, args = null, coverBefore = true) {
            this._create(true, true, delay, caller, method, args, coverBefore);
        }
        toString() {
            return " handlers:" + this._handlers.length + " pool:" + Timer._pool.length;
        }
        clear(caller, method) {
            var handler = this._getHandler(caller, method);
            if (handler) {
                handler.clear();
            }
        }
        clearAll(caller) {
            if (!caller)
                return;
            for (var i = 0, n = this._handlers.length; i < n; i++) {
                var handler = this._handlers[i];
                if (handler.caller === caller) {
                    handler.clear();
                }
            }
        }
        _getHandler(caller, method) {
            var cid = caller ? caller.$_GID || (caller.$_GID = Utils.getGID()) : 0;
            var mid = method.$_TID || (method.$_TID = Timer._mid++);
            var key = cid + "_" + mid;
            return this._map[key];
        }
        callLater(caller, method, args = null) {
            CallLater.I.callLater(caller, method, args);
        }
        runCallLater(caller, method) {
            CallLater.I.runCallLater(caller, method);
        }
        clearCallLater(caller, method) {
            CallLater.I.clear(caller, method);
        }
        runTimer(caller, method) {
            var handler = this._getHandler(caller, method);
            if (handler && handler.method != null) {
                this._map[handler.key] = null;
                handler.run(true);
            }
        }
        pause() {
            this.scale = 0;
        }
        resume() {
            this.scale = 1;
        }
        destroy() {
            for (var i = 0, n = this._handlers.length; i < n; i++) {
                var handler = this._handlers[i];
                handler.clear();
            }
            this._handlers.length = 0;
            this._map = {};
            this._temp.length = 0;
        }
    }
    Timer.gSysTimer = null;
    Timer._pool = [];
    Timer._mid = 1;
    class TimerHandler {
        clear() {
            this.caller = null;
            this.method = null;
            this.args = null;
        }
        run(withClear) {
            var caller = this.caller;
            if (caller && caller.destroyed)
                return this.clear();
            var method = this.method;
            var args = this.args;
            withClear && this.clear();
            if (method == null)
                return;
            args ? method.apply(caller, args) : method.call(caller);
        }
    }

    class CallLater {
        constructor() {
            this._pool = [];
            this._map = {};
            this._laters = [];
        }
        _update() {
            let laters = this._laters;
            let len = laters.length;
            if (len > 0) {
                for (let i = 0, n = len - 1; i <= n; i++) {
                    let handler = laters[i];
                    delete this._map[handler.key];
                    if (handler.method !== null) {
                        handler.run();
                        handler.clear();
                    }
                    this._pool.push(handler);
                    i === n && (n = laters.length - 1);
                }
                laters.length = 0;
            }
        }
        _getHandler(caller, method) {
            var cid = caller ? caller.$_GID || (caller.$_GID = Utils.getGID()) : 0;
            var mid = method.$_TID || (method.$_TID = (Timer._mid++));
            return this._map[cid + '.' + mid];
        }
        callLater(caller, method, args = null) {
            if (this._getHandler(caller, method) == null) {
                let handler;
                if (this._pool.length)
                    handler = this._pool.pop();
                else
                    handler = new LaterHandler();
                handler.caller = caller;
                handler.method = method;
                handler.args = args;
                var cid = caller ? caller.$_GID : 0;
                var mid = method["$_TID"];
                handler.key = cid + '.' + mid;
                this._map[handler.key] = handler;
                this._laters.push(handler);
            }
        }
        runCallLater(caller, method) {
            var handler = this._getHandler(caller, method);
            if (handler && handler.method != null) {
                delete this._map[handler.key];
                handler.run();
                handler.clear();
            }
        }
        clear(caller, method) {
            var handler = this._getHandler(caller, method);
            if (handler) {
                delete this._map[handler.key];
                handler.key = "";
                handler.clear();
                return true;
            }
            return false;
        }
        clearAll(caller) {
            if (!caller)
                return;
            for (var i = 0, n = this._laters.length; i < n; i++) {
                var handler = this._laters[i];
                if (handler.caller === caller) {
                    delete this._map[handler.key];
                    handler.key = "";
                    handler.clear();
                }
            }
        }
    }
    CallLater.I = new CallLater();
    class LaterHandler {
        clear() {
            this.caller = null;
            this.method = null;
            this.args = null;
        }
        run() {
            var caller = this.caller;
            if (caller && caller.destroyed)
                return this.clear();
            var method = this.method;
            var args = this.args;
            if (method == null)
                return;
            args ? method.apply(caller, args) : method.call(caller);
        }
    }

    class WebGL {
        static _nativeRender_enable() {
        }
        static enable() {
            return true;
        }
        static onStageResize(width, height) {
            RenderState2D.width = width;
            RenderState2D.height = height;
            LayaGL.renderEngine.resizeOffScreen(width, height);
        }
    }
    WebGL.isNativeRender_enable = false;

    class RunDriver {
    }
    RunDriver.changeWebGLSize = function (w, h) {
        WebGL.onStageResize(w, h);
    };

    class ComponentDriver {
        constructor() {
            this._onUpdates = new Set();
            this._onLateUpdates = new Set();
            this._onPreRenders = new Set();
            this._onPostRenders = new Set();
            this._toStarts = new Set();
            this._toDestroys = new Set();
        }
        callStart() {
            for (let ele of this._toStarts) {
                if (ele._status == 2) {
                    ele._status = 3;
                    try {
                        ele.onStart();
                    }
                    catch (err) {
                        this.onError(err);
                    }
                }
            }
            this._toStarts.clear();
        }
        callUpdate() {
            for (let ele of this._onUpdates) {
                if (ele._status == 3) {
                    try {
                        ele.onUpdate();
                    }
                    catch (err) {
                        this.onError(err);
                    }
                }
            }
        }
        callLateUpdate() {
            for (let ele of this._onLateUpdates) {
                if (ele._status == 3) {
                    try {
                        ele.onLateUpdate();
                    }
                    catch (err) {
                        this.onError(err);
                    }
                }
            }
        }
        callPreRender() {
            for (let ele of this._onPreRenders) {
                if (ele._status == 3) {
                    try {
                        ele.onPreRender();
                    }
                    catch (err) {
                        this.onError(err);
                    }
                }
            }
        }
        callPostRender() {
            for (let ele of this._onPostRenders) {
                if (ele._status == 3) {
                    try {
                        ele.onPostRender();
                    }
                    catch (err) {
                        this.onError(err);
                    }
                }
            }
        }
        callDestroy() {
            for (let ele of this._toDestroys) {
                try {
                    ele._destroy(true);
                }
                catch (err) {
                    this.onError(err);
                }
            }
            this._toDestroys.clear();
        }
        add(comp) {
            if (comp._status == 1) {
                if (comp.onStart) {
                    comp._status = 2;
                    this._toStarts.add(comp);
                }
                else
                    comp._status = 3;
            }
            if (comp.onUpdate)
                this._onUpdates.add(comp);
            if (comp.onLateUpdate)
                this._onLateUpdates.add(comp);
            if (comp.onPreRender)
                this._onPreRenders.add(comp);
            if (comp.onPostRender)
                this._onPostRenders.add(comp);
        }
        remove(comp) {
            if (comp._status == 2)
                comp._status = 1;
            if (comp.onUpdate)
                this._onUpdates.delete(comp);
            if (comp.onLateUpdate)
                this._onLateUpdates.delete(comp);
            if (comp.onPreRender)
                this._onPreRenders.delete(comp);
            if (comp.onPostRender)
                this._onPostRenders.delete(comp);
        }
        destroy() {
        }
        onError(err) {
            console.error(err);
        }
    }

    class Stage extends Sprite {
        constructor() {
            super();
            this.offset = new Point();
            this._frameRate = "fast";
            this.designWidth = 0;
            this.designHeight = 0;
            this.canvasRotation = false;
            this.canvasDegree = 0;
            this.renderingEnabled = true;
            this.screenAdaptationEnabled = true;
            this._canvasTransform = new Matrix();
            this._mouseMoveTime = 0;
            this._wgColor = new Color(0, 0, 0, 0);
            this._scene3Ds = [];
            this._screenMode = "none";
            this._scaleMode = "noscale";
            this._alignV = "top";
            this._alignH = "left";
            this._bgColor = "gray";
            this._renderCount = 0;
            this._safariOffsetY = 0;
            this._frameStartTime = 0;
            this._previousOrientation = Browser.window.orientation;
            this._globalRepaintSet = false;
            this._globalRepaintGet = false;
            this.useRetinalCanvas = false;
            this._needUpdateCanvasSize = false;
            super.set_transform(this._createTransform());
            this.mouseEnabled = true;
            this.hitTestPrior = true;
            this.autoSize = false;
            this._setBit(NodeFlags.DISPLAYED_INSTAGE, true);
            this._setBit(NodeFlags.ACTIVE_INHIERARCHY, true);
            this._isFocused = true;
            this._isVisibility = true;
            this.useRetinalCanvas = LayaEnv.isConch ? true : Config.useRetinalCanvas;
            var window = Browser.window;
            window.addEventListener("focus", () => {
                this._isFocused = true;
                this.event(Event.FOCUS);
                this.event(Event.FOCUS_CHANGE);
            });
            window.addEventListener("blur", () => {
                this._isFocused = false;
                this.event(Event.BLUR);
                this.event(Event.FOCUS_CHANGE);
                if (this._isInputting())
                    Input["inputElement"].target.focus = false;
            });
            var state = "visibilityState", visibilityChange = "visibilitychange";
            var document = window.document;
            if (typeof document.hidden !== "undefined") {
                visibilityChange = "visibilitychange";
                state = "visibilityState";
            }
            else if (typeof document.mozHidden !== "undefined") {
                visibilityChange = "mozvisibilitychange";
                state = "mozVisibilityState";
            }
            else if (typeof document.msHidden !== "undefined") {
                visibilityChange = "msvisibilitychange";
                state = "msVisibilityState";
            }
            else if (typeof document.webkitHidden !== "undefined") {
                visibilityChange = "webkitvisibilitychange";
                state = "webkitVisibilityState";
            }
            window.document.addEventListener(visibilityChange, () => {
                if (Browser.document[state] == "hidden") {
                    this._isVisibility = false;
                    if (this._isInputting())
                        Input["inputElement"].target.focus = false;
                }
                else {
                    this._isVisibility = true;
                }
                this.renderingEnabled = this._isVisibility;
                this.event(Event.VISIBILITY_CHANGE);
            });
            window.addEventListener("resize", () => {
                var orientation = Browser.window.orientation;
                if (orientation != null && orientation != this._previousOrientation && this._isInputting()) {
                    Input["inputElement"].target.focus = false;
                }
                this._previousOrientation = orientation;
                if (this._isInputting())
                    return;
                if (Browser.onSafari)
                    this._safariOffsetY = Browser.getSafariToolbarOffset();
                if (this.screenAdaptationEnabled) {
                    this.event(Event.WILL_RESIZE);
                    this.updateCanvasSize(true);
                }
            });
            window.addEventListener("orientationchange", (e) => {
                if (this.screenAdaptationEnabled) {
                    this.event(Event.WILL_RESIZE);
                    this.updateCanvasSize(true);
                }
            });
            this._componentDriver = new ComponentDriver();
        }
        _isInputting() {
            return (Browser.onMobile && InputManager.isTextInputting);
        }
        set_width(value) {
            this.designWidth = value;
            super.set_width(value);
            this.updateCanvasSize(true);
        }
        get_width() {
            this.needUpdateCanvasSize();
            return super.get_width();
        }
        set_height(value) {
            this.designHeight = value;
            super.set_height(value);
            this.updateCanvasSize(true);
        }
        get_height() {
            this.needUpdateCanvasSize();
            return super.get_height();
        }
        get transform() {
            if (this._tfChanged)
                this._adjustTransform();
            return (this._transform = this._transform || this._createTransform());
        }
        set transform(value) {
            super.set_transform(value);
        }
        get isFocused() {
            return this._isFocused;
        }
        get isVisibility() {
            return this._isVisibility;
        }
        updateCanvasSize(delay) {
            if (delay) {
                if (!this._needUpdateCanvasSize) {
                    this._needUpdateCanvasSize = true;
                    ILaya.systemTimer.callLater(this, this.updateCanvasSize);
                }
            }
            else {
                this.setScreenSize(Browser.clientWidth * Browser.pixelRatio, Browser.clientHeight * Browser.pixelRatio);
            }
        }
        needUpdateCanvasSize() {
            if (this._needUpdateCanvasSize)
                this.updateCanvasSize();
        }
        setScreenSize(screenWidth, screenHeight) {
            this._needUpdateCanvasSize = false;
            var rotation = false;
            if (this._screenMode !== Stage.SCREEN_NONE) {
                var screenType = screenWidth / screenHeight < 1 ? Stage.SCREEN_VERTICAL : Stage.SCREEN_HORIZONTAL;
                rotation = screenType !== this._screenMode;
                if (rotation) {
                    var temp = screenHeight;
                    screenHeight = screenWidth;
                    screenWidth = temp;
                }
            }
            this.canvasRotation = rotation;
            var canvas = Render._mainCanvas;
            var mat = this._canvasTransform.identity();
            var scaleMode = this._scaleMode;
            var scaleX = screenWidth / this.designWidth;
            var scaleY = screenHeight / this.designHeight;
            var canvasWidth = this.useRetinalCanvas ? screenWidth : this.designWidth;
            var canvasHeight = this.useRetinalCanvas ? screenHeight : this.designHeight;
            var realWidth = screenWidth;
            var realHeight = screenHeight;
            var pixelRatio = Browser.pixelRatio;
            this._width = this.designWidth;
            this._height = this.designHeight;
            switch (scaleMode) {
                case Stage.SCALE_NOSCALE:
                    scaleX = scaleY = 1;
                    realWidth = this.designWidth;
                    realHeight = this.designHeight;
                    break;
                case Stage.SCALE_SHOWALL:
                    scaleX = scaleY = Math.min(scaleX, scaleY);
                    realWidth = Math.round(this.designWidth * scaleX);
                    realHeight = Math.round(this.designHeight * scaleY);
                    break;
                case Stage.SCALE_NOBORDER:
                    scaleX = scaleY = Math.max(scaleX, scaleY);
                    realWidth = Math.round(this.designWidth * scaleX);
                    realHeight = Math.round(this.designHeight * scaleY);
                    break;
                case Stage.SCALE_FULL:
                    scaleX = scaleY = 1;
                    this._width = canvasWidth = screenWidth;
                    this._height = canvasHeight = screenHeight;
                    break;
                case Stage.SCALE_FULLSCREEN:
                    scaleX = scaleY = pixelRatio;
                    canvasWidth = screenWidth;
                    canvasHeight = screenHeight;
                    this._width = screenWidth / pixelRatio;
                    this._height = screenHeight / pixelRatio;
                    break;
                case Stage.SCALE_FIXED_WIDTH:
                    scaleY = scaleX;
                    this._height = canvasHeight = Math.round(screenHeight / scaleX);
                    break;
                case Stage.SCALE_FIXED_HEIGHT:
                    scaleX = scaleY;
                    this._width = canvasWidth = Math.round(screenWidth / scaleY);
                    break;
                case Stage.SCALE_FIXED_AUTO:
                    if ((screenWidth / screenHeight) < (this.designWidth / this.designHeight)) {
                        scaleY = scaleX;
                        this._height = canvasHeight = Math.round(screenHeight / scaleX);
                    }
                    else {
                        scaleX = scaleY;
                        this._width = canvasWidth = Math.round(screenWidth / scaleY);
                    }
                    break;
            }
            if (this.useRetinalCanvas) {
                if (scaleMode === Stage.SCALE_SHOWALL || scaleMode === Stage.SCALE_NOSCALE) {
                    canvasWidth = realWidth;
                    canvasHeight = realHeight;
                }
                else {
                    canvasWidth = realWidth = screenWidth;
                    canvasHeight = realHeight = screenHeight;
                }
            }
            scaleX *= this.scaleX;
            scaleY *= this.scaleY;
            if (scaleX === 1 && scaleY === 1) {
                this.transform.identity();
            }
            else {
                this.transform.a = this._formatData(scaleX / (realWidth / canvasWidth));
                this.transform.d = this._formatData(scaleY / (realHeight / canvasHeight));
            }
            canvas.size(canvasWidth, canvasHeight);
            RunDriver.changeWebGLSize(canvasWidth, canvasHeight);
            mat.scale(realWidth / canvasWidth / pixelRatio, realHeight / canvasHeight / pixelRatio);
            if (this._alignH === Stage.ALIGN_LEFT)
                this.offset.x = 0;
            else if (this._alignH === Stage.ALIGN_RIGHT)
                this.offset.x = screenWidth - realWidth;
            else
                this.offset.x = (screenWidth - realWidth) * 0.5 / pixelRatio;
            if (this._alignV === Stage.ALIGN_TOP)
                this.offset.y = 0;
            else if (this._alignV === Stage.ALIGN_BOTTOM)
                this.offset.y = screenHeight - realHeight;
            else
                this.offset.y = (screenHeight - realHeight) * 0.5 / pixelRatio;
            this.offset.x = Math.round(this.offset.x);
            this.offset.y = Math.round(this.offset.y);
            mat.translate(this.offset.x, this.offset.y);
            if (this._safariOffsetY)
                mat.translate(0, this._safariOffsetY);
            this.canvasDegree = 0;
            if (rotation) {
                if (this._screenMode === Stage.SCREEN_HORIZONTAL) {
                    mat.rotate(Math.PI / 2);
                    mat.translate(screenHeight / pixelRatio, 0);
                    this.canvasDegree = 90;
                }
                else {
                    mat.rotate(-Math.PI / 2);
                    mat.translate(0, screenWidth / pixelRatio);
                    this.canvasDegree = -90;
                }
            }
            mat.a = this._formatData(mat.a);
            mat.d = this._formatData(mat.d);
            mat.tx = this._formatData(mat.tx);
            mat.ty = this._formatData(mat.ty);
            super.set_transform(this.transform);
            Stage._setStageStyle(canvas, canvasWidth, canvasHeight, mat);
            if (this._safariOffsetY)
                mat.translate(0, -this._safariOffsetY);
            this.visible = true;
            this._repaint |= SpriteConst.REPAINT_CACHE;
            this.event(Event.RESIZE);
        }
        static _setStageStyle(mainCanv, canvasWidth, canvasHeight, mat) {
            var canvasStyle = mainCanv.source.style;
            canvasStyle.transformOrigin = canvasStyle.webkitTransformOrigin = canvasStyle.msTransformOrigin = canvasStyle.mozTransformOrigin = canvasStyle.oTransformOrigin = "0px 0px 0px";
            canvasStyle.transform = canvasStyle.webkitTransform = canvasStyle.msTransform = canvasStyle.mozTransform = canvasStyle.oTransform = "matrix(" + mat.toString() + ")";
            canvasStyle.width = canvasWidth;
            canvasStyle.height = canvasHeight;
            mat.translate(parseInt(canvasStyle.left) || 0, parseInt(canvasStyle.top) || 0);
        }
        setScreenSizeForScene(screenWidth, screenHeight, screenMode) {
            var rotation = false;
            if (screenMode !== Stage.SCREEN_NONE) {
                var screenType = screenWidth / screenHeight < 1 ? Stage.SCREEN_VERTICAL : Stage.SCREEN_HORIZONTAL;
                rotation = screenType !== screenMode;
                if (rotation) {
                    var temp = screenHeight;
                    screenHeight = screenWidth;
                    screenWidth = temp;
                }
            }
            this.canvasRotation = rotation;
            var scaleMode = this._scaleMode;
            var scaleX = screenWidth / this.designWidth;
            var scaleY = screenHeight / this.designHeight;
            var canvasWidth = this.useRetinalCanvas ? screenWidth : this.designWidth;
            var canvasHeight = this.useRetinalCanvas ? screenHeight : this.designHeight;
            var realWidth = screenWidth;
            var realHeight = screenHeight;
            let _width = this.designWidth;
            let _height = this.designHeight;
            switch (scaleMode) {
                case Stage.SCALE_NOSCALE:
                    scaleX = scaleY = 1;
                    realWidth = this.designWidth;
                    realHeight = this.designHeight;
                    break;
                case Stage.SCALE_SHOWALL:
                    scaleX = scaleY = Math.min(scaleX, scaleY);
                    realWidth = Math.round(this.designWidth * scaleX);
                    realHeight = Math.round(this.designHeight * scaleY);
                    break;
                case Stage.SCALE_NOBORDER:
                    scaleX = scaleY = Math.max(scaleX, scaleY);
                    realWidth = Math.round(this.designWidth * scaleX);
                    realHeight = Math.round(this.designHeight * scaleY);
                    break;
                case Stage.SCALE_FULL:
                    scaleX = scaleY = 1;
                    _width = canvasWidth = screenWidth;
                    _height = canvasHeight = screenHeight;
                    break;
                case Stage.SCALE_FIXED_WIDTH:
                    scaleY = scaleX;
                    _height = canvasHeight = Math.round(screenHeight / scaleX);
                    break;
                case Stage.SCALE_FIXED_HEIGHT:
                    scaleX = scaleY;
                    _width = canvasWidth = Math.round(screenWidth / scaleY);
                    break;
                case Stage.SCALE_FIXED_AUTO:
                    if ((screenWidth / screenHeight) < (this.designWidth / this.designHeight)) {
                        scaleY = scaleX;
                        _height = canvasHeight = Math.round(screenHeight / scaleX);
                    }
                    else {
                        scaleX = scaleY;
                        _width = canvasWidth = Math.round(screenWidth / scaleY);
                    }
                    break;
            }
            if (this.useRetinalCanvas) {
                if (scaleMode === Stage.SCALE_SHOWALL || scaleMode === Stage.SCALE_NOSCALE) {
                    canvasWidth = realWidth;
                    canvasHeight = realHeight;
                }
                else {
                    canvasWidth = realWidth = screenWidth;
                    canvasHeight = realHeight = screenHeight;
                }
            }
            return {
                stageWidth: _width,
                stageHeight: _height,
                canvasWidth: canvasWidth,
                canvasHeight: canvasHeight,
                scaleX: scaleX / (realWidth / canvasWidth),
                scaleY: scaleY / (realHeight / canvasHeight),
            };
        }
        _formatData(value) {
            if (Math.abs(value) < 0.000001)
                return 0;
            if (Math.abs(1 - value) < 0.001)
                return value > 0 ? 1 : -1;
            return value;
        }
        get scaleMode() {
            return this._scaleMode;
        }
        set scaleMode(value) {
            this._scaleMode = value;
            this.updateCanvasSize(true);
        }
        get alignH() {
            this.needUpdateCanvasSize();
            return this._alignH;
        }
        set alignH(value) {
            this._alignH = value;
            this.updateCanvasSize(true);
        }
        get alignV() {
            this.needUpdateCanvasSize();
            return this._alignV;
        }
        set alignV(value) {
            this._alignV = value;
            this.updateCanvasSize(true);
        }
        get bgColor() {
            return this._bgColor;
        }
        set bgColor(value) {
            this._bgColor = value;
            if (value) {
                let colorArr = ColorUtils.create(value).arrColor;
                this._wgColor.setValue(colorArr[0], colorArr[1], colorArr[2], colorArr[3]);
            }
            else
                this._wgColor = null;
            Stage._setStyleBgColor(value);
        }
        static _setStyleBgColor(value) {
            if (value) {
                Render.canvas.style.background = value;
            }
            else {
                Render.canvas.style.background = "none";
            }
        }
        get mouseX() {
            return Math.round(InputManager.mouseX / this.clientScaleX);
        }
        get mouseY() {
            return Math.round(InputManager.mouseY / this.clientScaleY);
        }
        getMousePoint() {
            return Point.TEMP.setTo(this.mouseX, this.mouseY);
        }
        get clientScaleX() {
            this.needUpdateCanvasSize();
            return this._transform ? this._transform.getScaleX() : 1;
        }
        get clientScaleY() {
            this.needUpdateCanvasSize();
            return this._transform ? this._transform.getScaleY() : 1;
        }
        get screenMode() {
            return this._screenMode;
        }
        set screenMode(value) {
            this._screenMode = value;
        }
        repaint(type = SpriteConst.REPAINT_CACHE) {
            this._repaint |= type;
        }
        parentRepaint(type = SpriteConst.REPAINT_CACHE) {
        }
        _loop() {
            this._globalRepaintGet = this._globalRepaintSet;
            this._globalRepaintSet = false;
            this.render(Render._context, 0, 0);
            return true;
        }
        getFrameTm() {
            return this._frameStartTime;
        }
        getTimeFromFrameStart() {
            return Browser.now() - this._frameStartTime;
        }
        get visible() {
            return super.visible;
        }
        set visible(value) {
            if (this.visible !== value) {
                super.set_visible(value);
                Stage._setVisibleStyle(value);
            }
        }
        static _setVisibleStyle(value) {
            var style = Render._mainCanvas.source.style;
            style.visibility = value ? "visible" : "hidden";
        }
        render(context2D, x, y) {
            if (this._frameRate === Stage.FRAME_SLEEP) {
                var now = Browser.now();
                if (now - this._frameStartTime < 1000)
                    return;
                this._frameStartTime = now;
            }
            else {
                if (!this._visible) {
                    this._renderCount++;
                    if (this._renderCount % 5 === 0) {
                        CallLater.I._update();
                        Stat.loopCount++;
                        RenderInfo.loopCount = Stat.loopCount;
                        this._runComponents();
                        this._updateTimers();
                    }
                    return;
                }
                this._frameStartTime = Browser.now();
                RenderInfo.loopStTm = this._frameStartTime;
            }
            this._renderCount++;
            var frameMode = this._frameRate === Stage.FRAME_MOUSE ? (((this._frameStartTime - this._mouseMoveTime) < 2000) ? Stage.FRAME_FAST : Stage.FRAME_SLOW) : this._frameRate;
            var isFastMode = (frameMode !== Stage.FRAME_SLOW);
            var isDoubleLoop = (this._renderCount % 2 === 0);
            Stat.renderSlow = !isFastMode;
            if (!isFastMode && !isDoubleLoop)
                return;
            CallLater.I._update();
            Stat.loopCount++;
            RenderInfo.loopCount = Stat.loopCount;
            if (this.renderingEnabled) {
                for (let i = 0, n = this._scene3Ds.length; i < n; i++)
                    this._scene3Ds[i]._update();
                this._runComponents();
                this._componentDriver.callPreRender();
                context2D.render2D.renderStart(!Config.preserveDrawingBuffer, this._wgColor);
                for (let i = 0, n = this._scene3Ds.length; i < n; i++)
                    this._scene3Ds[i].renderSubmit();
                this._render2d(context2D, x, y);
                this._componentDriver.callPostRender();
                VectorGraphManager.instance && VectorGraphManager.getInstance().endDispose();
            }
            else
                this._runComponents();
            this._updateTimers();
            LayaGL.renderEngine.endFrame();
        }
        _render2d(context2D, x, y) {
            Stat.draw2D = 0;
            context2D.startRender();
            super.render(context2D, x, y);
            Stat.render(context2D, x, y);
            context2D.endRender();
        }
        _runComponents() {
            this._componentDriver.callStart();
            this._componentDriver.callUpdate();
            this._componentDriver.callLateUpdate();
            this._componentDriver.callDestroy();
        }
        _updateTimers() {
            ILaya.systemTimer._update();
            ILaya.physicsTimer._update();
            ILaya.timer._update();
        }
        set fullScreenEnabled(value) {
            var document = Browser.document;
            var canvas = Render.canvas;
            if (value) {
                canvas.addEventListener('mousedown', requestFullscreen);
                canvas.addEventListener('touchstart', requestFullscreen);
                document.addEventListener("fullscreenchange", fullScreenChanged);
                document.addEventListener("mozfullscreenchange", fullScreenChanged);
                document.addEventListener("webkitfullscreenchange", fullScreenChanged);
                document.addEventListener("msfullscreenchange", fullScreenChanged);
            }
            else {
                canvas.removeEventListener('mousedown', requestFullscreen);
                canvas.removeEventListener('touchstart', requestFullscreen);
                document.removeEventListener("fullscreenchange", fullScreenChanged);
                document.removeEventListener("mozfullscreenchange", fullScreenChanged);
                document.removeEventListener("webkitfullscreenchange", fullScreenChanged);
                document.removeEventListener("msfullscreenchange", fullScreenChanged);
            }
        }
        exitFullscreen() {
            var document = Browser.document;
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
            else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            }
            else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            }
        }
        get frameRate() {
            return this._frameRate;
        }
        set frameRate(value) {
            this._frameRate = value;
        }
        isGlobalRepaint() {
            return this._globalRepaintGet;
        }
        setGlobalRepaint() {
            this._globalRepaintSet = true;
        }
    }
    Stage.SCALE_NOSCALE = "noscale";
    Stage.SCALE_SHOWALL = "showall";
    Stage.SCALE_NOBORDER = "noborder";
    Stage.SCALE_FULL = "full";
    Stage.SCALE_FULLSCREEN = "fullscreen";
    Stage.SCALE_FIXED_WIDTH = "fixedwidth";
    Stage.SCALE_FIXED_HEIGHT = "fixedheight";
    Stage.SCALE_FIXED_AUTO = "fixedauto";
    Stage.ALIGN_LEFT = "left";
    Stage.ALIGN_RIGHT = "right";
    Stage.ALIGN_CENTER = "center";
    Stage.ALIGN_TOP = "top";
    Stage.ALIGN_MIDDLE = "middle";
    Stage.ALIGN_BOTTOM = "bottom";
    Stage.SCREEN_NONE = "none";
    Stage.SCREEN_HORIZONTAL = "horizontal";
    Stage.SCREEN_VERTICAL = "vertical";
    Stage.FRAME_FAST = "fast";
    Stage.FRAME_SLOW = "slow";
    Stage.FRAME_MOUSE = "mouse";
    Stage.FRAME_SLEEP = "sleep";
    function requestFullscreen() {
        var element = Browser.document.documentElement;
        if (element.requestFullscreen) {
            element.requestFullscreen();
        }
        else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
        }
        else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen();
        }
        else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
        }
        var canvas = Render.canvas;
        canvas.removeEventListener('mousedown', requestFullscreen);
        canvas.removeEventListener('touchstart', requestFullscreen);
    }
    function fullScreenChanged() {
        ILaya.stage.event(Event.FULL_SCREEN_CHANGE);
    }

    class SoundChannel extends EventDispatcher {
        constructor() {
            super(...arguments);
            this.isStopped = false;
        }
        get volume() {
            return 1;
        }
        set volume(v) {
        }
        get position() {
            return 0;
        }
        get duration() {
            return 0;
        }
        play() {
        }
        stop() {
            if (this.completeHandler)
                this.completeHandler.runWith(false);
        }
        pause() {
        }
        resume() {
        }
        __runComplete(handler) {
            if (handler) {
                handler.runWith(true);
            }
        }
    }

    class AudioSoundChannel extends SoundChannel {
        constructor(audio) {
            super();
            this._audio = null;
            this._onEnd = this.__onEnd.bind(this);
            this._resumePlay = this.__resumePlay.bind(this);
            audio.addEventListener("ended", this._onEnd);
            this._audio = audio;
            this._src = audio.src;
        }
        __onEnd(evt) {
            if (this.loops == 1) {
                if (this.completeHandler) {
                    ILaya.systemTimer.once(10, this, this.__runComplete, [this.completeHandler], false);
                    this.completeHandler = null;
                }
                this.stop();
                this.event(Event.COMPLETE);
                return;
            }
            if (this.loops > 0) {
                this.loops--;
            }
            this.startTime = 0;
            this.play();
        }
        __resumePlay() {
            if (this._audio)
                this._audio.removeEventListener("canplay", this._resumePlay);
            if (this.isStopped)
                return;
            try {
                this._audio.currentTime = this.startTime;
                Browser.container.appendChild(this._audio);
                this._audio.play();
            }
            catch (e) {
                this.event(Event.ERROR);
            }
        }
        play() {
            this.isStopped = false;
            try {
                this._audio.playbackRate = SoundManager.playbackRate;
                this._audio.currentTime = this.startTime;
            }
            catch (e) {
                this._audio.addEventListener("canplay", this._resumePlay);
                return;
            }
            SoundManager.addChannel(this);
            Browser.container.appendChild(this._audio);
            if ("play" in this._audio) {
                let p = this._audio.play();
                if (p)
                    p.catch(e => { });
            }
        }
        get position() {
            if (!this._audio)
                return 0;
            return this._audio.currentTime;
        }
        get duration() {
            if (!this._audio)
                return 0;
            return this._audio.duration;
        }
        stop() {
            super.stop();
            this.isStopped = true;
            SoundManager.removeChannel(this);
            this.completeHandler = null;
            if (!this._audio)
                return;
            if ("pause" in this._audio)
                if (LayaEnv.isConch) {
                    this._audio.stop();
                }
            this._audio.pause();
            this._audio.removeEventListener("ended", this._onEnd);
            this._audio.removeEventListener("canplay", this._resumePlay);
            if (!ILaya.Browser.onIE) {
                if (this._audio != AudioSound._musicAudio) {
                    Pool.recover("audio:" + this.url, this._audio);
                }
            }
            Browser.removeElement(this._audio);
            this._audio = null;
            if (SoundManager.autoReleaseSound)
                SoundManager.disposeSoundLater(this.url);
        }
        pause() {
            this.isStopped = true;
            SoundManager.removeChannel(this);
            if (!this._audio)
                return;
            if ("pause" in this._audio)
                this._audio.pause();
            if (SoundManager.autoReleaseSound)
                SoundManager.disposeSoundLater(this.url);
        }
        resume() {
            var audio = this._audio;
            if (!audio)
                return;
            this.isStopped = false;
            if (audio.readyState == 0) {
                audio.src = this._src;
                audio.addEventListener("canplay", this._resumePlay);
                audio.load();
            }
            SoundManager.addChannel(this);
            if ("play" in audio) {
                audio.play();
            }
        }
        get volume() {
            if (!this._audio)
                return 1;
            return this._audio.volume;
        }
        set volume(v) {
            if (!this._audio)
                return;
            this._audio.volume = v;
        }
    }

    class AudioSound extends EventDispatcher {
        constructor() {
            super(...arguments);
            this.loaded = false;
        }
        dispose() {
            var ad = AudioSound._audioCache[this.url];
            Pool.clearBySign("audio:" + this.url);
            if (ad) {
                if (!LayaEnv.isConch) {
                    ad.src = "";
                }
                delete AudioSound._audioCache[this.url];
            }
        }
        static _initMusicAudio() {
            if (AudioSound._musicAudio)
                return;
            if (!AudioSound._musicAudio)
                AudioSound._musicAudio = Browser.createElement("audio");
            if (!LayaEnv.isConch) {
                Browser.document.addEventListener("mousedown", AudioSound._makeMusicOK);
            }
        }
        static _makeMusicOK() {
            Browser.document.removeEventListener("mousedown", AudioSound._makeMusicOK);
            if (!AudioSound._musicAudio.src) {
                AudioSound._musicAudio.src = "";
                AudioSound._musicAudio.load();
            }
            else {
                AudioSound._musicAudio.play();
            }
        }
        load(url) {
            this.url = url;
            var ad;
            if (url == SoundManager._bgMusic) {
                AudioSound._initMusicAudio();
                ad = AudioSound._musicAudio;
                if (ad.originalUrl != url) {
                    delete AudioSound._audioCache[ad.originalUrl];
                    ad = null;
                }
            }
            else {
                ad = AudioSound._audioCache[url];
            }
            if (ad && ad.readyState >= 2) {
                this.event(Event.COMPLETE);
                return;
            }
            if (!ad) {
                if (url == SoundManager._bgMusic) {
                    AudioSound._initMusicAudio();
                    ad = AudioSound._musicAudio;
                }
                else {
                    ad = Browser.createElement("audio");
                }
                AudioSound._audioCache[url] = ad;
                AssetDb.inst.resolveURL(url, url => {
                    ad.src = URL.postFormatURL(URL.formatURL(url));
                });
            }
            ad.originalUrl = url;
            ad.addEventListener("canplaythrough", onLoaded);
            ad.addEventListener("error", onErr);
            var me = this;
            function onLoaded() {
                offs();
                me.loaded = true;
                me.event(Event.COMPLETE);
            }
            function onErr() {
                ad.load = null;
                offs();
                me.event(Event.ERROR);
            }
            function offs() {
                ad.removeEventListener("canplaythrough", onLoaded);
                ad.removeEventListener("error", onErr);
            }
            this.audio = ad;
            if (ad.load) {
                ad.load();
            }
            else {
                onErr();
            }
        }
        play(startTime = 0, loops = 0) {
            if (!this.url)
                return null;
            var ad;
            if (this.url == SoundManager._bgMusic) {
                ad = AudioSound._musicAudio;
                if (ad.src != "" && ad.originalUrl != this.url) {
                    delete AudioSound._audioCache[ad.originalUrl];
                    AudioSound._audioCache[this.url] = ad;
                }
            }
            else {
                ad = AudioSound._audioCache[this.url];
            }
            if (!ad)
                return null;
            var tAd;
            tAd = Pool.getItem("audio:" + this.url);
            if (LayaEnv.isConch) {
                if (!tAd) {
                    tAd = Browser.createElement("audio");
                    AssetDb.inst.resolveURL(this.url, url => {
                        tAd.src = URL.postFormatURL(URL.formatURL(url));
                    });
                }
            }
            else {
                if (this.url == SoundManager._bgMusic) {
                    AudioSound._initMusicAudio();
                    tAd = AudioSound._musicAudio;
                    AssetDb.inst.resolveURL(this.url, url => {
                        tAd.src = URL.postFormatURL(URL.formatURL(url));
                    });
                }
                else {
                    tAd = tAd ? tAd : ad.cloneNode(true);
                }
            }
            tAd.originalUrl = this.url;
            var channel = new AudioSoundChannel(tAd);
            channel.url = this.url;
            channel.loops = loops;
            channel.startTime = startTime;
            channel.play();
            SoundManager.addChannel(channel);
            return channel;
        }
        get duration() {
            var ad;
            ad = AudioSound._audioCache[this.url];
            if (!ad)
                return 0;
            return ad.duration;
        }
    }
    AudioSound._audioCache = {};

    class WebAudioSoundChannel extends SoundChannel {
        constructor() {
            super();
            this.bufferSource = null;
            this._currentTime = 0;
            this._volume = 1;
            this._startTime = 0;
            this._pauseTime = 0;
            this.context = WebAudioSound.ctx;
            this._onPlayEnd = this.__onPlayEnd.bind(this);
            if (this.context["createGain"]) {
                this.gain = this.context["createGain"]();
            }
            else {
                this.gain = this.context["createGainNode"]();
            }
        }
        play() {
            SoundManager.addChannel(this);
            this.isStopped = false;
            this._clearBufferSource();
            if (!this.audioBuffer)
                return;
            if (this.startTime >= this.duration)
                return this.stop();
            var context = this.context;
            var gain = this.gain;
            var bufferSource = context.createBufferSource();
            this.bufferSource = bufferSource;
            bufferSource.buffer = this.audioBuffer;
            bufferSource.connect(gain);
            if (gain)
                gain.disconnect();
            gain.connect(context.destination);
            bufferSource.onended = this._onPlayEnd;
            this._startTime = Browser.now();
            if (this.gain.gain.setTargetAtTime) {
                this.gain.gain.setTargetAtTime(this._volume, this.context.currentTime, WebAudioSoundChannel.SetTargetDelay);
            }
            else
                this.gain.gain.value = this._volume;
            if (this.loops == 0) {
                bufferSource.loop = true;
            }
            if (bufferSource.playbackRate.setTargetAtTime) {
                bufferSource.playbackRate.setTargetAtTime(SoundManager.playbackRate, this.context.currentTime, WebAudioSoundChannel.SetTargetDelay);
            }
            else
                bufferSource.playbackRate.value = SoundManager.playbackRate;
            bufferSource.start(0, this.startTime);
            this._currentTime = 0;
        }
        __onPlayEnd() {
            if (this.loops == 1) {
                if (this.completeHandler) {
                    ILaya.timer.once(10, this, this.__runComplete, [this.completeHandler], false);
                    this.completeHandler = null;
                }
                this.stop();
                this.event(Event.COMPLETE);
                return;
            }
            if (this.loops > 0) {
                this.loops--;
            }
            this.startTime = 0;
            this.play();
        }
        get position() {
            if (this.bufferSource) {
                return (Browser.now() - this._startTime) / 1000 + this.startTime;
            }
            return 0;
        }
        get duration() {
            if (this.audioBuffer) {
                return this.audioBuffer.duration;
            }
            return 0;
        }
        _clearBufferSource() {
            if (this.bufferSource) {
                var sourceNode = this.bufferSource;
                if (sourceNode.stop) {
                    sourceNode.stop(0);
                }
                else {
                    sourceNode.noteOff(0);
                }
                sourceNode.disconnect(0);
                sourceNode.onended = null;
                if (!WebAudioSoundChannel._tryCleanFailed)
                    this._tryClearBuffer(sourceNode);
                this.bufferSource = null;
            }
        }
        _tryClearBuffer(sourceNode) {
            try {
                sourceNode.buffer = null;
            }
            catch (e) {
                WebAudioSoundChannel._tryCleanFailed = true;
            }
        }
        stop() {
            super.stop();
            this._clearBufferSource();
            this.audioBuffer = null;
            if (this.gain)
                this.gain.disconnect();
            this.isStopped = true;
            SoundManager.removeChannel(this);
            this.completeHandler = null;
            if (SoundManager.autoReleaseSound)
                SoundManager.disposeSoundLater(this.url);
        }
        pause() {
            if (!this.isStopped) {
                this._pauseTime = this.position;
            }
            this._clearBufferSource();
            if (this.gain)
                this.gain.disconnect();
            this.isStopped = true;
            SoundManager.removeChannel(this);
            if (SoundManager.autoReleaseSound)
                SoundManager.disposeSoundLater(this.url);
        }
        resume() {
            this.startTime = this._pauseTime;
            this.play();
        }
        get volume() {
            return this._volume;
        }
        set volume(v) {
            this._volume = v;
            if (this.isStopped) {
                return;
            }
            if (this.gain.gain.setTargetAtTime) {
                this.gain.gain.setTargetAtTime(v, this.context.currentTime, WebAudioSoundChannel.SetTargetDelay);
            }
            else
                this.gain.gain.value = v;
        }
    }
    WebAudioSoundChannel._tryCleanFailed = false;
    WebAudioSoundChannel.SetTargetDelay = 0.001;

    class WebAudioSound extends EventDispatcher {
        constructor() {
            super(...arguments);
            this.loaded = false;
            this._disposed = false;
        }
        static _playEmptySound() {
            if (WebAudioSound.ctx == null) {
                return;
            }
            var source = WebAudioSound.ctx.createBufferSource();
            source.buffer = WebAudioSound._miniBuffer;
            source.connect(WebAudioSound.ctx.destination);
            source.start(0, 0, 0);
        }
        static _unlock() {
            if (WebAudioSound._unlocked) {
                return;
            }
            WebAudioSound._playEmptySound();
            if (WebAudioSound.ctx.state == "running") {
                window.document.removeEventListener("mousedown", WebAudioSound._unlock, true);
                window.document.removeEventListener("touchend", WebAudioSound._unlock, true);
                window.document.removeEventListener("touchstart", WebAudioSound._unlock, true);
                WebAudioSound._unlocked = true;
            }
        }
        static initWebAudio() {
            WebAudioSound.ctx = new (window["AudioContext"] || window["webkitAudioContext"] || window["mozAudioContext"])();
            if (WebAudioSound.ctx.state != "running") {
                WebAudioSound._unlock();
                window.document.addEventListener("mousedown", WebAudioSound._unlock, true);
                window.document.addEventListener("touchend", WebAudioSound._unlock, true);
                window.document.addEventListener("touchstart", WebAudioSound._unlock, true);
            }
        }
        load(url) {
            this.url = url;
            this.audioBuffer = ILaya.loader.getRes(url);
            if (this.audioBuffer) {
                this._loaded(this.audioBuffer);
                return;
            }
            ILaya.loader.load(url, Loader.SOUND).then(audioBuffer => this._loaded(audioBuffer));
        }
        _loaded(audioBuffer) {
            if (this._disposed)
                return;
            this.audioBuffer = audioBuffer;
            this.loaded = true;
            this.event(Event.COMPLETE);
        }
        __playAfterLoaded() {
            if (!this.__toPlays)
                return;
            var i, len;
            var toPlays;
            toPlays = this.__toPlays;
            len = toPlays.length;
            var tParams;
            for (i = 0; i < len; i++) {
                tParams = toPlays[i];
                if (tParams[2] && !tParams[2].isStopped) {
                    this.play(tParams[0], tParams[1], tParams[2]);
                }
            }
            this.__toPlays.length = 0;
        }
        play(startTime = 0, loops = 0, channel = null) {
            channel = channel ? channel : new WebAudioSoundChannel();
            if (!this.audioBuffer) {
                if (this.url) {
                    if (!this.__toPlays)
                        this.__toPlays = [];
                    this.__toPlays.push([startTime, loops, channel]);
                    this.once(Event.COMPLETE, this, this.__playAfterLoaded);
                    this.load(this.url);
                }
            }
            channel.url = this.url;
            channel.loops = loops;
            channel.audioBuffer = this.audioBuffer;
            channel.startTime = startTime;
            channel.play();
            SoundManager.addChannel(channel);
            return channel;
        }
        get duration() {
            if (this.audioBuffer) {
                return this.audioBuffer.duration;
            }
            return 0;
        }
        dispose() {
            this._disposed = true;
            if (this.audioBuffer) {
                ILaya.loader.clearRes(this.url, this.audioBuffer);
                this.audioBuffer = null;
            }
            this.__toPlays = [];
        }
    }
    WebAudioSound._miniBuffer = WebAudioSound.ctx ? WebAudioSound.ctx.createBuffer(1, 1, 22050) : undefined;
    WebAudioSound._unlocked = false;

    class SoundManager {
        static __init__() {
            var win = ILaya.Browser.window;
            var supportWebAudio = win["AudioContext"] || win["webkitAudioContext"] || win["mozAudioContext"] ? true : false;
            if (supportWebAudio)
                WebAudioSound.initWebAudio();
            SoundManager._soundClass = supportWebAudio ? WebAudioSound : AudioSound;
            if (!Browser.onTBMiniGame) {
                AudioSound._initMusicAudio();
            }
            SoundManager._musicClass = AudioSound;
            return supportWebAudio;
        }
        static addChannel(channel) {
            if (SoundManager._channels.indexOf(channel) >= 0)
                return;
            SoundManager._channels.push(channel);
        }
        static removeChannel(channel) {
            for (let i = SoundManager._channels.length - 1; i >= 0; i--) {
                if (SoundManager._channels[i] == channel) {
                    SoundManager._channels.splice(i, 1);
                }
            }
        }
        static disposeSoundLater(url) {
            SoundManager._lastSoundUsedTimeDic[url] = ILaya.Browser.now();
            if (!SoundManager._isCheckingDispose) {
                SoundManager._isCheckingDispose = true;
                ILaya.timer.loop(5000, null, SoundManager._checkDisposeSound);
            }
        }
        static _checkDisposeSound() {
            let tTime = ILaya.Browser.now();
            let hasCheck = false;
            for (let key in SoundManager._lastSoundUsedTimeDic) {
                if (tTime - SoundManager._lastSoundUsedTimeDic[key] > 30000) {
                    delete SoundManager._lastSoundUsedTimeDic[key];
                    SoundManager.disposeSoundIfNotUsed(key);
                }
                else {
                    hasCheck = true;
                }
            }
            if (!hasCheck) {
                SoundManager._isCheckingDispose = false;
                ILaya.timer.clear(null, SoundManager._checkDisposeSound);
            }
        }
        static disposeSoundIfNotUsed(url) {
            for (let i = SoundManager._channels.length - 1; i >= 0; i--) {
                if (SoundManager._channels[i].url == url) {
                    return;
                }
            }
            SoundManager.destroySound(url);
        }
        static get autoStopMusic() {
            return SoundManager._autoStopMusic;
        }
        static set autoStopMusic(v) {
            ILaya.stage.off(Event.BLUR, null, SoundManager._stageOnBlur);
            ILaya.stage.off(Event.FOCUS, null, SoundManager._stageOnFocus);
            ILaya.stage.off(Event.VISIBILITY_CHANGE, null, SoundManager._visibilityChange);
            SoundManager._autoStopMusic = v;
            if (v) {
                ILaya.stage.on(Event.BLUR, null, SoundManager._stageOnBlur);
                ILaya.stage.on(Event.FOCUS, null, SoundManager._stageOnFocus);
                ILaya.stage.on(Event.VISIBILITY_CHANGE, null, SoundManager._visibilityChange);
            }
        }
        static _visibilityChange() {
            if (ILaya.stage.isVisibility) {
                SoundManager._stageOnFocus();
            }
            else {
                SoundManager._stageOnBlur();
            }
        }
        static _stageOnBlur() {
            SoundManager._isActive = false;
            if (SoundManager._musicChannel) {
                if (!SoundManager._musicChannel.isStopped) {
                    SoundManager._blurPaused = true;
                    SoundManager._musicChannel.pause();
                }
            }
            SoundManager.stopAllSound();
            ILaya.stage.once(Event.MOUSE_DOWN, null, SoundManager._stageOnFocus);
        }
        static _recoverWebAudio() {
            if (WebAudioSound.ctx && WebAudioSound.ctx.state != "running" && WebAudioSound.ctx.resume)
                WebAudioSound.ctx.resume();
        }
        static _stageOnFocus() {
            SoundManager._isActive = true;
            SoundManager._recoverWebAudio();
            ILaya.stage.off(Event.MOUSE_DOWN, null, SoundManager._stageOnFocus);
            if (SoundManager._blurPaused) {
                if (SoundManager._musicChannel && SoundManager._musicChannel.isStopped) {
                    SoundManager._blurPaused = false;
                    SoundManager._musicChannel.resume();
                }
            }
        }
        static get muted() {
            return SoundManager._muted;
        }
        static set muted(value) {
            if (value == SoundManager._muted)
                return;
            if (value) {
                SoundManager.stopAllSound();
            }
            SoundManager.musicMuted = value;
            SoundManager._muted = value;
        }
        static get soundMuted() {
            return SoundManager._soundMuted;
        }
        static set soundMuted(value) {
            SoundManager._soundMuted = value;
        }
        static get musicMuted() {
            return SoundManager._musicMuted;
        }
        static set musicMuted(value) {
            if (value == SoundManager._musicMuted)
                return;
            if (value) {
                if (SoundManager._bgMusic) {
                    if (SoundManager._musicChannel && !SoundManager._musicChannel.isStopped) {
                        if (LayaEnv.isConch) {
                            if (SoundManager._musicChannel._audio)
                                SoundManager._musicChannel._audio.muted = true;
                        }
                        else {
                            SoundManager._musicChannel.pause();
                        }
                    }
                    else {
                        SoundManager._musicChannel = null;
                    }
                }
                else {
                    SoundManager._musicChannel = null;
                }
                SoundManager._musicMuted = value;
            }
            else {
                SoundManager._musicMuted = value;
                if (SoundManager._bgMusic) {
                    if (SoundManager._musicChannel) {
                        if (LayaEnv.isConch) {
                            if (SoundManager._musicChannel._audio)
                                SoundManager._musicChannel._audio.muted = false;
                        }
                        else {
                            SoundManager._musicChannel.resume();
                        }
                    }
                }
            }
        }
        static get useAudioMusic() {
            return SoundManager._useAudioMusic;
        }
        static set useAudioMusic(value) {
            SoundManager._useAudioMusic = value;
            if (value) {
                SoundManager._musicClass = AudioSound;
            }
            else {
                SoundManager._musicClass = null;
            }
        }
        static playSound(url, loops = 1, complete = null, soundClass = null, startTime = 0) {
            if (!SoundManager._isActive || !url)
                return null;
            if (SoundManager._muted)
                return null;
            SoundManager._recoverWebAudio();
            if (url == SoundManager._bgMusic) {
                if (SoundManager._musicMuted)
                    return null;
            }
            else {
                if (SoundManager._soundMuted)
                    return null;
            }
            let tSound;
            if (!Browser._isMiniGame) {
                tSound = SoundManager._soundCache[url];
            }
            if (!soundClass)
                soundClass = SoundManager._soundClass;
            if (!tSound) {
                tSound = new soundClass();
                tSound.load(url);
                if (!Browser._isMiniGame) {
                    SoundManager._soundCache[url] = tSound;
                }
            }
            let channel = tSound.play(startTime, loops);
            if (!channel)
                return null;
            channel.url = url;
            channel.volume = (url == SoundManager._bgMusic) ? SoundManager.musicVolume : SoundManager.soundVolume;
            channel.completeHandler = complete;
            return channel;
        }
        static destroySound(url) {
            let tSound = SoundManager._soundCache[url];
            if (tSound) {
                delete SoundManager._soundCache[url];
                tSound.dispose();
            }
        }
        static playMusic(url, loops = 0, complete = null, startTime = 0) {
            SoundManager._bgMusic = url;
            if (SoundManager._musicChannel)
                SoundManager._musicChannel.stop();
            return SoundManager._musicChannel = SoundManager.playSound(url, loops, complete, SoundManager._musicClass, startTime);
        }
        static stopSound(url) {
            for (let i = SoundManager._channels.length - 1; i >= 0; i--) {
                let channel = SoundManager._channels[i];
                if (channel.url == url) {
                    channel.stop();
                }
            }
        }
        static stopAll() {
            SoundManager._bgMusic = null;
            var i;
            var channel;
            for (i = SoundManager._channels.length - 1; i >= 0; i--) {
                channel = SoundManager._channels[i];
                channel.stop();
            }
        }
        static stopAllSound() {
            for (let i = SoundManager._channels.length - 1; i >= 0; i--) {
                let channel = SoundManager._channels[i];
                if (channel.url != SoundManager._bgMusic) {
                    channel.stop();
                }
            }
        }
        static stopMusic() {
            if (SoundManager._musicChannel)
                SoundManager._musicChannel.stop();
            SoundManager._bgMusic = null;
        }
        static setSoundVolume(volume, url = null) {
            if (url) {
                SoundManager._setVolume(url, volume);
            }
            else {
                SoundManager.soundVolume = volume;
                for (let i = SoundManager._channels.length - 1; i >= 0; i--) {
                    let channel = SoundManager._channels[i];
                    if (channel.url != SoundManager._bgMusic) {
                        channel.volume = volume;
                    }
                }
            }
        }
        static setMusicVolume(volume) {
            SoundManager.musicVolume = volume;
            SoundManager._setVolume(SoundManager._bgMusic, volume);
        }
        static _setVolume(url, volume) {
            for (let i = SoundManager._channels.length - 1; i >= 0; i--) {
                let channel = SoundManager._channels[i];
                if (channel.url == url) {
                    channel.volume = volume;
                }
            }
        }
    }
    SoundManager.musicVolume = 1;
    SoundManager.soundVolume = 1;
    SoundManager.playbackRate = 1;
    SoundManager._useAudioMusic = true;
    SoundManager._muted = false;
    SoundManager._soundMuted = false;
    SoundManager._musicMuted = false;
    SoundManager._bgMusic = null;
    SoundManager._musicChannel = null;
    SoundManager._channels = [];
    SoundManager._blurPaused = false;
    SoundManager._isActive = true;
    SoundManager._lastSoundUsedTimeDic = {};
    SoundManager._isCheckingDispose = false;
    SoundManager._soundCache = {};
    SoundManager.autoReleaseSound = true;

    class LocalStorage {
        static __init__() {
            if (!LocalStorage._baseClass) {
                LocalStorage._baseClass = Storage;
                Storage.init();
            }
            LocalStorage.items = LocalStorage._baseClass.items;
            LocalStorage.support = LocalStorage._baseClass.support;
            return LocalStorage.support;
        }
        static setItem(key, value) {
            LocalStorage._baseClass.setItem(key, value);
        }
        static getItem(key) {
            return LocalStorage._baseClass.getItem(key);
        }
        static setJSON(key, value) {
            LocalStorage._baseClass.setJSON(key, value);
        }
        static getJSON(key) {
            return LocalStorage._baseClass.getJSON(key);
        }
        static removeItem(key) {
            LocalStorage._baseClass.removeItem(key);
        }
        static clear() {
            LocalStorage._baseClass.clear();
        }
    }
    LocalStorage.support = false;
    class Storage {
        static init() {
            try {
                Storage.support = true;
                Storage.items = window.localStorage;
                Storage.setItem('laya', '1');
                Storage.removeItem('laya');
            }
            catch (e) {
                Storage.support = false;
            }
            if (!Storage.support)
                console.log('LocalStorage is not supprot or browser is private mode.');
        }
        static setItem(key, value) {
            try {
                Storage.support && Storage.items.setItem(key, value);
            }
            catch (e) {
                console.warn("set localStorage failed", e);
            }
        }
        static getItem(key) {
            return Storage.support ? Storage.items.getItem(key) : null;
        }
        static setJSON(key, value) {
            try {
                Storage.support && Storage.items.setItem(key, JSON.stringify(value));
            }
            catch (e) {
                console.warn("set localStorage failed", e);
            }
        }
        static getJSON(key) {
            try {
                let obj = JSON.parse(Storage.support ? Storage.items.getItem(key) : null);
                return obj;
            }
            catch (err) {
                return Storage.items.getItem(key);
            }
        }
        static removeItem(key) {
            Storage.support && Storage.items.removeItem(key);
        }
        static clear() {
            Storage.support && Storage.items.clear();
        }
    }
    Storage.support = false;

    class PrimitiveSV extends Value2D {
        constructor() {
            super(exports.RenderSpriteData.Primitive);
            PrimitiveSV.prototype.initialize.call(this);
        }
        initialize() {
            this._defaultShader = Shader3D.find("Sprite2DPrimitive");
        }
        reinit() {
            super.initialize();
            this.initialize();
        }
    }

    class TextureSV extends Value2D {
        constructor() {
            super(exports.RenderSpriteData.Texture2D);
            TextureSV.prototype.initialize.call(this);
        }
        initialize() {
            this._blurInfo = new Vector2();
            this._u_blurInfo1 = new Vector4();
            this._u_blurInfo2 = new Vector4();
            this._u_TexRange = new Vector4();
            this._colorMat = new Matrix4x4();
            this._colorAlpha = new Vector4();
            this._strength_sig2_2sig2_gauss1 = new Vector4();
            this._defaultShader = Shader3D.find("Sprite2DTexture");
            this.blurInfo = this._blurInfo;
            this.u_blurInfo1 = this._u_blurInfo1;
            this.u_blurInfo2 = this._u_blurInfo2;
            this.u_TexRange = this._u_TexRange;
            this.colorMat = this._colorMat;
            this.colorAlpha = this._colorAlpha;
            this.strength_sig2_2sig2_gauss1 = this._strength_sig2_2sig2_gauss1;
        }
        reinit() {
            super.initialize();
            this.initialize();
        }
        get blurInfo() {
            return this.shaderData.getVector2(ShaderDefines2D.UNIFORM_BLURINFO);
        }
        set blurInfo(value) {
            this.shaderData.setVector2(ShaderDefines2D.UNIFORM_BLURINFO, value);
        }
        get u_blurInfo1() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_BLURINFO1);
        }
        set u_blurInfo1(value) {
            this.shaderData.setVector(ShaderDefines2D.UNIFORM_BLURINFO1, value);
        }
        get u_blurInfo2() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_BLURINFO2);
        }
        set u_blurInfo2(value) {
            this.shaderData.setVector(ShaderDefines2D.UNIFORM_BLURINFO2, value);
        }
        get u_TexRange() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_TEXRANGE);
        }
        set u_TexRange(value) {
            this.shaderData.setVector(ShaderDefines2D.UNIFORM_TEXRANGE, value);
        }
        get colorMat() {
            return this.shaderData.getMatrix4x4(ShaderDefines2D.UNIFORM_COLORMAT);
        }
        set colorMat(value) {
            this.shaderData.setMatrix4x4(ShaderDefines2D.UNIFORM_COLORMAT, value);
        }
        get colorAlpha() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_COLORALPHA);
        }
        set colorAlpha(value) {
            this.shaderData.setVector(ShaderDefines2D.UNIFORM_COLORALPHA, value);
        }
        get strength_sig2_2sig2_gauss1() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_STRENGTH_SIG2_2SIG2_GAUSS1);
        }
        set strength_sig2_2sig2_gauss1(value) {
            this.shaderData.setVector(ShaderDefines2D.UNIFORM_STRENGTH_SIG2_2SIG2_GAUSS1, value);
        }
    }

    class Mouse {
        static set cursor(cursorStr) {
            Mouse._style.cursor = cursorStr;
        }
        static get cursor() {
            return Mouse._style.cursor;
        }
        static __init__() {
            Mouse._style = Browser.document.body.style;
        }
        static hide() {
            if (Mouse.cursor != "none") {
                Mouse._preCursor = Mouse.cursor;
                Mouse.cursor = "none";
            }
        }
        static show() {
            if (Mouse.cursor == "none") {
                if (Mouse._preCursor) {
                    Mouse.cursor = Mouse._preCursor;
                }
                else {
                    Mouse.cursor = "auto";
                }
            }
        }
    }

    class WeakObject {
        static __init__() {
            WeakObject.I = new WeakObject();
            if (!WeakObject.supportWeakMap)
                ILaya.systemTimer.loop(WeakObject.delInterval, null, WeakObject.clearCache);
        }
        static clearCache() {
            for (var i = 0, n = WeakObject._maps.length; i < n; i++) {
                var obj = WeakObject._maps[i];
                obj._obj = {};
            }
        }
        constructor() {
            this._obj = {};
            WeakObject._maps.push(this);
        }
        set(key, value) {
            if (key == null)
                return;
            if (WeakObject.supportWeakMap) ;
            else {
                if (typeof (key) == 'string' || typeof (key) == 'number') {
                    this._obj[key] = value;
                }
                else {
                    key.$_GID || (key.$_GID = Utils.getGID());
                    this._obj[key.$_GID] = value;
                }
            }
        }
        get(key) {
            if (key == null)
                return null;
            if (WeakObject.supportWeakMap) ;
            else {
                if (typeof (key) == 'string' || typeof (key) == 'number')
                    return this._obj[key];
                return this._obj[key.$_GID];
            }
        }
        del(key) {
            if (key == null)
                return;
            if (WeakObject.supportWeakMap) ;
            else {
                if (typeof (key) == 'string' || typeof (key) == 'number')
                    delete this._obj[key];
                else
                    delete this._obj[this._obj.$_GID];
            }
        }
        has(key) {
            if (key == null)
                return false;
            if (WeakObject.supportWeakMap) {
                return false;
            }
            else {
                if (typeof (key) == 'string' || typeof (key) == 'number')
                    return this._obj[key] != null;
                return this._obj[this._obj.$_GID] != null;
            }
        }
    }
    WeakObject.supportWeakMap = false;
    WeakObject.delInterval = 10 * 60 * 1000;
    WeakObject._maps = [];

    class UniformBufferBase {
        constructor(name, pointer, single) {
            this._mapArray = [];
            this._blockName = name;
            this._singgle = single;
            this._glPointerID = pointer;
        }
        add(buffer) {
            let index = this._mapArray.indexOf(buffer);
            if (index == -1)
                this._mapArray.push(buffer);
        }
        splitBuffer(buffer) {
            let index = this._mapArray.indexOf(buffer);
            if (index != -1)
                this._mapArray.splice(index, 1);
        }
    }

    class UniformBufferObject {
        static create(name, bufferUsage, bytelength, isSingle = false) {
            if (!UniformBufferObject._Map.get(name)) {
                UniformBufferObject._Map.set(name, new UniformBufferBase(name, LayaGL.renderEngine.getUBOPointer(name), isSingle));
            }
            let bufferBase = UniformBufferObject._Map.get(name);
            if (bufferBase._singgle && bufferBase._mapArray.length > 0) {
                return null;
            }
            else {
                let ubo = LayaGL.renderOBJCreate.createUniformBufferObject(bufferBase._glPointerID, name, bufferUsage, bytelength, isSingle);
                if (bufferBase._singgle)
                    bufferBase.add(ubo);
                return ubo;
            }
        }
        static getBuffer(name, index) {
            let base = UniformBufferObject._Map.get(name);
            if (!base)
                return null;
            return base._mapArray[index];
        }
        constructor(glPointer, name, bufferUsage, byteLength, isSingle) {
            this._isSingle = false;
            this.bufferType = exports.BufferTargetType.UNIFORM_BUFFER;
            this.bufferUsage = bufferUsage;
            this._glPointer = glPointer;
            this.byteLength = byteLength;
            this._name = name;
            this._isSingle = isSingle;
            this._glBuffer = LayaGL.renderEngine.createBuffer(exports.BufferTargetType.UNIFORM_BUFFER, bufferUsage);
            this.bind();
            if (this._isSingle)
                this._bindUniformBufferBase();
            this._glBuffer.setDataLength(this.byteLength);
        }
        _bindUniformBufferBase() {
            this._glBuffer.bindBufferBase(this._glPointer);
        }
        _bindBufferRange(offset, byteCount) {
            this.bind();
            this._glBuffer.bindBufferRange(this._glPointer, offset, byteCount);
        }
        _reset(bytelength) {
            if (this._glBuffer) {
                this._glBuffer.destroy();
                this._glBuffer = null;
            }
            this.byteLength = bytelength;
            this._glBuffer = LayaGL.renderEngine.createBuffer(this.bufferType, this.bufferUsage);
            if (this._isSingle)
                this._bindUniformBufferBase();
            this._glBuffer.setDataLength(this.byteLength);
        }
        bind() {
            return this._glBuffer.bindBuffer();
        }
        setData(buffer, bufferOffset = 0, byteCount = Number.MAX_SAFE_INTEGER) {
            if (byteCount < 0)
                return;
            this.bind();
            var needSubData = !(bufferOffset == 0 && byteCount == this.byteLength);
            if (needSubData) {
                var subData = new Uint8Array(buffer.buffer, bufferOffset, byteCount);
                this._glBuffer.setData(subData, bufferOffset);
            }
            else {
                this._glBuffer.setDataEx(buffer, bufferOffset, buffer.length);
            }
        }
        setDataByUniformBufferData(bufferData) {
            if (this._updateDataInfo == bufferData) {
                this.setData(bufferData._buffer, bufferData._updateFlag.x * 4, (bufferData._updateFlag.y - bufferData._updateFlag.x) * 4);
                bufferData._resetUpdateFlag();
            }
            else {
                this.setData(bufferData._buffer, 0, this.byteLength);
                bufferData._resetUpdateFlag();
                this._updateDataInfo = bufferData;
            }
        }
        setDataByByUniformBufferDataOffset(bufferData, offset) {
            let datalength = bufferData.getbyteLength();
            let reallength = bufferData._realByte;
            bufferData._resetUpdateFlag();
            this.bind();
            this._glBuffer.setDataEx(bufferData._buffer, offset * datalength, reallength / 4);
        }
        destroy() {
            if (this._glBuffer) {
                this._glBuffer.destroy();
                this._glBuffer = null;
            }
        }
    }
    UniformBufferObject.UBONAME_SCENE = "SceneUniformBlock";
    UniformBufferObject.UBONAME_CAMERA = "CameraUniformBlock";
    UniformBufferObject.UBONAME_SPRITE3D = "SpriteUniformBlock";
    UniformBufferObject.UBONAME_SHADOW = "ShadowUniformBlock";
    UniformBufferObject._Map = new Map();

    exports.MaterialRenderMode = void 0;
    (function (MaterialRenderMode) {
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_OPAQUE"] = 0] = "RENDERMODE_OPAQUE";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_CUTOUT"] = 1] = "RENDERMODE_CUTOUT";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_TRANSPARENT"] = 2] = "RENDERMODE_TRANSPARENT";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_ADDTIVE"] = 3] = "RENDERMODE_ADDTIVE";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_ALPHABLENDED"] = 4] = "RENDERMODE_ALPHABLENDED";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_CUSTOME"] = 5] = "RENDERMODE_CUSTOME";
    })(exports.MaterialRenderMode || (exports.MaterialRenderMode = {}));
    class Material extends Resource {
        static load(url, complete) {
            ILaya.loader.load(url, complete, null, Loader.MATERIAL);
        }
        static __initDefine__() {
            Material.SHADERDEFINE_ALPHATEST = Shader3D.getDefineByName("ALPHATEST");
            Material.SHADERDEFINE_MAINTEXTURE = Shader3D.getDefineByName("MAINTEXTURE");
            Material.SHADERDEFINE_ADDTIVEFOG = Shader3D.getDefineByName("ADDTIVEFOG");
            Material.ALPHATESTVALUE = Shader3D.propertyNameToID("u_AlphaTestValue");
            Shader3D.CULL = Shader3D.propertyNameToID("s_Cull");
            Shader3D.BLEND = Shader3D.propertyNameToID("s_Blend");
            Shader3D.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc");
            Shader3D.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst");
            Shader3D.BLEND_SRC_RGB = Shader3D.propertyNameToID("s_BlendSrcRGB");
            Shader3D.BLEND_DST_RGB = Shader3D.propertyNameToID("s_BlendDstRGB");
            Shader3D.BLEND_SRC_ALPHA = Shader3D.propertyNameToID("s_BlendSrcAlpha");
            Shader3D.BLEND_DST_ALPHA = Shader3D.propertyNameToID("s_BlendDstAlpha");
            Shader3D.BLEND_EQUATION = Shader3D.propertyNameToID("s_BlendEquation");
            Shader3D.BLEND_EQUATION_RGB = Shader3D.propertyNameToID("s_BlendEquationRGB");
            Shader3D.BLEND_EQUATION_ALPHA = Shader3D.propertyNameToID("s_BlendEquationAlpha");
            Shader3D.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest");
            Shader3D.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite");
            Shader3D.STENCIL_Ref = Shader3D.propertyNameToID("s_StencilRef");
            Shader3D.STENCIL_TEST = Shader3D.propertyNameToID("s_StencilTest");
            Shader3D.STENCIL_WRITE = Shader3D.propertyNameToID("s_StencilWrite");
            Shader3D.STENCIL_Op = Shader3D.propertyNameToID("s_StencilOp");
        }
        get renderQueue() {
            return this._renderQueue;
        }
        set renderQueue(value) {
            this._renderQueue = value;
            this._notifyOwnerElements();
        }
        _setOwnerElement(element) {
            this.ownerElements.add(element);
            element.materialShaderData = this.shaderData;
            element.materialRenderQueue = this.renderQueue;
            element.subShader = this._shader.getSubShaderAt(0);
            element.materialId = this.id;
        }
        _removeOwnerElement(element) {
            this.ownerElements.delete(element);
        }
        _notifyOwnerElements() {
            this.ownerElements.forEach(element => {
                this._setOwnerElement(element);
            });
        }
        get shaderData() {
            return this._shaderValues;
        }
        get alphaTestValue() {
            return this._shaderValues.getNumber(Material.ALPHATESTVALUE);
        }
        set alphaTestValue(value) {
            this._shaderValues.setNumber(Material.ALPHATESTVALUE, value);
        }
        get alphaTest() {
            return this.shaderData.hasDefine(Material.SHADERDEFINE_ALPHATEST);
        }
        set alphaTest(value) {
            if (value)
                this._shaderValues.addDefine(Material.SHADERDEFINE_ALPHATEST);
            else
                this._shaderValues.removeDefine(Material.SHADERDEFINE_ALPHATEST);
        }
        addDefine(define) {
            this._shaderValues.addDefine(define);
        }
        removeDefine(define) {
            this._shaderValues.removeDefine(define);
        }
        setDefine(define, value) {
            if (value) {
                this._shaderValues.addDefine(define);
            }
            else {
                this._shaderValues.removeDefine(define);
            }
        }
        hasDefine(define) {
            return this._shaderValues.hasDefine(define);
        }
        get depthWrite() {
            return this._shaderValues.getBool(Shader3D.DEPTH_WRITE);
        }
        set depthWrite(value) {
            this._shaderValues.setBool(Shader3D.DEPTH_WRITE, value);
        }
        get cull() {
            return this._shaderValues.getInt(Shader3D.CULL);
        }
        set cull(value) {
            this._shaderValues.setInt(Shader3D.CULL, value);
        }
        get blend() {
            return this._shaderValues.getInt(Shader3D.BLEND);
        }
        set blend(value) {
            this._shaderValues.setInt(Shader3D.BLEND, value);
        }
        get blendSrc() {
            return this._shaderValues.getInt(Shader3D.BLEND_SRC);
        }
        set blendSrc(value) {
            this._shaderValues.setInt(Shader3D.BLEND_SRC, value);
        }
        get blendDst() {
            return this._shaderValues.getInt(Shader3D.BLEND_DST);
        }
        set blendDst(value) {
            this._shaderValues.setInt(Shader3D.BLEND_DST, value);
        }
        get blendSrcAlpha() {
            return this._shaderValues.getInt(Shader3D.BLEND_SRC_ALPHA);
        }
        set blendSrcAlpha(value) {
            this._shaderValues.setInt(Shader3D.BLEND_SRC_ALPHA, value);
        }
        get blendSrcRGB() {
            return this._shaderValues.getInt(Shader3D.BLEND_SRC_RGB);
        }
        set blendSrcRGB(value) {
            this._shaderValues.setInt(Shader3D.BLEND_SRC_RGB, value);
        }
        get blendDstRGB() {
            return this._shaderValues.getInt(Shader3D.BLEND_DST_RGB);
        }
        set blendDstRGB(value) {
            this._shaderValues.setInt(Shader3D.BLEND_DST_RGB, value);
        }
        get blendDstAlpha() {
            return this._shaderValues.getInt(Shader3D.BLEND_DST_ALPHA);
        }
        set blendDstAlpha(value) {
            this._shaderValues.setInt(Shader3D.BLEND_DST_ALPHA, value);
        }
        get blendEquation() {
            return this._shaderValues.getInt(Shader3D.BLEND_EQUATION);
        }
        set blendEquation(value) {
            this._shaderValues.setInt(Shader3D.BLEND_EQUATION, value);
        }
        get blendEquationRGB() {
            return this._shaderValues.getInt(Shader3D.BLEND_EQUATION_RGB);
        }
        set blendEquationRGB(value) {
            this._shaderValues.setInt(Shader3D.BLEND_EQUATION_RGB, value);
        }
        get blendEquationAlpha() {
            return this._shaderValues.getInt(Shader3D.BLEND_EQUATION_ALPHA);
        }
        set blendEquationAlpha(value) {
            this._shaderValues.setInt(Shader3D.BLEND_EQUATION_ALPHA, value);
        }
        get depthTest() {
            return this._shaderValues.getInt(Shader3D.DEPTH_TEST);
        }
        set depthTest(value) {
            this._shaderValues.setInt(Shader3D.DEPTH_TEST, value);
        }
        get stencilTest() {
            return this._shaderValues.getInt(Shader3D.STENCIL_TEST);
        }
        set stencilTest(value) {
            this._shaderValues.setInt(Shader3D.STENCIL_TEST, value);
        }
        get stencilWrite() {
            return this._shaderValues.getBool(Shader3D.STENCIL_WRITE);
        }
        set stencilWrite(value) {
            this._shaderValues.setBool(Shader3D.STENCIL_WRITE, value);
        }
        get stencilRef() {
            return this._shaderValues.getInt(Shader3D.STENCIL_Ref);
        }
        set stencilRef(value) {
            this._shaderValues.setInt(Shader3D.STENCIL_Ref, value);
        }
        get stencilOp() {
            return this._shaderValues.getVector3(Shader3D.STENCIL_Op);
        }
        set stencilOp(value) {
            this._shaderValues.setVector3(Shader3D.STENCIL_Op, value);
        }
        get MaterialProperty() {
            let propertyMap = {};
            var shaderValues = this._shaderValues.getData();
            for (let key in shaderValues) {
                propertyMap[LayaGL.renderEngine.propertyIDToName(parseInt(key))] = shaderValues[key];
            }
            return propertyMap;
        }
        get MaterialDefine() {
            let shaderDefineArray = new Array();
            let defineData = this._shaderValues.getDefineData();
            Shader3D._getNamesByDefineData(defineData, shaderDefineArray);
            return shaderDefineArray;
        }
        get materialRenderMode() {
            return this._matRenderNode;
        }
        set materialRenderMode(value) {
            this._matRenderNode = value;
            switch (value) {
                case exports.MaterialRenderMode.RENDERMODE_OPAQUE:
                    this.alphaTest = false;
                    this.renderQueue = Material.RENDERQUEUE_OPAQUE;
                    this.depthWrite = true;
                    this.blend = RenderState.BLEND_DISABLE;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    break;
                case exports.MaterialRenderMode.RENDERMODE_CUTOUT:
                    this.renderQueue = Material.RENDERQUEUE_ALPHATEST;
                    this.alphaTest = true;
                    this.depthWrite = true;
                    this.blend = RenderState.BLEND_DISABLE;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    break;
                case exports.MaterialRenderMode.RENDERMODE_TRANSPARENT:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.blend = RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    break;
                case exports.MaterialRenderMode.RENDERMODE_ADDTIVE:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.blend = RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = RenderState.BLENDPARAM_ONE;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    this._shaderValues.addDefine(Material.SHADERDEFINE_ADDTIVEFOG);
                    break;
                case exports.MaterialRenderMode.RENDERMODE_ALPHABLENDED:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.blend = RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    this._shaderValues.removeDefine(Material.SHADERDEFINE_ADDTIVEFOG);
                    break;
                case exports.MaterialRenderMode.RENDERMODE_CUSTOME:
                    break;
                default:
                    console.warn(`Material : renderMode value error - (${value}).`);
                    break;
            }
        }
        constructor() {
            super();
            this.ownerElements = new Set();
            this._shaderValues = LayaGL.renderDeviceFactory.createShaderData(this);
            this.renderQueue = Material.RENDERQUEUE_OPAQUE;
            this._matRenderNode = 0;
            this.alphaTest = false;
            this.cull = RenderState.CULL_BACK;
            this.blend = RenderState.BLEND_DISABLE;
            this.blendSrc = RenderState.BLENDPARAM_ONE;
            this.blendDst = RenderState.BLENDPARAM_ZERO;
            this.blendSrcRGB = RenderState.BLENDPARAM_ONE;
            this.blendDstRGB = RenderState.BLENDPARAM_ZERO;
            this.blendSrcAlpha = RenderState.BLENDPARAM_ONE;
            this.blendDstAlpha = RenderState.BLENDPARAM_ZERO;
            this.blendEquation = RenderState.BLENDEQUATION_ADD;
            this.blendEquationRGB = RenderState.BLENDEQUATION_ADD;
            this.blendEquationAlpha = RenderState.BLENDEQUATION_ADD;
            this.depthTest = RenderState.DEPTHTEST_LEQUAL;
            this.depthWrite = true;
            this.stencilRef = 1;
            this.stencilTest = RenderState.STENCILTEST_OFF;
            this.stencilWrite = false;
            this.stencilOp = new Vector3(RenderState.STENCILOP_KEEP, RenderState.STENCILOP_KEEP, RenderState.STENCILOP_REPLACE);
            this.destroyedImmediately = Config.destroyResourceImmediatelyDefault;
        }
        _bindShaderInfo(shader) {
            let subShader = shader.getSubShaderAt(0);
            let shaderUBODatas = subShader._uniformBufferDataMap;
            if (!shaderUBODatas)
                return;
            for (let key of shaderUBODatas.keys()) {
                let uboData = shaderUBODatas.get(key).clone();
                let ubo = UniformBufferObject.create(key, exports.BufferUsage.Dynamic, uboData.getbyteLength(), false);
                this._shaderValues.setUniformBuffer(Shader3D.propertyNameToID(key), ubo);
                this._shaderValues._addCheckUBO(key, ubo, uboData);
            }
        }
        _releaseUBOData() {
            this._shaderValues._releaseUBOData();
        }
        _disposeResource() {
            this._releaseUBOData();
            this._shaderValues.destroy();
            this._shaderValues = null;
            this.ownerElements.clear();
        }
        get shader() {
            return this._shader;
        }
        effectiveProperty() {
            return this._shader.getSubShaderAt(0)._uniformTypeMap;
        }
        setShaderName(name) {
            this._shader = Shader3D.find(name);
            if (!this._shader) {
                console.warn(`Material: unknown shader name '${name}'`);
                this._shader = Shader3D.find("BLINNPHONG");
            }
            if (Config3D._uniformBlock) {
                this._releaseUBOData();
                this._bindShaderInfo(this._shader);
            }
            let subShader = this._shader.getSubShaderAt(0);
            let defaultValue = subShader._uniformDefaultValue;
            let typeMap = subShader._uniformTypeMap;
            this.applyUniformDefaultValue(typeMap, defaultValue);
            this._notifyOwnerElements();
        }
        applyUniformDefaultValue(typeMap, defaultValue) {
            typeMap.forEach((type, key) => {
                if (defaultValue && defaultValue[key] != undefined) {
                    let value = defaultValue[key];
                    this.setShaderData(key, type, value);
                }
                else {
                    let value = ShaderDataDefaultValue(type);
                    if (value) {
                        this.setShaderData(key, type, value);
                    }
                }
            });
        }
        getBoolByIndex(uniformIndex) {
            return this.shaderData.getBool(uniformIndex);
        }
        setBoolByIndex(uniformIndex, value) {
            this.shaderData.setBool(uniformIndex, value);
        }
        getBool(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getBoolByIndex(uniformIndex);
        }
        setBool(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setBoolByIndex(uniformIndex, value);
        }
        getFloatByIndex(uniformIndex) {
            return this.shaderData.getNumber(uniformIndex);
        }
        setFloatByIndex(uniformIndex, value) {
            this.shaderData.setNumber(uniformIndex, value);
        }
        getFloat(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getFloatByIndex(uniformIndex);
        }
        setFloat(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setFloatByIndex(uniformIndex, value);
        }
        getIntByIndex(uniformIndex) {
            return this.shaderData.getInt(uniformIndex);
        }
        setIntByIndex(uniformIndex, value) {
            this.shaderData.setInt(uniformIndex, value);
        }
        getInt(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getIntByIndex(uniformIndex);
        }
        setInt(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setIntByIndex(uniformIndex, value);
        }
        getVector2ByIndex(uniformIndex) {
            return this.shaderData.getVector2(uniformIndex);
        }
        setVector2ByIndex(uniformIndex, value) {
            this.shaderData.setVector2(uniformIndex, value);
        }
        getVector2(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getVector2ByIndex(uniformIndex);
        }
        setVector2(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setVector2ByIndex(uniformIndex, value);
        }
        getVector3ByIndex(uniformIndex) {
            return this.shaderData.getVector3(uniformIndex);
        }
        setVector3ByIndex(uniformIndex, value) {
            this.shaderData.setVector3(uniformIndex, value);
        }
        getVector3(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getVector3ByIndex(uniformIndex);
        }
        setVector3(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setVector3ByIndex(uniformIndex, value);
        }
        setVector4ByIndex(uniformIndex, value) {
            this.shaderData.setVector(uniformIndex, value);
        }
        getVector4ByIndex(uniformIndex) {
            return this.shaderData.getVector(uniformIndex);
        }
        setVector4(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setVector4ByIndex(uniformIndex, value);
        }
        getVector4(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getVector4ByIndex(uniformIndex);
        }
        getColorByIndex(uniformIndex) {
            return this.shaderData.getColor(uniformIndex);
        }
        setColorByIndex(uniformIndex, value) {
            this.shaderData.setColor(uniformIndex, value);
        }
        getColor(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.shaderData.getColor(uniformIndex);
        }
        setColor(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setColorByIndex(uniformIndex, value);
        }
        getMatrix4x4ByIndex(uniformIndex) {
            return this.shaderData.getMatrix4x4(uniformIndex);
        }
        setMatrix4x4ByIndex(uniformIndex, value) {
            this.shaderData.setMatrix4x4(uniformIndex, value);
        }
        getMatrix4x4(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getMatrix4x4ByIndex(uniformIndex);
        }
        setMatrix4x4(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setMatrix4x4ByIndex(uniformIndex, value);
        }
        getMatrix3x3ByIndex(index) {
            return this.shaderData.getMatrix3x3(index);
        }
        setMatrix3x3ByIndex(index, value) {
            this.shaderData.setMatrix3x3(index, value);
        }
        getMatrix3x3(name) {
            let index = Shader3D.propertyNameToID(name);
            return this.getMatrix3x3ByIndex(index);
        }
        setMatrix3x3(name, value) {
            let index = Shader3D.propertyNameToID(name);
            this.setMatrix3x3ByIndex(index, value);
        }
        setTextureByIndex(uniformIndex, texture) {
            this.shaderData.setTexture(uniformIndex, texture);
            if (texture && !texture._texture)
                texture.once(Event.READY, this, this.reSetTexture, [uniformIndex, texture]);
        }
        reSetTexture(uniformIndex, texture) {
            this.setTextureByIndex(uniformIndex, texture);
        }
        getTextureByIndex(uniformIndex) {
            return this.shaderData.getTexture(uniformIndex);
        }
        setTexture(name, texture) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setTextureByIndex(uniformIndex, texture);
        }
        getTexture(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getTextureByIndex(uniformIndex);
        }
        getBufferByIndex(uniformIndex) {
            return this.shaderData.getBuffer(uniformIndex);
        }
        setBufferByIndex(uniformIndex, value) {
            this.shaderData.setBuffer(uniformIndex, value);
        }
        getBuffer(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getBufferByIndex(uniformIndex);
        }
        setBuffer(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setBufferByIndex(uniformIndex, value);
        }
        setShaderDataByIndex(uniformIndex, type, value) {
            this.shaderData.setShaderData(uniformIndex, type, value);
        }
        setShaderData(name, type, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setShaderDataByIndex(uniformIndex, type, value);
        }
        getShaderData(name, type) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getShaderDataByIndex(uniformIndex, type);
        }
        getShaderDataByIndex(uniformIndex, type) {
            return this._shaderValues.getShaderData(uniformIndex, type);
        }
        cloneTo(destObject) {
            destObject.name = this.name;
            destObject.renderQueue = this.renderQueue;
            destObject.setShaderName(this._shader._name);
            this._shaderValues.cloneTo(destObject._shaderValues);
        }
        clone() {
            var dest = new Material();
            this.cloneTo(dest);
            return dest;
        }
        get _defineDatas() {
            return this._shaderValues.getDefineData();
        }
        oldparseEndEvent() {
        }
    }
    Material.RENDERQUEUE_OPAQUE = 2000;
    Material.RENDERQUEUE_ALPHATEST = 2450;
    Material.RENDERQUEUE_TRANSPARENT = 3000;

    class Laya {
        static init(...args) {
            if (Laya._inited)
                return Promise.resolve();
            Laya._inited = true;
            Stat.renderPassStatArray.length = exports.RenderPassStatisticsInfo.RenderPassStatisticCount;
            if (!WebGL.enable())
                throw new Error("Must support webGL!");
            let stageConfig;
            if (typeof (args[0]) === "number") {
                stageConfig = {
                    designWidth: args[0],
                    designHeight: args[1]
                };
            }
            else
                stageConfig = args[0];
            Browser.__init__();
            URL.__init__();
            let laya3D = window["Laya3D"];
            if (laya3D) {
                RunDriver.changeWebGLSize = laya3D._changeWebGLSize;
                Render.is3DMode = true;
            }
            let mainCanv = Browser.mainCanvas = new HTMLCanvas(true);
            Laya._setStyleInfo(mainCanv);
            if (!Browser.onKGMiniGame && !Browser.onAlipayMiniGame && !Browser.onTBMiniGame) {
                Browser.container.appendChild(mainCanv.source);
            }
            Browser.canvas = new HTMLCanvas(true);
            Browser.context = Browser.canvas.getContext('2d');
            Browser.supportWebAudio = SoundManager.__init__();
            Browser.supportLocalStorage = LocalStorage.__init__();
            exports.systemTimer = new Timer(false);
            exports.physicsTimer = new Timer(false);
            exports.timer = new Timer(false);
            exports.loader = new Loader();
            Laya.systemTimer = Timer.gSysTimer = exports.systemTimer;
            Laya.timer = exports.timer;
            Laya.physicsTimer = exports.physicsTimer;
            Laya.loader = exports.loader;
            ILaya.systemTimer = exports.systemTimer;
            ILaya.physicsTimer = exports.physicsTimer;
            ILaya.timer = exports.timer;
            ILaya.loader = exports.loader;
            WeakObject.__init__();
            Mouse.__init__();
            CacheManger.beginCheck();
            let steps = [];
            if (LayaEnv.beforeInit)
                steps.push(() => LayaEnv.beforeInit(stageConfig));
            Laya._beforeInitCallbacks.forEach(func => steps.push(() => func(stageConfig)));
            steps.push(() => LayaGL.renderOBJCreate.createEngine(null, Browser.mainCanvas));
            steps.push(() => Laya.initRender2D(stageConfig));
            if (laya3D)
                steps.push(() => laya3D.__init__());
            steps.push(() => Promise.all(Laya._initCallbacks.map(func => func())));
            steps.push(() => {
                let p = Promise.resolve();
                for (let func of Laya._afterInitCallbacks)
                    p = p.then(func);
                return p;
            });
            if (LayaEnv.afterInit)
                steps.push(() => LayaEnv.afterInit());
            let p = Promise.resolve();
            for (let step of steps)
                p = p.then(step);
            return p;
        }
        static _setStyleInfo(mainCanv) {
            let style = mainCanv.source.style;
            style.position = 'absolute';
            style.top = style.left = "0px";
            style.background = "#000000";
        }
        static initRender2D(stageConfig) {
            exports.stage = window.stage = ILaya.stage = Laya.stage = new Stage();
            VertexElementFormat.__init__();
            VertexMesh.__init__();
            Shader3D.init();
            MeshQuadTexture.__int__();
            MeshVG.__init__();
            MeshTexture.__init__();
            Laya.render = Laya.createRender();
            exports.render = Laya.render;
            exports.stage.size(stageConfig.designWidth, stageConfig.designHeight);
            if (stageConfig.scaleMode)
                exports.stage.scaleMode = stageConfig.scaleMode;
            if (stageConfig.screenMode)
                exports.stage.screenMode = stageConfig.screenMode;
            if (stageConfig.alignV)
                exports.stage.alignV = stageConfig.alignV;
            if (stageConfig.alignH)
                exports.stage.alignH = stageConfig.alignH;
            if (Config.isAlpha)
                exports.stage.bgColor = "#00000000";
            else if (stageConfig.backgroundColor)
                exports.stage.bgColor = stageConfig.backgroundColor;
            if (LayaEnv.isConch && window.conch.setGlobalRepaint) {
                window.conch.setGlobalRepaint(exports.stage.setGlobalRepaint.bind(exports.stage));
            }
            RenderStateContext.__init__();
            RenderSprite.__init__();
            Material.__initDefine__();
            DrawStyle._Defaultinit();
            InputManager.__init__(exports.stage, Render.canvas);
            if (!!window.conch && "conchUseWXAdapter" in Browser.window) {
                Input.isAppUseNewInput = true;
            }
            Input.__init__();
            SoundManager.autoStopMusic = true;
            Value2D._initone(exports.RenderSpriteData.Texture2D, TextureSV);
            Value2D._initone(exports.RenderSpriteData.Primitive, PrimitiveSV);
        }
        static createRender() {
            return new Render(0, 0, Browser.mainCanvas);
        }
        static alertGlobalError(value) {
            var erralert = 0;
            if (value) {
                Browser.window.onerror = function (msg, url, line, column, detail) {
                    if (erralert++ < 5 && detail)
                        this.alert("出错啦，请把此信息截图给研发商\n" + msg + "\n" + detail.stack);
                };
            }
            else {
                Browser.window.onerror = null;
            }
        }
        static _runScript(script) {
            return Browser.window[Laya._evcode](script);
        }
        static enableDebugPanel(debugJsPath = "libs/laya.debugtool.js") {
            if (!window['Laya']["DebugPanel"]) {
                var script = Browser.createElement("script");
                script.onload = function () {
                    window['Laya']["DebugPanel"].enable();
                };
                script.src = debugJsPath;
                Browser.document.body.appendChild(script);
            }
            else {
                window['Laya']["DebugPanel"].enable();
            }
        }
        static addInitCallback(callback) {
            Laya._initCallbacks.push(callback);
        }
        static addBeforeInitCallback(callback) {
            Laya._beforeInitCallbacks.push(callback);
        }
        static addAfterInitCallback(callback) {
            Laya._afterInitCallbacks.push(callback);
        }
    }
    Laya.stage = null;
    Laya.systemTimer = null;
    Laya.physicsTimer = null;
    Laya.timer = null;
    Laya.loader = null;
    Laya._inited = false;
    Laya._initCallbacks = [];
    Laya._beforeInitCallbacks = [];
    Laya._afterInitCallbacks = [];
    Laya._evcode = "eva" + "l";
    Laya.isNativeRender_enable = false;
    ILaya.Laya = Laya;
    ILaya.Loader = Loader;
    ILaya.Context = Context;
    ILaya.Browser = Browser;
    var init = Laya.init;
    exports.stage = void 0;
    exports.systemTimer = void 0;
    exports.physicsTimer = void 0;
    exports.timer = void 0;
    exports.loader = void 0;
    exports.render = void 0;
    var alertGlobalError = Laya.alertGlobalError;
    var enableDebugPanel = Laya.enableDebugPanel;
    var addInitCallback = Laya.addInitCallback;
    var addBeforeInitCallback = Laya.addBeforeInitCallback;
    var addAfterInitCallback = Laya.addAfterInitCallback;

    class Texture2DArray extends BaseTexture {
        static get defaultTexture() {
            return this._defaultTexture;
        }
        static __init__() {
            if (LayaGL.renderEngine.getCapable(exports.RenderCapable.Texture3D)) {
                this._defaultTexture = new Texture2DArray(1, 1, 1, exports.TextureFormat.R8G8B8A8, false, false, false);
                this._defaultTexture.lock = true;
                this._defaultTexture.setPixelsData(new Uint8Array([255, 255, 255, 255]), false, false);
            }
        }
        constructor(width, height, depth, format, mipmap = true, canRead, sRGB = false) {
            super(width, height, format);
            this._dimension = exports.TextureDimension.Texture2DArray;
            this._gammaSpace = sRGB;
            this.depth = depth;
            let context = LayaGL.textureContext;
            this._texture = context.createTexture3DInternal(this._dimension, width, height, depth, format, mipmap, sRGB, false);
            return;
        }
        setImageData(sources, premultiplyAlpha, invertY) {
            let texture = this._texture;
            let context = LayaGL.textureContext;
            context.setTexture3DImageData(texture, sources, this.depth, premultiplyAlpha, invertY);
        }
        setPixelsData(source, premultiplyAlpha, invertY) {
            let texture = this._texture;
            let context = LayaGL.textureContext;
            context.setTexture3DPixelsData(texture, source, this.depth, premultiplyAlpha, invertY);
        }
        setSubPixelsData(xOffset, yOffset, zOffset, width, height, depth, pixels, mipmapLevel, generateMipmap, premultiplyAlpha, invertY) {
            let texture = this._texture;
            let context = LayaGL.textureContext;
            context.setTexture3DSubPixelsData(texture, pixels, mipmapLevel, generateMipmap, xOffset, yOffset, zOffset, width, height, depth, premultiplyAlpha, invertY);
        }
    }

    exports.TextureCubeFace = void 0;
    (function (TextureCubeFace) {
        TextureCubeFace[TextureCubeFace["PositiveX"] = 0] = "PositiveX";
        TextureCubeFace[TextureCubeFace["NegativeX"] = 1] = "NegativeX";
        TextureCubeFace[TextureCubeFace["PositiveY"] = 2] = "PositiveY";
        TextureCubeFace[TextureCubeFace["NegativeY"] = 3] = "NegativeY";
        TextureCubeFace[TextureCubeFace["PositiveZ"] = 4] = "PositiveZ";
        TextureCubeFace[TextureCubeFace["NegativeZ"] = 5] = "NegativeZ";
    })(exports.TextureCubeFace || (exports.TextureCubeFace = {}));
    const DEFAULT_PIXELS = new Uint8Array(4);
    class TextureCube extends BaseTexture {
        static get blackTexture() {
            return TextureCube._blackTexture;
        }
        static get grayTexture() {
            return TextureCube._grayTexture;
        }
        static get whiteTexture() {
            return TextureCube._whiteTexture;
        }
        static get errorTexture() {
            return TextureCube._errorTexture;
        }
        static __init__() {
            var blackTexture = new TextureCube(1, exports.TextureFormat.R8G8B8A8, false);
            var grayTexture = new TextureCube(1, exports.TextureFormat.R8G8B8A8, false);
            var writeTexture = new TextureCube(1, exports.TextureFormat.R8G8B8A8, false);
            var pixels = DEFAULT_PIXELS;
            pixels[0] = 0, pixels[1] = 0, pixels[2] = 0;
            pixels[3] = 255;
            blackTexture.setPixelsData([pixels, pixels, pixels, pixels, pixels, pixels], false, false);
            blackTexture.lock = true;
            pixels[0] = 128, pixels[1] = 128, pixels[2] = 128;
            pixels[3] = 255;
            grayTexture.setPixelsData([pixels, pixels, pixels, pixels, pixels, pixels], false, false);
            grayTexture.lock = true;
            pixels[0] = 255, pixels[1] = 255, pixels[2] = 255;
            pixels[3] = 255;
            writeTexture.setPixelsData([pixels, pixels, pixels, pixels, pixels, pixels], false, false);
            writeTexture.lock = true;
            TextureCube._grayTexture = grayTexture;
            TextureCube._blackTexture = blackTexture;
            TextureCube._whiteTexture = writeTexture;
            TextureCube._errorTexture = writeTexture;
        }
        constructor(size, format, mipmap = true, sRGB = false, premultiplyAlpha = false) {
            super(size, size, format);
            this._dimension = exports.TextureDimension.Cube;
            this._texture = LayaGL.textureContext.createTextureInternal(this._dimension, size, size, format, mipmap, sRGB, premultiplyAlpha);
            return;
        }
        setImageData(source, premultiplyAlpha, invertY) {
            let error = false;
            let k = source.findIndex(s => s != null);
            if (k != -1) {
                let img = source[k];
                if (!source.every(s => s != null && s.width == img.width && s.height == img.height))
                    error = true;
            }
            else
                error = true;
            let texture = this._texture;
            if (!error)
                LayaGL.textureContext.setCubeImageData(texture, source, premultiplyAlpha, invertY);
            else {
                let pixels = DEFAULT_PIXELS;
                LayaGL.textureContext.setCubePixelsData(texture, [pixels, pixels, pixels, pixels, pixels, pixels], premultiplyAlpha, invertY);
            }
        }
        setPixelsData(source, premultiplyAlpha, invertY) {
            let texture = this._texture;
            LayaGL.textureContext.setCubePixelsData(texture, source, premultiplyAlpha, invertY);
        }
        updateSubPixelsData(source, xOffset, yOffset, width, height, mipmapLevel, generateMipmap, premultiplyAlpha, invertY) {
            let texture = this._texture;
            LayaGL.textureContext.setCubeSubPixelData(texture, source, mipmapLevel, generateMipmap, xOffset, yOffset, width, height, premultiplyAlpha, invertY);
        }
        setDDSData(ddsInfo) {
            let texture = this._texture;
            LayaGL.textureContext.setCubeDDSData(texture, ddsInfo);
        }
        setKTXData(ktxInfo) {
            let texture = this._texture;
            LayaGL.textureContext.setCubeKTXData(texture, ktxInfo);
        }
        get defaultTexture() {
            return TextureCube.grayTexture;
        }
    }

    class Render {
        static customRequestAnimationFrame(value, loopFun) {
            Render._customRequestAnimationFrame = value;
            Render._loopFunction = loopFun;
        }
        static set customRenderEngine(engine) {
            Render._customEngine = engine;
        }
        static get customRenderEngine() {
            return Render._customEngine;
        }
        static gc() {
            if (LayaEnv.isConch) {
                window.gc({ type: 'major', execution: 'async' });
            }
        }
        constructor(width, height, mainCanv) {
            this._first = true;
            this._startTm = 0;
            this._timeId = 0;
            Render._Render = this;
            Render._mainCanvas = mainCanv;
            let source = Render._mainCanvas.source;
            source.id = "layaCanvas";
            source.width = width;
            source.height = height;
            if (LayaEnv.isConch) {
                document.body.appendChild(source);
                Render._mainCanvas.getContext("2d");
            }
            this.initRender(Render._mainCanvas, width, height);
            if (Config._enableWindowRAFFunction) {
                window.requestAnimationFrame(loop);
            }
            else {
                requestAnimationFrame(loop);
            }
            let me = this;
            performance.now();
            let fps = Config.FPS;
            let ifps = Render.ifps = 1000 / fps;
            function loop(stamp) {
                performance.now();
                if (me._first) {
                    me._startTm = Math.floor(stamp / ifps) * ifps;
                    me._first = false;
                }
                stamp -= me._startTm;
                let frm = Math.floor(stamp / ifps);
                let dfrm = frm - Render.lastFrm;
                if (dfrm > 0 || !Config.fixedFrames) {
                    Render.lastFrm = frm;
                    ILaya.stage._loop();
                }
                if (!!Render._customRequestAnimationFrame && !!Render._loopFunction) {
                    Render._customRequestAnimationFrame(Render._loopFunction);
                }
                else {
                    if (Config._enableWindowRAFFunction) {
                        window.requestAnimationFrame(loop);
                    }
                    else {
                        requestAnimationFrame(loop);
                    }
                }
            }
            ILaya.stage.on("visibilitychange", this, this._onVisibilitychange);
            LayaEnv.isConch && Laya.timer.frameOnce(2, null, Render.gc);
        }
        _onVisibilitychange() {
            if (!ILaya.stage.isVisibility) {
                this._timeId = window.setInterval(this._enterFrame, 1000);
            }
            else if (this._timeId != 0) {
                window.clearInterval(this._timeId);
            }
        }
        static vsyncTime() {
            return Render.lastFrm * Render.ifps;
        }
        initRender(canvas, w, h) {
            canvas.size(w, h);
            ShaderDefines2D.__init__();
            Context.__init__();
            var ctx = new Context();
            ctx.isMain = true;
            Render._context = ctx;
            canvas._setContext(ctx);
            Shader2D.__init__();
            BlendMode._init_();
            Texture2D.__init__();
            TextureCube.__init__();
            Texture2DArray.__init__();
            HalfFloatUtils.__init__();
            return true;
        }
        _enterFrame(e = null) {
            ILaya.stage._loop();
        }
        static get context() {
            return Render._context;
        }
        static get canvas() {
            return Render._mainCanvas.source;
        }
    }
    Render.lastFrm = 0;
    Render.ifps = 1000 / 60;

    const TypedArrayClasses = {
        "Int8Array": Int8Array,
        "Uint8Array": Uint8Array,
        "Int16Array": Int16Array,
        "Uint16Array": Uint16Array,
        "Int32Array": Int32Array,
        "Uint32Array": Uint32Array,
        "Float32Array": Float32Array,
        "Float64Array": Float64Array
    };
    var _errors;
    var _getNodeByRef;
    var _getNodeData;
    class SerializeUtil {
        static decodeObj(data, obj, options) {
            if (options) {
                _errors = options.outErrors;
                _getNodeByRef = options.getNodeByRef;
                _getNodeData = options.getNodeData;
            }
            else {
                _errors = null;
                _getNodeByRef = null;
                _getNodeData = null;
            }
            SerializeUtil.isDeserializing = true;
            try {
                return SerializeUtil._decodeObj(data, obj);
            }
            finally {
                SerializeUtil.isDeserializing = false;
            }
        }
        static _decodeObj(data, obj) {
            if (data == null)
                return null;
            else if (Array.isArray(data)) {
                let arr = [];
                for (let i = 0; i < data.length; i++) {
                    let v = data[i];
                    if (v != null) {
                        try {
                            arr[i] = SerializeUtil._decodeObj(v);
                        }
                        catch (error) {
                            if (_errors)
                                _errors.push(error);
                            arr[i] = null;
                        }
                    }
                    else
                        arr[i] = null;
                }
                return arr;
            }
            else if (typeof (data) === "object") {
                if (data._$uuid != null) {
                    let url = URL.getResURLByUUID(data._$uuid);
                    return ILaya.loader.getRes(url, SerializeUtil.getLoadTypeByEngineType(data._$type));
                }
                if (data._$ref != null) {
                    let node = _getNodeByRef === null || _getNodeByRef === void 0 ? void 0 : _getNodeByRef(data._$ref);
                    if (node && data._$type) {
                        let cls = ClassUtils.getClass(data._$type);
                        if (cls)
                            return node.getComponent(cls);
                        else
                            return null;
                    }
                    else
                        return node;
                }
                let type = data._$type;
                if (type === "any") {
                    if (data._$type)
                        return data.value;
                    else
                        return data;
                }
                let typedArray = TypedArrayClasses[type];
                if (typedArray != null) {
                    if (data._$type)
                        return new typedArray(data.value);
                    else
                        return new typedArray(data);
                }
                if (!obj) {
                    let cls = ClassUtils.getClass(type);
                    if (!cls) {
                        return null;
                    }
                    obj = new cls();
                }
                for (let key in data) {
                    if (key.startsWith("_$"))
                        continue;
                    let v = data[key];
                    if (v == null || typeof (v) !== "object" || Array.isArray(v)
                        || v._$type || v._$uuid || v._$ref) {
                        try {
                            let v2 = SerializeUtil._decodeObj(v);
                            obj[key] = v2;
                            if (v2 != null && v != null && v._$tmpl)
                                obj[v._$tmpl] = _getNodeData(v2);
                        }
                        catch (error) {
                            if (_errors)
                                _errors.push(error);
                        }
                    }
                    else {
                        let childObj = obj[key];
                        if (childObj) {
                            try {
                                SerializeUtil._decodeObj(v, childObj);
                            }
                            catch (error) {
                                if (_errors)
                                    _errors.push(error);
                            }
                        }
                    }
                }
                if (obj.onAfterDeserialize)
                    obj.onAfterDeserialize();
                return obj;
            }
            else
                return data;
        }
        static getLoadTypeByEngineType(type) {
            return Loader.assetTypeToLoadType[type];
        }
        static bakeOverrideData(overrideData) {
            let dataMap = null;
            for (let n = overrideData.length, i = n - 1; i >= 0; i--) {
                let arr = overrideData[i];
                if (arr && arr.length > 0) {
                    for (let d of arr) {
                        let od = d._$override || d._$parent;
                        let k;
                        if (Array.isArray(od))
                            k = od[n - i - 1];
                        else if (i == n - 1)
                            k = od;
                        if (k != null) {
                            if (!dataMap)
                                dataMap = {};
                            let arr2 = dataMap[k];
                            if (!arr2)
                                dataMap[k] = arr2 = [];
                            arr2.push(n - i, d);
                        }
                    }
                }
            }
            return dataMap;
        }
        static applyOverrideData(nodeData, overrideDataMap) {
            function test(obj) {
                if (overrideDataMap[obj._$id])
                    return true;
                let children = obj._$child;
                if (children && children.find(child => test(child)))
                    return true;
                return false;
            }
            function cloneTree(obj) {
                let ret = Object.assign({}, obj);
                let children = ret._$child;
                if (children)
                    ret._$child = children.map(c => cloneTree(c));
                let comps = ret._$comp;
                if (comps)
                    ret._$comp = comps.map(c => Object.assign({}, c));
                return ret;
            }
            function visit(data) {
                let children = data._$child;
                if (children) {
                    for (let child of children) {
                        if (child._$id)
                            visit(child);
                    }
                }
                let od = overrideDataMap[data._$id];
                if (od) {
                    for (let i = 0; i < od.length; i += 2) {
                        let j = od[i];
                        let e = od[i + 1];
                        let idPath;
                        if (idPath = e._$override) {
                            let toWrite;
                            if (Array.isArray(idPath)) {
                                if (j == idPath.length - 1) {
                                    let k = idPath[j];
                                    if (!children)
                                        data._$child = children = [];
                                    else
                                        toWrite = children.find(c => c._$override == k);
                                    if (!toWrite) {
                                        toWrite = { _$override: k };
                                        children.push(toWrite);
                                    }
                                }
                                else if (j < idPath.length - 1) {
                                    let k = idPath.slice(j);
                                    if (!children)
                                        data._$child = children = [];
                                    else {
                                        toWrite = children.find(c => {
                                            let o = c._$override;
                                            return Array.isArray(o) && arrayEquals(o, k);
                                        });
                                    }
                                    if (!toWrite) {
                                        toWrite = { _$override: k };
                                        children.push(toWrite);
                                    }
                                }
                                else
                                    toWrite = data;
                            }
                            else
                                toWrite = data;
                            mergeData(toWrite, e);
                            if (e._$comp) {
                                let comps = toWrite._$comp;
                                if (!comps)
                                    toWrite._$comp = comps = [];
                                for (let comp of e._$comp) {
                                    let typeOrId = comp._$type || comp._$override;
                                    let c = comps.find(c => c._$override == typeOrId || c._$type == typeOrId || c._$id == typeOrId);
                                    if (!c) {
                                        c = {};
                                        if (comp._$type)
                                            c._$type = typeOrId;
                                        else
                                            c._$override = typeOrId;
                                        comps.push(c);
                                    }
                                    mergeData(c, comp);
                                }
                            }
                        }
                        else if (idPath = e._$parent) {
                            if (!children)
                                data._$child = children = [];
                            let k;
                            if (j < idPath.length) {
                                if (j == idPath.length - 1)
                                    k = idPath[j];
                                else
                                    k = idPath.slice(j);
                                let toWrite = Object.assign({}, e);
                                toWrite._$parent = k;
                                children.push(toWrite);
                            }
                            else {
                                let toWrite = Object.assign({}, e);
                                delete toWrite._$parent;
                                if (data._$prefab) {
                                    children.push(toWrite);
                                }
                                else {
                                    delete toWrite._$index;
                                    if (e._$index < children.length)
                                        children.splice(e._$index, 0, toWrite);
                                    else
                                        children.push(toWrite);
                                }
                            }
                        }
                    }
                }
            }
            if (test(nodeData)) {
                nodeData = cloneTree(nodeData);
                visit(nodeData);
            }
            return nodeData;
        }
    }
    SerializeUtil.isDeserializing = false;
    function mergeData(target, overrided) {
        for (let k in overrided) {
            if (k.startsWith("_$"))
                continue;
            let v = overrided[k];
            if (v != null && typeof (v) === "object" && !Array.isArray(v) && !(v._$type || v._$uuid || v._$ref)) {
                let v2 = target[k];
                if (v2 != null && typeof (v2) === "object") {
                    target[k] = v2 = Object.assign({}, v2);
                    mergeData(v2, v);
                }
                else
                    target[k] = v;
            }
            else
                target[k] = v;
        }
    }
    function arrayEquals(a, b) {
        if (a.length === b.length) {
            for (var i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        }
        else {
            return false;
        }
    }

    class Input extends Text {
        constructor() {
            super();
            this._multiline = false;
            this._editable = true;
            this._maxChars = 0;
            this._type = "text";
            Input.IOS_IFRAME = (ILaya.Browser.onIOS && ILaya.Browser.window.top != ILaya.Browser.window.self);
            this._width = 100;
            this._height = 20;
            this.multiline = false;
            this.overflow = Text.SCROLL;
            this._promptColor = "#A9A9A9";
            this.on(Event.MOUSE_DOWN, this, this._onMouseDown);
            this.on(Event.UNDISPLAY, this, this._onUnDisplay);
        }
        static __init__() {
            Input._createInputElement();
            if (ILaya.Browser.onMobile) {
                var isTrue = false;
                if (ILaya.Browser.onMiniGame || ILaya.Browser.onBDMiniGame || ILaya.Browser.onQGMiniGame || ILaya.Browser.onKGMiniGame || ILaya.Browser.onVVMiniGame || ILaya.Browser.onAlipayMiniGame || ILaya.Browser.onQQMiniGame || ILaya.Browser.onBLMiniGame || ILaya.Browser.onTTMiniGame || ILaya.Browser.onHWMiniGame || ILaya.Browser.onTBMiniGame) {
                    isTrue = true;
                }
                Render.canvas.addEventListener(Input.IOS_IFRAME ? (isTrue ? "touchend" : "click") : "touchend", Input._popupInputMethod);
            }
            if (ILaya.Browser.onLayaRuntime && ILaya.Browser.onPC) {
                Render.canvas.addEventListener("click", Input._popupInputMethod);
            }
        }
        static _popupInputMethod(e) {
            if (!InputManager.isTextInputting)
                return;
            var input = Input.inputElement;
            input.focus();
        }
        static _createInputElement() {
            Input._initInput(Input.area = ILaya.Browser.createElement("textarea"));
            Input._initInput(Input.input = ILaya.Browser.createElement("input"));
            Input.inputContainer = ILaya.Browser.createElement("div");
            Input.inputContainer.style.position = "absolute";
            Input.inputContainer.style.zIndex = '1E5';
            ILaya.Browser.container.appendChild(Input.inputContainer);
            Input.inputContainer.setPos = function (x, y) {
                Input.inputContainer.style.left = x + 'px';
                Input.inputContainer.style.top = y + 'px';
            };
        }
        static _initInput(input) {
            var style = input.style;
            style.cssText = "position:absolute;overflow:hidden;resize:none;transform-origin:0 0;-webkit-transform-origin:0 0;-moz-transform-origin:0 0;-o-transform-origin:0 0;";
            style.resize = 'none';
            style.backgroundColor = 'transparent';
            style.border = 'none';
            style.outline = 'none';
            style.zIndex = '1';
            input.addEventListener('input', Input._processInputting);
            input.addEventListener('mousemove', Input._stopEvent, { passive: false });
            input.addEventListener('mousedown', Input._stopEvent, { passive: false });
            input.addEventListener('touchmove', Input._stopEvent, { passive: false });
            input.setFontFace = function (fontFace) { input.style.fontFamily = fontFace; };
            if (!(LayaEnv.isConch && !Input.isAppUseNewInput)) {
                input.setColor = function (color) { input.style.color = color; };
                input.setFontSize = function (fontSize) { input.style.fontSize = fontSize + 'px'; };
            }
        }
        static _processInputting(e) {
            var input = Input.inputElement.target;
            if (!input)
                return;
            var value = Input.inputElement.value;
            if (input._restrictPattern) {
                value = value.replace(/\u2006|\x27/g, "");
                if (input._restrictPattern.test(value)) {
                    value = value.replace(input._restrictPattern, "");
                    Input.inputElement.value = value;
                }
            }
            if (value == null)
                value = "";
            input._text = value;
            input.event(Event.INPUT);
        }
        static _stopEvent(e) {
            if (e.type == 'touchmove')
                e.preventDefault();
            e.stopPropagation && e.stopPropagation();
        }
        setSelection(startIndex, endIndex) {
            this.focus = true;
            Input.inputElement.selectionStart = startIndex;
            Input.inputElement.selectionEnd = endIndex;
        }
        get multiline() {
            return this._multiline;
        }
        set multiline(value) {
            this._multiline = value;
            if (!SerializeUtil.isDeserializing)
                this.valign = value ? "top" : "middle";
        }
        get nativeInput() {
            return this._multiline ? Input.area : Input.input;
        }
        _onUnDisplay(e = null) {
            this.focus = false;
        }
        _onMouseDown(e) {
            this.focus = true;
        }
        _syncInputTransform() {
            var inputElement = this.nativeInput;
            var transform = SpriteUtils.getTransformRelativeToWindow(this, this._padding[3], this._padding[0]);
            var inputWid = this._width - this._padding[1] - this._padding[3];
            var inputHei = this._height - this._padding[0] - this._padding[2];
            if (LayaEnv.isConch && !Input.isAppUseNewInput) {
                inputElement.setScale(transform.scaleX, transform.scaleY);
                inputElement.setSize(inputWid, inputHei);
                inputElement.setPos(transform.x, transform.y);
            }
            else {
                Input.inputContainer.style.transform = Input.inputContainer.style.webkitTransform = "scale(" + transform.scaleX + "," + transform.scaleY + ") rotate(" + (ILaya.stage.canvasDegree) + "deg)";
                inputElement.style.width = inputWid + 'px';
                inputElement.style.height = inputHei + 'px';
                Input.inputContainer.style.left = transform.x + 'px';
                Input.inputContainer.style.top = transform.y + 'px';
            }
        }
        select() {
            this.nativeInput.select();
        }
        get focus() {
            return this._focus;
        }
        set focus(value) {
            var input = this.nativeInput;
            if (this._focus !== value) {
                if (value) {
                    if (input.target) {
                        input.target._focusOut();
                    }
                    else {
                        this._setInputMethod();
                    }
                    input = this.nativeInput;
                    input.target = this;
                    this._focusIn();
                }
                else {
                    input.target = null;
                    this._focusOut();
                    ILaya.Browser.document.body.scrollTop = 0;
                    input.blur();
                    if (LayaEnv.isConch && !Input.isAppUseNewInput)
                        input.setPos(-10000, -10000);
                    else if (Input.inputContainer.contains(input))
                        Input.inputContainer.removeChild(input);
                }
            }
        }
        _setInputMethod() {
            Input.input.parentElement && (Input.inputContainer.removeChild(Input.input));
            Input.area.parentElement && (Input.inputContainer.removeChild(Input.area));
            if (ILaya.Browser.onAndroid) {
                Input.input = Input.inputElement = ILaya.Browser.createElement('input');
                Input._initInput(Input.input);
            }
            Input.inputElement = (this._multiline ? Input.area : Input.input);
            Input.inputContainer.appendChild(Input.inputElement);
            if (Text.RightToLeft) {
                Input.inputElement.style.direction = "rtl";
            }
        }
        _focusIn() {
            InputManager.isTextInputting = true;
            var input = this.nativeInput;
            Input.input && (Input.input.type = this._type);
            this._focus = true;
            var cssStyle = input.style;
            cssStyle.whiteSpace = (this.wordWrap ? "pre-wrap" : "nowrap");
            this._setPromptColor();
            input.readOnly = !this._editable;
            if (LayaEnv.isConch && !Input.isAppUseNewInput) {
                input.setType(this._type);
                input.setForbidEdit(!this._editable);
            }
            input.maxLength = this._maxChars <= 0 ? 1E5 : this._maxChars;
            input.value = this._text;
            input.placeholder = this._prompt;
            ILaya.stage.off(Event.KEY_DOWN, this, this._onKeyDown);
            ILaya.stage.on(Event.KEY_DOWN, this, this._onKeyDown);
            ILaya.stage.focus = this;
            this.event(Event.FOCUS);
            if (ILaya.Browser.onPC)
                input.focus();
            if (!(LayaEnv.isConch && Input.isAppUseNewInput) && !ILaya.Browser.onMiniGame && !ILaya.Browser.onBDMiniGame && !ILaya.Browser.onQGMiniGame && !ILaya.Browser.onKGMiniGame && !ILaya.Browser.onVVMiniGame && !ILaya.Browser.onAlipayMiniGame && !ILaya.Browser.onQQMiniGame && !ILaya.Browser.onBLMiniGame && !ILaya.Browser.onTTMiniGame && !ILaya.Browser.onHWMiniGame && !ILaya.Browser.onTBMiniGame) {
                if (this._bgDrawCmd)
                    this.graphics.removeCmd(this._bgDrawCmd);
                this.graphics.clear(true);
                this.drawBg();
                this._hideText = true;
            }
            input.setColor(this.color);
            input.setFontSize(this.fontSize);
            input.setFontFace(this._realFont);
            if (LayaEnv.isConch && !Input.isAppUseNewInput) {
                input.setMultiAble && input.setMultiAble(this._multiline);
                input.setFont(this._realFont);
            }
            cssStyle.lineHeight = (this.leading + this.fontSize) + "px";
            cssStyle.fontStyle = (this.italic ? "italic" : "normal");
            cssStyle.fontWeight = (this.bold ? "bold" : "normal");
            cssStyle.textAlign = this.align;
            cssStyle.padding = "0 0";
            this._syncInputTransform();
            if (!LayaEnv.isConch && ILaya.Browser.onPC)
                ILaya.systemTimer.frameLoop(1, this, this._syncInputTransform);
        }
        _setPromptColor() {
            Input.promptStyleDOM = ILaya.Browser.getElementById("promptStyle");
            if (!Input.promptStyleDOM) {
                Input.promptStyleDOM = ILaya.Browser.createElement("style");
                Input.promptStyleDOM.setAttribute("id", "promptStyle");
                ILaya.Browser.document.head.appendChild(Input.promptStyleDOM);
            }
            Input.promptStyleDOM.innerText = "input::-webkit-input-placeholder, textarea::-webkit-input-placeholder {" + "color:" + this._promptColor + "}" + "input:-moz-placeholder, textarea:-moz-placeholder {" + "color:" + this._promptColor + "}" + "input::-moz-placeholder, textarea::-moz-placeholder {" + "color:" + this._promptColor + "}" + "input:-ms-input-placeholder, textarea:-ms-input-placeholder {" + "color:" + this._promptColor + "}";
        }
        _focusOut() {
            if (!InputManager.isTextInputting)
                return;
            if (!InputManager.isiOSWKwebView)
                InputManager.isTextInputting = false;
            this._focus = false;
            this._hideText = false;
            this.text = this.nativeInput.value;
            this.markChanged();
            this.typeset();
            ILaya.stage.off(Event.KEY_DOWN, this, this._onKeyDown);
            ILaya.stage.focus = null;
            this.event(Event.BLUR);
            this.event(Event.CHANGE);
            if (LayaEnv.isConch && !Input.isAppUseNewInput)
                this.nativeInput.blur();
            ILaya.Browser.onPC && ILaya.systemTimer.clear(this, this._syncInputTransform);
        }
        _onKeyDown(e) {
            if (e.keyCode === 13) {
                if (ILaya.Browser.onMobile && !this._multiline)
                    this.focus = false;
                this.event(Event.ENTER);
            }
        }
        miniGameTxt(value) {
            value += '';
            if (!this._multiline)
                value = value.replace(/\r?\n/g, '');
            this.text = value;
        }
        get text() {
            if (this._focus)
                return this.nativeInput.value;
            else
                return super.text;
        }
        set text(value) {
            if (value == null)
                value = "";
            else if (typeof (value) !== "string")
                value = '' + value;
            if (this._focus) {
                this.nativeInput.value = value;
                this.event(Event.CHANGE);
            }
            else {
                if (!this._multiline)
                    value = value.replace(/\r?\n/g, '');
                super.text = value;
            }
        }
        set_color(value) {
            if (this._focus)
                this.nativeInput.setColor(value);
            super.set_color(value);
        }
        get bgColor() {
            return super.bgColor;
        }
        set bgColor(value) {
            super.bgColor = value;
            if (LayaEnv.isConch && !Input.isAppUseNewInput)
                this.nativeInput.setBgColor(value);
        }
        get restrict() {
            return this._restrict;
        }
        set restrict(value) {
            this._restrict = value;
            if (value) {
                value = "[^" + value + "]";
                if (value.indexOf("^^") > -1)
                    value = value.replace("^^", "");
                this._restrictPattern = new RegExp(value, "g");
            }
            else
                this._restrictPattern = null;
        }
        get editable() {
            return this._editable;
        }
        set editable(value) {
            this._editable = value;
            if (LayaEnv.isConch && !Input.isAppUseNewInput) {
                Input.input.setForbidEdit(!value);
            }
        }
        get maxChars() {
            return this._maxChars;
        }
        set maxChars(value) {
            this._maxChars = value;
        }
        get prompt() {
            return this._prompt;
        }
        set prompt(value) {
            var _a;
            value = ((_a = Text.langPacks) === null || _a === void 0 ? void 0 : _a[value]) || value;
            if (this._prompt != value) {
                this._prompt = value;
                this.markChanged();
            }
        }
        get promptColor() {
            return this._promptColor;
        }
        set promptColor(value) {
            if (this._promptColor != value) {
                this._promptColor = value;
                this.markChanged();
            }
        }
        get type() {
            return this._type;
        }
        set type(value) {
            this._asPassword = value === "password";
            this._type = value;
            this.markChanged();
        }
    }
    Input.TYPE_TEXT = "text";
    Input.TYPE_PASSWORD = "password";
    Input.TYPE_EMAIL = "email";
    Input.TYPE_URL = "url";
    Input.TYPE_NUMBER = "number";
    Input.TYPE_RANGE = "range";
    Input.TYPE_DATE = "date";
    Input.TYPE_MONTH = "month";
    Input.TYPE_WEEK = "week";
    Input.TYPE_TIME = "time";
    Input.TYPE_DATE_TIME = "datetime";
    Input.TYPE_DATE_TIME_LOCAL = "datetime-local";
    Input.TYPE_SEARCH = "search";
    Input.IOS_IFRAME = false;
    Input.isAppUseNewInput = false;

    class Widget extends Component {
        constructor() {
            super();
            this._top = null;
            this._bottom = null;
            this._left = null;
            this._right = null;
            this._centerX = null;
            this._centerY = null;
            this.runInEditor = true;
            this.hideFlags |= HideFlags.HideAndDontSave;
        }
        onReset() {
            this._top = this._bottom = this._left = this._right = this._centerX = this._centerY = null;
        }
        _onEnable() {
            if (this.owner.parent)
                this._onAdded();
            else
                this.owner.once(Event.ADDED, this, this._onAdded);
        }
        _onDisable() {
            this.owner.off(Event.ADDED, this, this._onAdded);
            if (this.owner.parent)
                this.owner.parent.off(Event.RESIZE, this, this._onParentResize);
        }
        _onAdded() {
            if (this.owner.parent)
                this.owner.parent.on(Event.RESIZE, this, this._onParentResize);
            this.resetLayoutX();
            this.resetLayoutY();
        }
        _onParentResize() {
            var flagX = this.resetLayoutX();
            var flagY = this.resetLayoutY();
            if (flagX || flagY)
                this.owner.event(Event.RESIZE);
        }
        resetLayoutX() {
            var owner = this.owner;
            if (!owner)
                return false;
            var parent = owner.parent;
            if (parent) {
                if (this._centerX != null) {
                    owner.x = Math.round((parent.width - owner.displayWidth) * 0.5 + this._centerX + owner.pivotX * owner.scaleX);
                }
                else if (this._left != null) {
                    owner.x = Math.round(this._left + owner.pivotX * owner.scaleX);
                    if (this._right != null) {
                        if (!parent._width)
                            return false;
                        var temp = (parent._width - this._left - this._right) / (owner.scaleX || 0.01);
                        if (temp != owner._width) {
                            owner.width = temp;
                            return true;
                        }
                    }
                }
                else if (this._right != null) {
                    owner.x = Math.round(parent.width - owner.displayWidth - this._right + owner.pivotX * owner.scaleX);
                }
            }
            return false;
        }
        resetLayoutY() {
            var owner = this.owner;
            if (!owner)
                return false;
            var parent = owner.parent;
            if (parent) {
                if (this._centerY != null) {
                    owner.y = Math.round((parent.height - owner.displayHeight) * 0.5 + this._centerY + owner.pivotY * owner.scaleY);
                }
                else if (this._top != null) {
                    owner.y = Math.round(this._top + owner.pivotY * owner.scaleY);
                    if (this._bottom != null) {
                        if (!parent._height)
                            return false;
                        var temp = (parent._height - this._top - this._bottom) / (owner.scaleY || 0.01);
                        if (temp != owner._height) {
                            owner.height = temp;
                            return true;
                        }
                    }
                }
                else if (this._bottom != null) {
                    owner.y = Math.round(parent.height - owner.displayHeight - this._bottom + owner.pivotY * owner.scaleY);
                }
            }
            return false;
        }
        resetLayout() {
            if (this.owner) {
                this.resetLayoutX();
                this.resetLayoutY();
            }
        }
        get top() {
            return this._top;
        }
        set top(value) {
            if (isNaN(value))
                value = null;
            if (this._top != value) {
                this._top = value;
                this.resetLayoutY();
            }
        }
        get bottom() {
            return this._bottom;
        }
        set bottom(value) {
            if (isNaN(value))
                value = null;
            if (this._bottom != value) {
                this._bottom = value;
                this.resetLayoutY();
            }
        }
        get left() {
            return this._left;
        }
        set left(value) {
            if (isNaN(value))
                value = null;
            if (this._left != value) {
                this._left = value;
                this.resetLayoutX();
            }
        }
        get right() {
            return this._right;
        }
        set right(value) {
            if (isNaN(value))
                value = null;
            if (this._right != value) {
                this._right = value;
                this.resetLayoutX();
            }
        }
        get centerX() {
            return this._centerX;
        }
        set centerX(value) {
            if (isNaN(value))
                value = null;
            if (this._centerX != value) {
                this._centerX = value;
                this.resetLayoutX();
            }
        }
        get centerY() {
            return this._centerY;
        }
        set centerY(value) {
            if (isNaN(value))
                value = null;
            if (this._centerY != value) {
                this._centerY = value;
                this.resetLayoutY();
            }
        }
    }
    Widget.EMPTY = null;
    Widget.EMPTY = new Widget();

    class Prefab extends Resource {
        constructor(version) {
            super();
            this.fromDCC = false;
            this.version = version;
            this._traceDeps = true;
        }
        create(options, errors) {
            if (this.json)
                return HierarchyLoader.legacySceneOrPrefab.createByData(null, this.json);
            else
                return null;
        }
    }
    var HierarchyResource = Prefab;

    class PrefabImpl extends Prefab {
        constructor(api, data, version) {
            super(version);
            this.api = api;
            this.data = data;
        }
        create(options, errors) {
            let ret = this.api.parse(this.data, options, errors);
            if (Array.isArray(ret)) {
                if (ret.length == 1) {
                    ret[0].url = this.url;
                }
                return ret[0];
            }
            else {
                ret.url = this.url;
                return ret;
            }
        }
    }

    class HierarchyParser {
        static parse(data, options, errors) {
            let printErrors = errors == null;
            errors = errors || [];
            let nodeMap = {};
            let dataList = [];
            let allNodes = [];
            let outNodes = [];
            let scene;
            let inPrefab;
            let prefabNodeDict;
            let skinBaseUrl;
            let overrideData;
            if (options) {
                inPrefab = options.inPrefab;
                if (inPrefab)
                    prefabNodeDict = options.prefabNodeDict;
                skinBaseUrl = options.skinBaseUrl;
                overrideData = options.overrideData;
            }
            function createChildren(data, prefab) {
                for (let child of data._$child) {
                    if (child._$child) {
                        let node = createNode(child, prefab);
                        createChildren(child, child._$prefab ? node : prefab);
                        dataList.push(child);
                        allNodes.push(node);
                    }
                    else {
                        let node = createNode(child, prefab);
                        dataList.push(child);
                        allNodes.push(node);
                    }
                }
            }
            function createNode(nodeData, prefab, runtime) {
                let node;
                let pstr;
                if (pstr = nodeData._$override) {
                    if (prefab && prefabNodeDict) {
                        if (Array.isArray(pstr)) {
                            node = prefab;
                            for (let i = 0, n = pstr.length; i < n; i++) {
                                let map = prefabNodeDict.get(node);
                                node = map === null || map === void 0 ? void 0 : map[pstr[i]];
                                if (!node)
                                    break;
                            }
                        }
                        else {
                            let map = prefabNodeDict.get(prefab);
                            if (map)
                                node = map[nodeData._$override];
                        }
                    }
                }
                else {
                    if (pstr = nodeData._$prefab) {
                        let res = Loader.getRes(URL.getResURLByUUID(pstr), Loader.HIERARCHY);
                        if (res) {
                            if (!prefabNodeDict)
                                prefabNodeDict = new Map();
                            let overrideData2 = [];
                            let testId = nodeData._$id;
                            if (overrideData) {
                                for (let i = 0, n = overrideData.length; i < n; i++) {
                                    let arr = overrideData[i];
                                    if (arr && arr.length > 0) {
                                        overrideData2[i] = arr.filter(d => {
                                            let od = d._$override || d._$parent;
                                            return Array.isArray(od) && od.length > n - i && od[n - i - 1] == testId;
                                        });
                                    }
                                    else
                                        overrideData2[i] = arr;
                                }
                            }
                            overrideData2.push(nodeData._$child);
                            node = res.create({ inPrefab: true, prefabNodeDict: prefabNodeDict, overrideData: overrideData2 }, errors);
                        }
                    }
                    else if (pstr = nodeData._$type) {
                        let cls = ClassUtils.getClass(runtime || pstr);
                        if (cls) {
                            try {
                                node = new cls();
                                if (runtime != null && !(node instanceof Node)) {
                                    errors.push(new Error(`runtime class invalid - '${runtime}', must derive from Node`));
                                    node = null;
                                }
                            }
                            catch (err) {
                                errors.push(err);
                            }
                        }
                        else {
                            errors.push(new Error(`missing node type '${runtime || pstr}' (in ${nodeData.name || 'noname'})`));
                        }
                    }
                    if (node)
                        nodeMap[nodeData._$id] = node;
                }
                return node;
            }
            function getNodeByRef(idPath) {
                if (Array.isArray(idPath)) {
                    let prefab = nodeMap[idPath[0]];
                    if (prefab && idPath.length > 1)
                        return findNodeInPrefab(prefab, idPath, 1);
                    else
                        return prefab;
                }
                else
                    return nodeMap[idPath];
            }
            function findNodeInPrefab(prefab, idPath, startIndex = 0) {
                if (!idPath)
                    return prefab;
                let map = prefabNodeDict === null || prefabNodeDict === void 0 ? void 0 : prefabNodeDict.get(prefab);
                if (!map)
                    return null;
                if (Array.isArray(idPath)) {
                    let node;
                    for (let i = startIndex, n = idPath.length; i < n; i++) {
                        if (!map)
                            return null;
                        node = map[idPath[i]];
                        if (!node)
                            break;
                        map = prefabNodeDict.get(node);
                    }
                    return node;
                }
                else
                    return map[idPath];
            }
            let bakedOverrideData;
            function getNodeData(node) {
                node.visible = false;
                let i = allNodes.indexOf(node);
                let nodeData = dataList[i];
                if (!overrideData)
                    return nodeData;
                if (bakedOverrideData === undefined)
                    bakedOverrideData = SerializeUtil.bakeOverrideData(overrideData);
                if (bakedOverrideData)
                    return SerializeUtil.applyOverrideData(nodeData, bakedOverrideData);
                else
                    return nodeData;
            }
            let runtime;
            if (data._$type || data._$prefab) {
                runtime = data._$runtime;
                if (runtime && runtime.startsWith("res://"))
                    runtime = runtime.substring(6);
                let node = createNode(data, null, runtime);
                if (node) {
                    if (data._$child)
                        createChildren(data, data._$prefab ? node : null);
                    dataList.push(data);
                    allNodes.push(node);
                    if (node instanceof Scene)
                        scene = node;
                }
            }
            else {
                if (data._$child)
                    createChildren(data, null);
            }
            let cnt = dataList.length;
            let k = 0;
            let outNodeData = [];
            for (let i = 0; i < cnt; i++) {
                let nodeData = dataList[i];
                let node = allNodes[i];
                let children = nodeData._$child;
                if (children) {
                    let num = children.length;
                    if (node) {
                        if (nodeData._$prefab) {
                            for (let j = 0; j < num; j++) {
                                let m = k - num + j;
                                let n = outNodes[m];
                                if (n && !n.parent) {
                                    let nodeData2 = outNodeData[m];
                                    let parentNode = findNodeInPrefab(node, nodeData2._$parent);
                                    if (parentNode) {
                                        let pos = nodeData2._$index;
                                        if (pos != null && pos < parentNode.numChildren)
                                            parentNode.addChildAt(n, pos);
                                        else
                                            parentNode.addChild(n);
                                    }
                                    else {
                                        node.addChildAt(n, 0);
                                    }
                                }
                            }
                        }
                        else {
                            for (let j = 0; j < num; j++) {
                                let n = outNodes[k - num + j];
                                if (n) {
                                    if (node === scene && n._is3D)
                                        scene._scene3D = n;
                                    else
                                        node.addChild(n);
                                }
                            }
                        }
                    }
                    k -= num;
                }
                outNodes[k] = node;
                outNodeData[k] = nodeData;
                k++;
            }
            outNodes.length = k;
            outNodes = outNodes.filter(n => n != null);
            let topNode = outNodes[0];
            let compInitList = [];
            for (let i = 0; i < cnt; i++) {
                let components = dataList[i]._$comp;
                if (!components)
                    continue;
                let node = allNodes[i];
                if (!node)
                    continue;
                for (let compData of components) {
                    let comp;
                    let typeOrId = compData._$override;
                    if (compData._$override) {
                        let cls = ClassUtils.getClass(typeOrId);
                        if (cls)
                            comp = node.getComponent(cls);
                        else
                            comp = node.components.find(comp => comp._extra.storeId == typeOrId);
                    }
                    else {
                        let cls = ClassUtils.getClass(compData._$type);
                        if (cls) {
                            if (!compData._$id)
                                comp = node.getComponent(cls);
                            if (!comp) {
                                try {
                                    comp = node.addComponent(cls);
                                    comp._extra.storeId = compData._$id;
                                }
                                catch (err) {
                                    errors.push(err);
                                }
                            }
                        }
                        else
                            errors.push(new Error(`missing component type '${compData._$type}' (in ${dataList[i].name || 'noname'})`));
                    }
                    if (comp)
                        compInitList.push(compData, comp);
                }
            }
            const decodeOptions = { outErrors: errors, getNodeByRef, getNodeData };
            for (let i = 0; i < cnt; i++) {
                let nodeData = dataList[i];
                let node = allNodes[i];
                if (node) {
                    if (skinBaseUrl != null && (node instanceof Sprite))
                        node._skinBaseUrl = skinBaseUrl;
                    SerializeUtil.decodeObj(nodeData, node, decodeOptions);
                    if (runtime && nodeData._$var && node.name) {
                        try {
                            topNode[node.name] = node;
                        }
                        catch (err) {
                            errors.push(err);
                        }
                    }
                }
            }
            cnt = compInitList.length;
            for (let i = 0; i < cnt; i += 2) {
                SerializeUtil.decodeObj(compInitList[i], compInitList[i + 1], decodeOptions);
            }
            if (inPrefab && prefabNodeDict && topNode)
                prefabNodeDict.set(topNode, nodeMap);
            if (printErrors && errors.length > 0)
                errors.forEach(err => console.error(err));
            return outNodes;
        }
        static collectResourceLinks(data, basePath) {
            let test = {};
            let innerUrls = [];
            function addInnerUrl(url, type) {
                if (!url)
                    return "";
                let entry = test[url];
                if (entry === undefined) {
                    let url2;
                    if (Utils.isUUID(url))
                        url2 = "res://" + url;
                    else
                        url2 = URL.join(basePath, url);
                    innerUrls.push({ url: url2, type: type });
                    test[url] = entry = [url2, type];
                }
                else if (entry.indexOf(type, 1) == -1) {
                    entry.push(type);
                    innerUrls.push({ url: entry[0], type: type });
                }
                return entry[0];
            }
            let type;
            function checkData(data) {
                if (data._$uuid != null) {
                    data._$uuid = addInnerUrl(data._$uuid, Loader.assetTypeToLoadType[data._$type]);
                    return;
                }
                if (data._$prefab != null)
                    data._$prefab = addInnerUrl(data._$prefab, Loader.HIERARCHY);
                else if ((type = data._$type) != null) {
                    if (type.endsWith(".bp"))
                        addInnerUrl(type, null);
                    else if (LayaEnv.isPreview && Utils.isUUID(type)) {
                        let cls = ClassUtils.getClass(type);
                        if (cls == null || cls._$loadable)
                            addInnerUrl("res://" + type, null);
                    }
                }
                check(data);
            }
            function check(data) {
                for (let key in data) {
                    let child = data[key];
                    if (child == null)
                        continue;
                    if (Array.isArray(child)) {
                        for (let item of child) {
                            if (item == null)
                                continue;
                            if (typeof (item) === "object") {
                                checkData(item);
                            }
                        }
                    }
                    else if (typeof (child) === "object") {
                        checkData(child);
                    }
                }
            }
            check(data);
            if (data._$preloads) {
                let types = data._$preloadTypes;
                let pi = 0;
                for (let url of data._$preloads) {
                    if (types && types[pi])
                        addInnerUrl(url, Loader.assetTypeToLoadType[types[pi]]);
                    else
                        innerUrls.push(url);
                    pi++;
                }
            }
            return innerUrls;
        }
    }

    class HierarchyLoader {
        load(task) {
            let url = task.url;
            let fromDCC = task.ext == "gltf" || task.ext == "fbx" || task.ext == "glb" || task.ext == "obj";
            if (fromDCC)
                url = AssetDb.inst.getSubAssetURL(url, task.uuid, "0", "lh");
            return task.loader.fetch(url, "json", task.progress.createCallback(0.2), task.options).then(data => {
                if (!data)
                    return null;
                if (data._$ver != null)
                    return this._load(HierarchyLoader.v3, task, data, 3, fromDCC);
                else if (task.ext == "ls" || task.ext == "lh")
                    return this._load(HierarchyLoader.v2, task, data, 2, fromDCC);
                else if (task.ext == "scene" || task.ext == "prefab")
                    return this._load(HierarchyLoader.legacySceneOrPrefab, task, data, 2, fromDCC);
                else
                    return null;
            });
        }
        _load(api, task, data, version, fromDCC) {
            let basePath = URL.getPath(task.url);
            let links = api.collectResourceLinks(data, basePath);
            let options = Object.assign({}, task.options);
            options.initiator = task;
            delete options.cache;
            delete options.ignoreCache;
            return task.loader.load(links, options, task.progress.createCallback()).then((resArray) => {
                let res = new PrefabImpl(api, data, version);
                res.fromDCC = fromDCC;
                res.addDeps(resArray);
                return res;
            });
        }
    }
    HierarchyLoader.v3 = HierarchyParser;
    HierarchyLoader.v2 = null;
    Loader.registerLoader(["lh", "ls", "scene", "prefab"], HierarchyLoader, Loader.HIERARCHY);

    class Scene extends Sprite {
        constructor(createChildren = true) {
            super();
            this.autoDestroyAtClosed = false;
            this._viewCreated = false;
            this._timer = ILaya.timer;
            this._widget = Widget.EMPTY;
            this._scene = this;
            if (createChildren)
                this.createChildren();
            this._shaderData = LayaGL.renderDeviceFactory.createShaderData(null);
        }
        createChildren() {
        }
        static setUIMap(url) {
            let uimap = ILaya.loader.getRes(url);
            if (uimap) {
                for (let key in uimap) {
                    ILaya.Loader.loadedMap[key + ".scene"] = uimap[key];
                }
            }
            else {
                throw "请提前加载uimap的json，再使用该接口设置！";
            }
        }
        loadScene(path) {
            Scene.unDestroyedScenes.add(this);
            let url = path.indexOf(".") > -1 ? path : path + ".scene";
            let content = ILaya.loader.getRes(url);
            if (content) {
                if (!this._viewCreated) {
                    content.create({ root: this });
                    this._viewCreated = true;
                    Scene.unDestroyedScenes.add(this);
                }
            }
            else {
                this._setBit(NodeFlags.NOT_READY, true);
                ILaya.loader.load(url, null, value => {
                    if (Scene._loadPage)
                        Scene._loadPage.event("progress", value);
                }).then((content) => {
                    if (!content)
                        throw "Can not find scene:" + path;
                    if (!this._viewCreated) {
                        this.url = url;
                        Scene.hideLoadingPage();
                        content.create({ root: this });
                        this._viewCreated = true;
                        Scene.unDestroyedScenes.add(this);
                    }
                    else
                        this._setBit(NodeFlags.NOT_READY, false);
                });
            }
        }
        createView(view) {
            if (view && !this._viewCreated) {
                this._viewCreated = true;
                HierarchyLoader.legacySceneOrPrefab.createByData(this, view);
            }
        }
        getNodeByID(id) {
            if (this._idMap)
                return this._idMap[id];
            return null;
        }
        open(closeOther = true, param = null) {
            if (closeOther)
                Scene.closeAll();
            Scene.root.addChild(this);
            if (this._scene3D)
                ILaya.stage.addChildAt(this._scene3D, 0);
            this.onOpened(param);
        }
        onOpened(param) {
        }
        close(type = null) {
            this.onClosed(type);
            if (this.autoDestroyAtClosed) {
                this.destroy();
                if (this._scene3D)
                    this._scene3D.destroy();
            }
            else {
                this.removeSelf();
                if (this._scene3D)
                    this._scene3D.removeSelf();
            }
        }
        onClosed(type = null) {
        }
        destroy(destroyChild = true) {
            super.destroy(destroyChild);
            if (this._scene3D) {
                this._scene3D.destroy();
                this._scene3D = null;
            }
            this._idMap = null;
            Scene.unDestroyedScenes.delete(this);
        }
        get_width() {
            if (this._isWidthSet)
                return this._width;
            var max = 0;
            for (var i = this.numChildren - 1; i > -1; i--) {
                var comp = this.getChildAt(i);
                if (comp._visible) {
                    max = Math.max(comp._x + comp.width * comp.scaleX, max);
                }
            }
            return max;
        }
        get_height() {
            if (this._isHeightSet)
                return this._height;
            var max = 0;
            for (var i = this.numChildren - 1; i > -1; i--) {
                var comp = this.getChildAt(i);
                if (comp._visible) {
                    max = Math.max(comp._y + comp.height * comp.scaleY, max);
                }
            }
            return max;
        }
        get timer() {
            return this._timer;
        }
        set timer(value) {
            this._timer = value;
        }
        get scene3D() {
            return this._scene3D;
        }
        get sceneShaderData() {
            return this._shaderData;
        }
        get top() {
            return this._widget.top;
        }
        set top(value) {
            if (value != this._widget.top) {
                this._getWidget().top = value;
            }
        }
        get bottom() {
            return this._widget.bottom;
        }
        set bottom(value) {
            if (value != this._widget.bottom) {
                this._getWidget().bottom = value;
            }
        }
        get left() {
            return this._widget.left;
        }
        set left(value) {
            if (value != this._widget.left) {
                this._getWidget().left = value;
            }
        }
        get right() {
            return this._widget.right;
        }
        set right(value) {
            if (value != this._widget.right) {
                this._getWidget().right = value;
            }
        }
        get centerX() {
            return this._widget.centerX;
        }
        set centerX(value) {
            if (value != this._widget.centerX) {
                this._getWidget().centerX = value;
            }
        }
        get centerY() {
            return this._widget.centerY;
        }
        set centerY(value) {
            if (value != this._widget.centerY) {
                this._getWidget().centerY = value;
            }
        }
        render(ctx, x, y) {
            Render2DSimple.rendercontext2D.sceneData = this._shaderData;
            super.render(ctx, x, y);
            Render2DSimple.rendercontext2D.sceneData = null;
        }
        _shouldRefreshLayout() {
            super._shouldRefreshLayout();
            this.callLater(this._sizeChanged);
        }
        _sizeChanged() {
            this.event(Event.RESIZE);
            if (this._widget !== Widget.EMPTY)
                this._widget.resetLayout();
        }
        freshLayout() {
            if (this._widget != Widget.EMPTY) {
                this._widget.resetLayout();
            }
        }
        _getWidget() {
            this._widget === Widget.EMPTY && (this._widget = this.addComponent(Widget));
            return this._widget;
        }
        static get root() {
            let root = Scene._root;
            if (!root) {
                root = Scene._root = ILaya.stage.addChild(new Sprite());
                root.name = "root";
                root.mouseThrough = true;
                ILaya.stage.on("resize", null, () => {
                    root.size(ILaya.stage.width, ILaya.stage.height);
                    root.event(Event.RESIZE);
                });
                root.size(ILaya.stage.width, ILaya.stage.height);
                root.event(Event.RESIZE);
            }
            return root;
        }
        static load(url, complete = null, progress = null) {
            return ILaya.loader.load(url, null, value => {
                if (Scene._loadPage)
                    Scene._loadPage.event("progress", value);
                progress && progress.runWith(value);
            }).then((content) => {
                if (!content)
                    throw "Can not find scene:" + url;
                let scene;
                let errors = [];
                let ret = content.create(null, errors);
                if (errors.length > 0)
                    console.warn(`Error loading ${url}: \n${errors.join("\n")}`);
                if (ret instanceof Scene)
                    scene = ret;
                else if (ret._is3D) {
                    scene = new Scene();
                    scene.left = scene.right = scene.top = scene.bottom = 0;
                    scene._scene3D = ret;
                }
                else
                    throw "Not a scene:" + url;
                scene._viewCreated = true;
                if (scene._scene3D)
                    scene._scene3D._scene2D = scene;
                Scene.unDestroyedScenes.add(scene);
                Scene.hideLoadingPage();
                complete && complete.runWith(scene);
                return scene;
            });
        }
        static open(url, closeOther = true, param = null, complete = null, progress = null) {
            if (param instanceof Handler) {
                var temp = complete;
                complete = param;
                param = temp;
            }
            Scene.showLoadingPage();
            return Scene.load(url, Handler.create(null, this._onSceneLoaded, [closeOther, complete, param]), progress);
        }
        static _onSceneLoaded(closeOther, complete, param, scene) {
            scene.open(closeOther, param);
            if (complete)
                complete.runWith(scene);
        }
        static close(url, name) {
            let flag = false;
            for (let scene of Scene.unDestroyedScenes) {
                if (scene && scene.parent && scene.url === url && (name == null || scene.name == name)) {
                    scene.close();
                    flag = true;
                    break;
                }
            }
            return flag;
        }
        static closeAll() {
            let root = Scene.root;
            for (let i = 0, n = root.numChildren; i < n; i++) {
                var scene = root.getChildAt(0);
                if (scene instanceof Scene)
                    scene.close();
                else
                    scene.removeSelf();
            }
        }
        static destroy(url, name) {
            let flag = false;
            for (let scene of Scene.unDestroyedScenes) {
                if (scene.url === url && (name == null || scene.name == name) && !scene._destroyed) {
                    scene.destroy();
                    flag = true;
                    break;
                }
            }
            return flag;
        }
        static gc() {
            Resource.destroyUnusedResources();
        }
        static setLoadingPage(loadPage) {
            Scene._loadPage = loadPage;
        }
        static showLoadingPage(param = null, delay = 500) {
            if (Scene._loadPage) {
                ILaya.systemTimer.clear(null, Scene._showLoading);
                ILaya.systemTimer.clear(null, Scene._hideLoading);
                ILaya.systemTimer.once(delay, null, Scene._showLoading, [param], false);
            }
        }
        static _showLoading(param) {
            ILaya.stage.addChild(Scene._loadPage);
            if (Scene._loadPage instanceof Scene)
                Scene._loadPage.onOpened(param);
        }
        static _hideLoading() {
            if (Scene._loadPage instanceof Scene)
                Scene._loadPage.close();
            else
                Scene._loadPage.removeSelf();
        }
        static hideLoadingPage(delay = 500) {
            if (Scene._loadPage) {
                ILaya.systemTimer.clear(null, Scene._showLoading);
                ILaya.systemTimer.clear(null, Scene._hideLoading);
                ILaya.systemTimer.once(delay, null, Scene._hideLoading);
            }
        }
    }
    Scene.unDestroyedScenes = new Set();

    var _definiteIntegralMap = {};
    class BlurFilter extends Filter {
        constructor(strength = 4) {
            super();
            this.shaderData = new TextureSV();
            this._shaderV1 = new Vector4();
            this.strength = strength;
        }
        get strength() {
            return this._strength;
        }
        set strength(v) {
            this._strength = Math.max(Math.abs(v), 2);
            var sigma = this._strength / 3.0;
            var sigma2 = sigma * sigma;
            let v1 = this._shaderV1 = new Vector4(this.strength, sigma2, 2.0 * sigma2, 1.0 / (2.0 * Math.PI * sigma2));
            let s = 0;
            let key = Math.floor(this.strength * 10);
            if (_definiteIntegralMap[key] != undefined) {
                s = _definiteIntegralMap[key];
            }
            else {
                for (let y = -4; y <= 4; ++y) {
                    for (let x = -4; x <= 4; ++x) {
                        s += v1.w * Math.exp(-(x * x + y * y) / v1.z);
                    }
                }
                _definiteIntegralMap[key] = s;
            }
            v1.w /= s;
            this.onChange();
        }
        render(srctexture, width, height) {
            let marginLeft = 50;
            let marginTop = 50;
            this.left = -marginLeft;
            this.top = -marginTop;
            let texwidth = width + 2 * marginLeft;
            let texheight = height + 2 * marginTop;
            this.width = texwidth;
            this.height = texheight;
            if (!this.texture || this.texture.destroyed || this.texture.width != texwidth || this.texture.height != texheight) {
                if (this.texture)
                    this.texture.destroy();
                this.texture = new RenderTexture2D(texwidth, texheight, exports.RenderTargetFormat.R8G8B8A8);
            }
            let render2d = this._render2D.clone(this.texture);
            render2d.renderStart(true, new Color(0, 0, 0, 0));
            let rectVB = this._rectMeshVB;
            let stridef32 = this._rectMesh.vertexDeclarition.vertexStride / 4;
            rectVB[0] = marginLeft;
            rectVB[1] = marginTop;
            rectVB[stridef32] = marginLeft + width;
            rectVB[stridef32 + 1] = marginTop;
            rectVB[stridef32 * 2] = marginLeft + width;
            rectVB[stridef32 * 2 + 1] = marginTop + height;
            rectVB[stridef32 * 3] = marginTop;
            rectVB[stridef32 * 3 + 1] = marginTop + height;
            let shadersv = this.shaderData;
            shadersv.shaderData.addDefine(ShaderDefines2D.FILTERBLUR);
            shadersv.size = new Vector2(texwidth, texheight);
            shadersv.textureHost = srctexture;
            shadersv.blurInfo = new Vector2(texwidth, texheight);
            shadersv.strength_sig2_2sig2_gauss1 = this._shaderV1;
            render2d.draw(this._rectMesh, 0, 4 * this._rectMesh.vertexDeclarition.vertexStride, 0, 12, shadersv, null);
            render2d.renderEnd();
        }
    }

    const DELTA_INDEX = [0, 0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1, 0.11, 0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.22, 0.24, 0.25, 0.27, 0.28, 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42, 0.44, 0.46, 0.48, 0.5, 0.53, 0.56, 0.59, 0.62, 0.65, 0.68, 0.71, 0.74, 0.77, 0.80, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98, 1.0, 1.06, 1.12, 1.18, 1.24, 1.30, 1.36, 1.42, 1.48, 1.54, 1.60, 1.66, 1.72, 1.78, 1.84, 1.90, 1.96, 2.0, 2.12, 2.25, 2.37, 2.50, 2.62, 2.75, 2.87, 3.0, 3.2, 3.4, 3.6, 3.8, 4.0, 4.3, 4.7, 4.9, 5.0, 5.5, 6.0, 6.5, 6.8, 7.0, 7.3, 7.5, 7.8, 8.0, 8.4, 8.7, 9.0, 9.4, 9.6, 9.8, 10.0];
    const GRAY_MATRIX = [0.3086, 0.6094, 0.082, 0, 0, 0.3086, 0.6094, 0.082, 0, 0, 0.3086, 0.6094, 0.082, 0, 0, 0, 0, 0, 1, 0];
    const IDENTITY_MATRIX = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
    const LENGTH = 25;
    class ColorFilter extends Filter {
        constructor(mat = null) {
            super();
            if (!mat)
                mat = this._copyMatrix(IDENTITY_MATRIX);
            this._mat = new Float32Array(16);
            this._alpha = new Float32Array(4);
            this.setByMatrix(mat);
        }
        render(srctexture, width, height) {
            let texwidth = width;
            let texheight = height;
            this.width = texwidth;
            this.height = texheight;
            if (!this.texture || this.texture.destroyed || this.texture.width != texwidth || this.texture.height != texheight) {
                if (this.texture)
                    this.texture.destroy();
                this.texture = new RenderTexture2D(texwidth, texheight, exports.RenderTargetFormat.R8G8B8A8);
            }
            let render2d = this._render2D.clone(this.texture);
            render2d.renderStart(true, new Color(0, 0, 0, 0));
            let rectVB = this._rectMeshVB;
            let stridef32 = this._rectMesh.vertexDeclarition.vertexStride / 4;
            rectVB[0] = 0;
            rectVB[1] = 0;
            rectVB[stridef32] = width;
            rectVB[stridef32 + 1] = 0;
            rectVB[stridef32 * 2] = width;
            rectVB[stridef32 * 2 + 1] = height;
            rectVB[stridef32 * 3] = 0;
            rectVB[stridef32 * 3 + 1] = height;
            let shadersv = new TextureSV();
            shadersv.setFilter(this);
            Matrix4x4.TEMPMatrix0.cloneByArray(this._mat);
            shadersv.shaderData.setMatrix4x4(ShaderDefines2D.UNIFORM_COLORMAT, Matrix4x4.TEMPMatrix0);
            Vector4.tempVec4.setValue(this._alpha[0], this._alpha[1], this._alpha[2], this._alpha[3]);
            shadersv.shaderData.setVector(ShaderDefines2D.UNIFORM_COLORALPHA, Vector4.tempVec4);
            shadersv.size = new Vector2(texwidth, texheight);
            shadersv.textureHost = srctexture;
            render2d.draw(this._rectMesh, 0, 4 * this._rectMesh.vertexDeclarition.vertexStride, 0, 12, shadersv, null);
            render2d.renderEnd();
        }
        gray() {
            return this.setByMatrix(GRAY_MATRIX);
        }
        color(red = 0, green = 0, blue = 0, alpha = 1) {
            return this.setByMatrix([red, 0, 0, 0, 1, 0, green, 0, 0, 1, 0, 0, blue, 0, 1, 0, 0, 0, alpha, 0]);
        }
        setColor(color) {
            var arr = ColorUtils.create(color).arrColor;
            var mt = [0, 0, 0, 0, 256 * arr[0], 0, 0, 0, 0, 256 * arr[1], 0, 0, 0, 0, 256 * arr[2], 0, 0, 0, 1, 0];
            return this.setByMatrix(mt);
        }
        setByMatrix(matrix) {
            if (this._matrix != matrix)
                this._copyMatrix(matrix);
            var j = 0;
            var z = 0;
            for (var i = 0; i < 20; i++) {
                if (i % 5 != 4) {
                    this._mat[j++] = matrix[i];
                }
                else {
                    this._alpha[z++] = matrix[i];
                }
            }
            this.onChange();
            return this;
        }
        get type() {
            return Filter.COLOR;
        }
        get typeDefine() {
            return ShaderDefines2D.FILTERCOLOR;
        }
        adjustColor(brightness, contrast, saturation, hue) {
            this.adjustHue(hue);
            this.adjustContrast(contrast);
            this.adjustBrightness(brightness);
            this.adjustSaturation(saturation);
            return this;
        }
        adjustBrightness(brightness) {
            brightness = this._clampValue(brightness, 100);
            if (brightness == 0 || isNaN(brightness))
                return this;
            return this._multiplyMatrix([1, 0, 0, 0, brightness, 0, 1, 0, 0, brightness, 0, 0, 1, 0, brightness, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        adjustContrast(contrast) {
            contrast = this._clampValue(contrast, 100);
            if (contrast == 0 || isNaN(contrast))
                return this;
            var x;
            if (contrast < 0) {
                x = 127 + contrast / 100 * 127;
            }
            else {
                x = contrast % 1;
                if (x == 0) {
                    x = DELTA_INDEX[contrast];
                }
                else {
                    x = DELTA_INDEX[(contrast << 0)] * (1 - x) + DELTA_INDEX[(contrast << 0) + 1] * x;
                }
                x = x * 127 + 127;
            }
            var x1 = x / 127;
            var x2 = (127 - x) * 0.5;
            return this._multiplyMatrix([x1, 0, 0, 0, x2, 0, x1, 0, 0, x2, 0, 0, x1, 0, x2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        adjustSaturation(saturation) {
            saturation = this._clampValue(saturation, 100);
            if (saturation == 0 || isNaN(saturation))
                return this;
            var x = 1 + ((saturation > 0) ? 3 * saturation / 100 : saturation / 100);
            var dx = 1 - x;
            var r = 0.3086 * dx;
            var g = 0.6094 * dx;
            var b = 0.0820 * dx;
            return this._multiplyMatrix([r + x, g, b, 0, 0, r, g + x, b, 0, 0, r, g, b + x, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        adjustHue(hue) {
            hue = this._clampValue(hue, 180) / 180 * Math.PI;
            if (hue == 0 || isNaN(hue))
                return this;
            var cos = Math.cos(hue);
            var sin = Math.sin(hue);
            var r = 0.213;
            var g = 0.715;
            var b = 0.072;
            return this._multiplyMatrix([r + cos * (1 - r) + sin * (-r), g + cos * (-g) + sin * (-g), b + cos * (-b) + sin * (1 - b), 0, 0, r + cos * (-r) + sin * (0.143), g + cos * (1 - g) + sin * (0.140), b + cos * (-b) + sin * (-0.283), 0, 0, r + cos * (-r) + sin * (-(1 - r)), g + cos * (-g) + sin * (g), b + cos * (1 - b) + sin * (b), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        reset() {
            return this.setByMatrix(this._copyMatrix(IDENTITY_MATRIX));
        }
        _multiplyMatrix(matrix) {
            var col = [];
            this._matrix = this._fixMatrix(this._matrix);
            for (var i = 0; i < 5; i++) {
                for (var j = 0; j < 5; j++) {
                    col[j] = this._matrix[j + i * 5];
                }
                for (j = 0; j < 5; j++) {
                    var val = 0;
                    for (var k = 0; k < 5; k++) {
                        val += matrix[j + k * 5] * col[k];
                    }
                    this._matrix[j + i * 5] = val;
                }
            }
            return this.setByMatrix(this._matrix);
        }
        _clampValue(val, limit) {
            return Math.min(limit, Math.max(-limit, val));
        }
        _fixMatrix(matrix = null) {
            if (matrix == null)
                return IDENTITY_MATRIX;
            if (matrix.length < LENGTH)
                matrix = matrix.slice(0, matrix.length).concat(IDENTITY_MATRIX.slice(matrix.length, LENGTH));
            else if (matrix.length > LENGTH)
                matrix = matrix.slice(0, LENGTH);
            return matrix;
        }
        _copyMatrix(matrix) {
            var len = LENGTH;
            if (!this._matrix)
                this._matrix = [];
            for (var i = 0; i < len; i++) {
                this._matrix[i] = matrix[i];
            }
            return this._matrix;
        }
        onAfterDeserialize() {
            let arr = ColorUtils.create(this._color || "#FFFFFF").arrColor;
            this.color(arr[0], arr[1], arr[2], arr[3]);
            this.adjustColor(this._brightness || 0, this._contrast || 0, this._saturation || 0, this._hue || 0);
        }
    }

    class GlowFilter extends Filter {
        constructor(color, blur = 4, offX = 6, offY = 6) {
            super();
            this._sv_blurInfo1 = new Array(4);
            this._sv_blurInfo2 = [0, 0, 1, 0];
            this._flipY = false;
            this._color = new ColorUtils(color || "#000");
            this.blur = Math.min(blur, 20);
            this.offX = offX;
            this.offY = offY;
            this._sv_blurInfo1[1] = this.blur;
            this.shaderDataBlur = new TextureSV();
            this.shaderDataBlur.u_blurInfo1 = new Vector4();
            this.shaderDataBlur.u_blurInfo2 = new Vector4();
            this.shaderDataBlur.color = new Vector4();
            this.shaderDataBlur.size = new Vector2();
            this.shaderDataBlur.blurInfo = new Vector2();
            this.shaderDataCopy = new TextureSV();
            this.shaderDataCopy.size = new Vector2();
            this.shaderDataCopy1 = new TextureSV();
        }
        _fillQuad(x, y, w, h, flipY = false) {
            let uvrect;
            if (flipY) {
                uvrect = [0, 1, 1, 0];
            }
            else {
                uvrect = [0, 0, 1, 1];
            }
            let rectVB = this._rectMeshVB;
            let stridef32 = this._rectMesh.vertexDeclarition.vertexStride / 4;
            rectVB[0] = x;
            rectVB[1] = y;
            rectVB[2] = uvrect[0];
            rectVB[3] = uvrect[1];
            rectVB[stridef32] = x + w;
            rectVB[stridef32 + 1] = y;
            rectVB[stridef32 + 2] = uvrect[2];
            rectVB[stridef32 + 3] = uvrect[1];
            rectVB[stridef32 * 2] = x + w;
            rectVB[stridef32 * 2 + 1] = y + h;
            rectVB[stridef32 * 2 + 2] = uvrect[2];
            rectVB[stridef32 * 2 + 3] = uvrect[3];
            rectVB[stridef32 * 3] = y;
            rectVB[stridef32 * 3 + 1] = y + h;
            rectVB[stridef32 * 3 + 2] = uvrect[0];
            rectVB[stridef32 * 3 + 3] = uvrect[3];
        }
        useFlipY(b) {
            super.useFlipY(b);
            this._flipY = b;
        }
        render(srctexture, width, height) {
            let marginLeft = 50;
            let marginTop = 50;
            this.left = -marginLeft;
            this.top = -marginTop;
            let outTexWidth = width + 2 * marginLeft;
            let outTexHeight = height + 2 * marginTop;
            this.width = outTexWidth;
            this.height = outTexHeight;
            if (!this.textureExtend || this.textureExtend.destroyed || this.textureExtend.width != outTexWidth ||
                this.textureExtend.height != outTexHeight) {
                if (this.textureExtend)
                    this.textureExtend.destroy();
                this.textureExtend = new RenderTexture2D(outTexWidth, outTexHeight, exports.RenderTargetFormat.R8G8B8A8);
            }
            let render2d = this._render2D.clone(this.textureExtend);
            render2d.renderStart(true, new Color(0, 0, 0, 0));
            this.shaderDataCopy1.size = new Vector2(outTexWidth, outTexHeight);
            this.shaderDataCopy1.textureHost = srctexture;
            this._fillQuad(marginLeft, marginTop, srctexture.width, srctexture.height, this._flipY);
            render2d.draw(this._rectMesh, 0, 4 * this._rectMesh.vertexDeclarition.vertexStride, 0, 12, this.shaderDataCopy1, null);
            render2d.renderEnd();
            if (!this.texture || this.texture.destroyed || this.texture.width != outTexWidth || this.texture.height != outTexHeight) {
                if (this.texture)
                    this.texture.destroy();
                this.texture = new RenderTexture2D(outTexWidth, outTexHeight, exports.RenderTargetFormat.R8G8B8A8);
            }
            render2d = render2d.clone(this.texture);
            render2d.renderStart(true, new Color(0, 0, 0, 0));
            this._fillQuad(0, 0, outTexWidth, outTexHeight, true);
            let shadersv = this.shaderDataBlur;
            shadersv.shaderData.addDefine(ShaderDefines2D.FILTERGLOW);
            let size = shadersv.size;
            size.setValue(outTexWidth, outTexHeight);
            shadersv.size = size;
            shadersv.textureHost = this.textureExtend;
            let blurInfo = shadersv.blurInfo;
            blurInfo.setValue(outTexWidth, outTexHeight);
            shadersv.blurInfo = blurInfo;
            let u_blurInfo1 = shadersv.u_blurInfo1;
            u_blurInfo1.setValue(this._sv_blurInfo1[0], this._sv_blurInfo1[1], this._sv_blurInfo1[2], this._sv_blurInfo1[3]);
            shadersv.u_blurInfo1 = u_blurInfo1;
            let u_blurInfo2 = shadersv.u_blurInfo2;
            u_blurInfo2.setValue(srctexture.width, srctexture.height, this._sv_blurInfo2[2], this._sv_blurInfo2[3]);
            shadersv.u_blurInfo2 = u_blurInfo2;
            let color = this.getColor();
            let svColor = shadersv.color;
            svColor.setValue(color[0], color[1], color[2], color[3]);
            shadersv.color = svColor;
            render2d.draw(this._rectMesh, 0, 4 * this._rectMesh.vertexDeclarition.vertexStride, 0, 12, shadersv, null);
            let shadercpy = this.shaderDataCopy;
            size = shadercpy.size;
            size.setValue(outTexWidth, outTexHeight);
            shadercpy.size = size;
            shadercpy.textureHost = srctexture;
            this._fillQuad(marginLeft, marginTop, srctexture.width, srctexture.height, this._flipY);
            render2d.draw(this._rectMesh, 0, 4 * this._rectMesh.vertexDeclarition.vertexStride, 0, 12, shadercpy, null);
            render2d.renderEnd();
        }
        get typeDefine() {
            return ShaderDefines2D.FILTERGLOW;
        }
        get offY() {
            return this._sv_blurInfo1[3];
        }
        set offY(value) {
            this._sv_blurInfo1[3] = value;
            this.onChange();
        }
        get offX() {
            return this._sv_blurInfo1[2];
        }
        set offX(value) {
            this._sv_blurInfo1[2] = value;
            this.onChange();
        }
        get color() {
            return this._color.strColor;
        }
        set color(value) {
            this._color = new ColorUtils(value);
            this.onChange();
        }
        getColor() {
            return this._color.arrColor;
        }
        get blur() {
            return this._sv_blurInfo1[1];
        }
        set blur(value) {
            this._sv_blurInfo1[0] = this._sv_blurInfo1[1] = value;
            this.onChange();
        }
    }

    class SoundNode extends Sprite {
        constructor() {
            super();
            this._loop = 1;
            this.on(Event.ADDED, this, this._onParentChange);
            this.on(Event.REMOVED, this, this._onParentChange);
        }
        get source() {
            return this._source;
        }
        set source(value) {
            this._source = value;
            if (value) {
                if (this._autoPlay && (!this._channel || this._channel.isStopped) && LayaEnv.isPlaying)
                    this.play();
            }
            else
                this.stop();
        }
        get isMusic() {
            return this._isMusic;
        }
        set isMusic(value) {
            this._isMusic = value;
        }
        get loop() {
            return this._loop;
        }
        set loop(value) {
            this._loop = value;
        }
        get autoPlay() {
            return this._autoPlay;
        }
        set autoPlay(value) {
            this._autoPlay = value;
            if (value && this._source && (!this._channel || this._channel.isStopped) && LayaEnv.isPlaying)
                this.play();
        }
        _onParentChange() {
            this.target = this.parent;
        }
        play(loops, complete) {
            if (!this._source)
                return;
            if (loops == null || isNaN(loops))
                loops = this._loop;
            this.stop();
            if (this._isMusic)
                this._channel = SoundManager.playMusic(this._source, loops, complete);
            else
                this._channel = SoundManager.playSound(this._source, loops, complete);
        }
        stop() {
            if (this._channel && !this._channel.isStopped) {
                this._channel.stop();
            }
            this._channel = null;
        }
        _setPlayAction(tar, event, action, add = true) {
            if (!this[action])
                return;
            if (!tar)
                return;
            if (add) {
                tar.on(event, this, this[action]);
            }
            else {
                tar.off(event, this, this[action]);
            }
        }
        _setPlayActions(tar, events, action, add = true) {
            if (!tar)
                return;
            if (!events)
                return;
            let eventArr = events.split(",");
            let len = eventArr.length;
            for (let i = 0; i < len; i++) {
                this._setPlayAction(tar, eventArr[i], action, add);
            }
        }
        set playEvent(events) {
            this._playEvents = events;
            if (!events)
                return;
            if (this._tar) {
                this._setPlayActions(this._tar, events, "play");
            }
        }
        set target(tar) {
            if (this._tar) {
                this._setPlayActions(this._tar, this._playEvents, "play", false);
                this._setPlayActions(this._tar, this._stopEvents, "stop", false);
            }
            this._tar = tar;
            if (this._tar) {
                this._setPlayActions(this._tar, this._playEvents, "play", true);
                this._setPlayActions(this._tar, this._stopEvents, "stop", true);
            }
        }
        set stopEvent(events) {
            this._stopEvents = events;
            if (!events)
                return;
            if (this._tar) {
                this._setPlayActions(this._tar, events, "stop");
            }
        }
    }

    class VideoTexture extends BaseTexture {
        set updateFrame(value) {
            this._frameDelty = 1 / value * 1000;
            this._updateFrame = value;
        }
        get updateFrame() {
            return this._updateFrame;
        }
        set useFrame(value) {
            this._useFrame = value;
        }
        get useFrame() {
            return this._useFrame;
        }
        constructor() {
            let ele = ILaya.Browser.createElement("video");
            super(ele.videoWidth, ele.videoHeight, exports.RenderTargetFormat.R8G8B8);
            this._requestVideoFrame = false;
            this._lastTimer = 0;
            this._frameRender = true;
            this._isLoaded = false;
            this._needUpdate = false;
            this.immediatelyPlay = false;
            this.element = ele;
            this.useFrame = false;
            this.updateFrame = 30;
            this._listeningEvents = {};
            this._dimension = exports.TextureDimension.Tex2D;
            var style = this.element.style;
            style.position = 'absolute';
            style.top = '0px';
            style.left = '0px';
            ele.setAttribute('crossorigin', 'anonymous');
            if (ILaya.Browser.onMobile) {
                ele["x5-playsInline"] = true;
                ele["x5-playsinline"] = true;
                ele.x5PlaysInline = true;
                ele.playsInline = true;
                ele["webkit-playsInline"] = true;
                ele["webkit-playsinline"] = true;
                ele.webkitPlaysInline = true;
                ele.playsinline = true;
                ele.style.playsInline = true;
                ele.crossOrigin = "anonymous";
                ele.setAttribute('playsinline', 'true');
                ele.setAttribute('x5-playsinline', 'true');
                ele.setAttribute('webkit-playsinline', 'true');
                ele.autoplay = true;
            }
            ele.addEventListener("loadedmetadata", () => {
                this.loadedmetadata();
            });
            if ("requestVideoFrameCallback" in HTMLVideoElement.prototype) {
                const scope = this;
                function updateVideo() {
                    scope._needUpdate = true;
                    ele.requestVideoFrameCallback(updateVideo);
                }
                ele.requestVideoFrameCallback(updateVideo);
                this._requestVideoFrame = true;
            }
            else {
                this._needUpdate = true;
            }
        }
        isNeedUpdate() {
            if (!this.useFrame)
                return !this._requestVideoFrame || this._needUpdate;
            else {
                let timer = Browser.now();
                if (timer - this._lastTimer > this._frameDelty) {
                    this._lastTimer = timer;
                    return true;
                }
                return false;
            }
        }
        loadedmetadata() {
            if (this._isLoaded)
                return;
            this._width = this.element.videoWidth;
            this._height = this.element.videoHeight;
            if (Browser.onLayaRuntime) {
                this._texture = LayaGL.textureContext.createTextureInternal(this._dimension, this.element.videoWidth, this.element.videoHeight, exports.TextureFormat.R8G8B8A8, false, false, false);
            }
            else {
                this._texture = LayaGL.textureContext.createTextureInternal(this._dimension, this.element.videoWidth, this.element.videoHeight, exports.TextureFormat.R8G8B8, false, false, false);
            }
            this.wrapModeU = exports.WrapMode.Clamp;
            this.wrapModeV = exports.WrapMode.Clamp;
            this.filterMode = exports.FilterMode.Bilinear;
            LayaGL.textureContext.initVideoTextureData(this._texture);
            this._texture.gammaCorrection = 2.2;
            if (this.immediatelyPlay) {
                this.play();
            }
            this._isLoaded = true;
            this.event(Event.READY, this);
        }
        get gammaCorrection() {
            return 2.2;
        }
        get source() {
            return this._source;
        }
        set source(url) {
            this._source = url;
            if (!url)
                return;
            AssetDb.inst.resolveURL(url, url => {
                while (this.element.childElementCount)
                    this.element.firstChild.remove();
                if (url.startsWith("blob:"))
                    this.element.src = url;
                else
                    this.appendSource(url);
            });
        }
        appendSource(source) {
            var sourceElement = ILaya.Browser.createElement("source");
            sourceElement.src = URL.postFormatURL(URL.formatURL(source));
            let extension = Utils.getFileExtension(source);
            sourceElement.type = extension == "m3u8" ? "application/vnd.apple.mpegurl" : ("video/" + extension);
            this.element.appendChild(sourceElement);
        }
        render() {
            if (this.element.readyState == 0)
                return;
            if (this.isNeedUpdate() || Browser.onLayaRuntime) {
                LayaGL.textureContext.updateVideoTexture(this._texture, this.element, false, false);
                this._needUpdate = false;
                this.event(VideoTexture.videoEvent_update);
            }
        }
        get frameRender() {
            return this._frameRender;
        }
        set frameRender(value) {
            if (this._frameRender && !value) {
                ILaya.timer.clear(this, this.render);
            }
            if (!this._frameRender && value) {
                ILaya.timer.frameLoop(1, this, this.render);
            }
            this._frameRender = value;
        }
        play() {
            if (!this._texture) {
                this.immediatelyPlay = true;
            }
            else {
                this.element.play().catch(() => {
                    this.event("NotAllowedError");
                });
                if (this._frameRender) {
                    ILaya.timer.frameLoop(1, this, this.render);
                }
            }
        }
        _getSource() {
            return this._texture ? this._texture.resource : null;
        }
        get defaultTexture() {
            return Texture2D.whiteTexture;
        }
        pause() {
            this.element.pause();
            if (this._frameRender) {
                ILaya.timer.clear(this, this.render);
            }
        }
        load() {
            this.element.load();
        }
        canPlayType(type) {
            type = type == "m3u8" ? "application/vnd.apple.mpegurl" : ("video/" + type);
            return this.element.canPlayType(type);
        }
        get buffered() {
            return this.element.buffered;
        }
        get currentSrc() {
            return this.element.currentSrc;
        }
        get currentTime() {
            return this.element.currentTime;
        }
        set currentTime(value) {
            if (!this.element)
                return;
            this.element.currentTime = value;
            this.render();
        }
        get volume() {
            return this.element.volume;
        }
        set volume(value) {
            if (!this.element)
                return;
            this.element.volume = value;
        }
        get readyState() {
            return this.element.readyState;
        }
        get videoWidth() {
            return this.element.videoWidth;
        }
        get videoHeight() {
            return this.element.videoHeight;
        }
        get duration() {
            return this.element.duration;
        }
        get ended() {
            return this.element.ended;
        }
        get error() {
            return this.element.error;
        }
        get loop() {
            return this.element.loop;
        }
        set loop(value) {
            if (!this.element)
                return;
            this.element.loop = value;
        }
        get playbackRate() {
            return this.element.playbackRate;
        }
        set playbackRate(value) {
            if (!this.element)
                return;
            this.element.playbackRate = value;
        }
        get muted() {
            return this.element.muted;
        }
        set muted(value) {
            if (!this.element)
                return;
            this.element.muted = value;
        }
        get paused() {
            return this.element.paused;
        }
        get preload() {
            return this.element.preload;
        }
        set preload(value) {
            if (!this.element)
                return;
            this.element.preload = value;
        }
        get seekable() {
            return this.element.seekable;
        }
        get seeking() {
            return this.element.seeking;
        }
        onStartListeningToType(type) {
            if (videoEvents.has(type)) {
                let func = this._listeningEvents[type];
                if (!func)
                    func = this._listeningEvents[type] = () => {
                        this.event(type);
                    };
                this.element.addEventListener(type, func);
            }
        }
        destroy() {
            if (this.element) {
                if (LayaEnv.isConch) {
                    this.element._destroy();
                }
                else {
                    this.element.pause();
                    this.element.src = "";
                    while (this.element.childElementCount)
                        this.element.firstChild.remove();
                }
            }
            ILaya.timer.clear(this, this.render);
            super.destroy();
        }
    }
    VideoTexture.videoEvent_update = "videoUpdate";
    const videoEvents = new Set([
        "abort", "canplay", "canplaythrough", "durationchange", "emptied", "error", "loadeddata",
        "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "seeked", "seeking",
        "stalled", "suspend", "timeupdate", "volumechange", "waiting", "ended"
    ]);

    class VideoNode extends Sprite {
        constructor() {
            super();
            this.texture = this._internalTex = new Texture();
            if (LayaEnv.isPlaying && ILaya.Browser.onMobile) {
                let func = () => {
                    ILaya.Browser.document.removeEventListener("touchend", func);
                    if (!this._videoTexture)
                        return;
                    if (Browser.onIOS) {
                        this._videoTexture.load();
                    }
                    else {
                        this._videoTexture.play();
                        this._videoTexture.pause();
                    }
                };
                ILaya.Browser.document.addEventListener("touchend", func);
            }
        }
        get videoTexture() {
            return this._videoTexture;
        }
        set videoTexture(value) {
            if (this._videoTexture) {
                this._videoTexture._removeReference();
                this._videoTexture.off(Event.READY, this, this.onVideoMetaLoaded);
                this._videoTexture.off(VideoTexture.videoEvent_update, this, this._repaintCachAs);
            }
            this._videoTexture = value;
            if (value) {
                this._videoTexture._addReference();
                this._videoTexture.on(Event.READY, this, this.onVideoMetaLoaded);
                if (this._videoTexture._isLoaded)
                    this._internalTex.setTo(this._videoTexture);
            }
            else {
                this._internalTex.setTo(null);
            }
            this._checkCachAs();
        }
        get source() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.source;
        }
        set source(value) {
            if (value) {
                if (!this._videoTexture)
                    this.videoTexture = new VideoTexture();
                this._videoTexture.source = value;
            }
            else if (this._videoTexture)
                this._videoTexture.source = value;
            this._checkCachAs();
        }
        _checkCachAs() {
            if (this.videoTexture != null)
                this.videoTexture.on(VideoTexture.videoEvent_update, this, this._repaintCachAs);
        }
        _repaintCachAs() {
            if (this.cacheAs != "none" || (!!this._getCacheStyle().mask)) {
                this.repaint();
            }
        }
        load(url) {
            this.source = url;
        }
        play() {
            if (!this._videoTexture)
                return;
            this._videoTexture.play();
        }
        pause() {
            if (!this._videoTexture)
                return;
            this._videoTexture.pause();
        }
        reload() {
            if (!this._videoTexture)
                return;
            this._videoTexture.load();
        }
        canPlayType(type) {
            if (!this._videoTexture)
                this.videoTexture = new VideoTexture();
            return this._videoTexture.canPlayType(type);
        }
        onVideoMetaLoaded() {
            this._internalTex.setTo(this._videoTexture);
        }
        get buffered() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.buffered;
        }
        get currentSrc() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.currentSrc;
        }
        get currentTime() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.currentTime;
        }
        set currentTime(value) {
            if (!this._videoTexture)
                return;
            this._videoTexture.currentTime = value;
        }
        get volume() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.volume;
        }
        set volume(value) {
            if (!this._videoTexture)
                return;
            this._videoTexture.volume = value;
        }
        get readyState() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.readyState;
        }
        get videoWidth() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.videoWidth;
        }
        get videoHeight() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.videoHeight;
        }
        get duration() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.duration;
        }
        get ended() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.ended;
        }
        get error() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.error;
        }
        get loop() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.loop;
        }
        set loop(value) {
            if (!this._videoTexture)
                return;
            this._videoTexture.loop = value;
        }
        get playbackRate() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.playbackRate;
        }
        set playbackRate(value) {
            if (!this._videoTexture)
                return;
            this._videoTexture.playbackRate = value;
        }
        get muted() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.muted;
        }
        set muted(value) {
            if (!this._videoTexture)
                return;
            this._videoTexture.muted = value;
        }
        get paused() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.paused;
        }
        get preload() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.preload;
        }
        set preload(value) {
            if (!this._videoTexture)
                return;
            this._videoTexture.preload = value;
        }
        get seekable() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.seekable;
        }
        get seeking() {
            var _a;
            return (_a = this._videoTexture) === null || _a === void 0 ? void 0 : _a.seeking;
        }
        _setX(value) {
            super._setX(value);
            if (this._videoTexture && LayaEnv.isConch) {
                var transform = SpriteUtils.getTransformRelativeToWindow(this, 0, 0);
                this._videoTexture.element.style.left = transform.x;
            }
        }
        _setY(value) {
            super._setY(value);
            if (this._videoTexture && LayaEnv.isConch) {
                var transform = SpriteUtils.getTransformRelativeToWindow(this, 0, 0);
                this._videoTexture.element.style.top = transform.y;
            }
        }
        set_width(value) {
            super.set_width(value);
            if (!this._videoTexture)
                return;
            if (LayaEnv.isConch) {
                var transform = SpriteUtils.getTransformRelativeToWindow(this, 0, 0);
                this._videoTexture.element.width = value * transform.scaleX;
            }
            else {
                this._videoTexture.element.width = this.width / ILaya.Browser.pixelRatio;
            }
        }
        set_height(value) {
            super.set_height(value);
            if (!this._videoTexture)
                return;
            if (LayaEnv.isConch) {
                var transform = SpriteUtils.getTransformRelativeToWindow(this, 0, 0);
                this._videoTexture.element.height = value * transform.scaleY;
            }
            else {
                this._videoTexture.element.height = this.height / ILaya.Browser.pixelRatio;
            }
        }
        destroy(destroyChildren = true) {
            this.videoTexture = null;
            super.destroy(destroyChildren);
        }
    }

    class AnimatorPlayState2D {
        get duration() {
            return this._duration;
        }
        get animatorState() {
            return this._currentState;
        }
        constructor() {
            this._currentState = null;
            this._frontPlay = true;
        }
        _resetPlayState(startTime, clipDuration) {
            this._finish = false;
            this._startPlayTime = startTime;
            this._elapsedTime = startTime;
            this._lastIsFront = true;
            this._parentPlayTime = null;
            this._playNum = 0;
            this._playAllTime = 0;
            var playTime = (this._elapsedTime / clipDuration) % 1.0;
            this._normalizedPlayTime = playTime < 0 ? playTime + 1.0 : playTime;
            this._frontPlay = true;
        }
        _cloneTo(dest) {
            dest._finish = this._finish;
            dest._startPlayTime = this._startPlayTime;
            dest._elapsedTime = this._elapsedTime;
            dest._playNum = this._playNum;
            dest._parentPlayTime = this._parentPlayTime;
            dest._normalizedPlayTime = this._normalizedPlayTime;
            dest._lastIsFront = this._lastIsFront;
            dest._frontPlay = this._frontPlay;
            dest._playAllTime = this._playAllTime;
        }
    }

    class AnimatorControllerLayer2D {
        constructor(name) {
            this._referenceCount = 0;
            this._playStateInfo = new AnimatorPlayState2D();
            this._crossPlayStateInfo = new AnimatorPlayState2D();
            this._crossMark = 0;
            this._crossNodesOwnersCount = 0;
            this._crossNodesOwnersIndicesMap = {};
            this._srcCrossClipNodeIndices = [];
            this._destCrossClipNodeIndices = [];
            this.playOnWake = true;
            this.defaultWeight = 1.0;
            this.blendingMode = AnimatorControllerLayer2D.BLENDINGMODE_OVERRIDE;
            this.enable = true;
            this._states = [];
            this._playType = -1;
            this.name = name;
        }
        get states() {
            return this._states;
        }
        set states(states) {
            if (this._states === states)
                return;
            for (let i = this.states.length - 1; i >= 0; i--) {
                this.removeState(this.states[i]);
            }
            for (let i = states.length - 1; i >= 0; i--) {
                this.addState(states[i]);
            }
        }
        get defaultStateName() {
            if (!this._defaultState) {
                return null;
            }
            return this._defaultState.name;
        }
        set defaultStateName(str) {
            this._defaultState = this.getStateByName(str);
            if (null == this._defaultState) {
                if (0 == this._states.length) {
                    this._defaultStateNameCatch = str;
                }
                else {
                    for (var i = this._states.length - 1; i >= 0; i--) {
                        if (this._states[i].name == str) {
                            this._defaultState = this._states[i];
                            break;
                        }
                    }
                }
            }
        }
        get defaultState() {
            return this._defaultState;
        }
        set defaultState(value) {
            this._defaultState = value;
        }
        _removeClip(clipStateInfos, index, state) {
            clipStateInfos.splice(index, 1);
        }
        _getReferenceCount() {
            return this._referenceCount;
        }
        _addReference(count) {
            for (var i = 0, n = this._states.length; i < n; i++)
                this._states[i]._addReference(count);
            this._referenceCount += count;
        }
        _removeReference(count = 1) {
            for (var i = 0, n = this._states.length; i < n; i++)
                this._states[i]._removeReference(count);
            this._referenceCount -= count;
        }
        _clearReference() {
            this._removeReference(-this._referenceCount);
        }
        getCurrentPlayState() {
            return this._playStateInfo;
        }
        getStateByName(str) {
            for (let i = this._states.length - 1; i >= 0; i--) {
                if (this._states[i].name == str) {
                    return this._states[i];
                }
            }
            return null;
        }
        addState(state) {
            var stateName = state.name;
            if (this.getStateByName(stateName)) {
                throw new Error("AnimatorControllerLayer:this stat's name has exist.");
            }
            else {
                this._states.push(state);
                if (stateName == this._defaultStateNameCatch) {
                    this._defaultState = state;
                    this._defaultStateNameCatch = null;
                }
            }
        }
        removeState(state) {
            var states = this._states;
            var index = -1;
            for (var i = 0, n = states.length; i < n; i++) {
                if (states[i] === state) {
                    index = i;
                    break;
                }
            }
            if (-1 != index)
                this._removeClip(states, index, state);
        }
        clone() {
            var dest = new AnimatorControllerLayer2D(this.name);
            this.cloneTo(dest);
            return dest;
        }
        cloneTo(destObject) {
            destObject.name = this.name;
        }
        destroy() {
            this._removeReference();
            for (var i = 0, n = this._states.length; i < n; i++) {
                this._states[i].destroy();
            }
            this._states.length = 0;
        }
    }
    AnimatorControllerLayer2D.BLENDINGMODE_OVERRIDE = 0;
    AnimatorControllerLayer2D.BLENDINGMODE_ADDTIVE = 1;

    exports.AniParmType = void 0;
    (function (AniParmType) {
        AniParmType[AniParmType["Float"] = 0] = "Float";
        AniParmType[AniParmType["Bool"] = 1] = "Bool";
        AniParmType[AniParmType["Trigger"] = 2] = "Trigger";
    })(exports.AniParmType || (exports.AniParmType = {}));
    exports.AniStateConditionType = void 0;
    (function (AniStateConditionType) {
        AniStateConditionType[AniStateConditionType["Number"] = 0] = "Number";
        AniStateConditionType[AniStateConditionType["Bool"] = 1] = "Bool";
        AniStateConditionType[AniStateConditionType["Trigger"] = 2] = "Trigger";
    })(exports.AniStateConditionType || (exports.AniStateConditionType = {}));
    exports.AniStateConditionNumberCompressType = void 0;
    (function (AniStateConditionNumberCompressType) {
        AniStateConditionNumberCompressType[AniStateConditionNumberCompressType["Less"] = 0] = "Less";
        AniStateConditionNumberCompressType[AniStateConditionNumberCompressType["Greater"] = 1] = "Greater";
    })(exports.AniStateConditionNumberCompressType || (exports.AniStateConditionNumberCompressType = {}));
    class AnimatorControllerParse {
        static parse(data) {
            let ret = data;
            let layers = ret.controllerLayers;
            if (null == layers) {
                layers = [];
            }
            let clipsID = [];
            for (let i = layers.length - 1; i >= 0; i--) {
                let l = layers[i];
                let states = l.states;
                if (!states) {
                    states = [];
                    l.states = states;
                }
                l.defaultStateName = null;
                let retobj = this.checkStates(states, clipsID, ret);
                if (retobj) {
                    l.defaultStateName = retobj.enterName;
                }
                else {
                    layers.splice(i, 1);
                }
            }
            return { ret: ret, clipsID: clipsID };
        }
        static checkStates(states, clipsID, data) {
            let clipState = null;
            let enterState = null;
            for (let j = states.length - 1; j >= 0; j--) {
                let state = states[j];
                if (state.states) {
                    if (null == this.checkStates(state.states, clipsID, data)) {
                        states.splice(j, 1);
                    }
                    else {
                        if (null == clipState) {
                            clipState = [];
                        }
                        clipState.push(state);
                    }
                }
                else if ("-1" == state.id) {
                    enterState = state;
                }
                else if ("-2" == state.id) ;
                else if ("-3" == state.id) ;
                else if (null == state.clip || null == state.clip._$uuid || "" == state.clip._$uuid) {
                    states.splice(j, 1);
                }
                else {
                    if (0 > clipsID.indexOf(state.clip._$uuid)) {
                        clipsID.push(state.clip._$uuid);
                    }
                    this.checkNext(state, states, data);
                    if (null == clipState) {
                        clipState = [];
                    }
                    clipState.push(state);
                }
            }
            let ret = null;
            if (clipState && enterState) {
                let defName = this.checkDefault(enterState, clipState);
                if (null != defName) {
                    ret = { states: clipState, enterName: defName };
                }
            }
            return ret;
        }
        static checkNext(state, states, data) {
            let nexts = state.soloTransitions;
            if (nexts) {
                for (let i = nexts.length - 1; i >= 0; i--) {
                    let next = nexts[i];
                    let nState = this.getStateByID(states, next.id);
                    if (!nState || (null == nState.clip && "-3" != nState.id && null == nState.states)) {
                        nexts.splice(i, 1);
                    }
                    else {
                        next.name = nState.name;
                        next.conditions = this.checkConditions(next.conditions, data);
                    }
                }
            }
        }
        static checkConditions(conditions, data) {
            if (!conditions || 0 == conditions.length || null == data.animatorParams || 0 == data.animatorParams.length) {
                return [];
            }
            let parms = data.animatorParams;
            for (let i = conditions.length - 1; i >= 0; i--) {
                let o = conditions[i];
                let parm = null;
                for (let j = parms.length - 1; j >= 0; j--) {
                    if (parms[j].id == o.id) {
                        parm = parms[j];
                        break;
                    }
                }
                if (null == parm) {
                    conditions.splice(i, 1);
                }
                else {
                    o.name = parm.name;
                    if (parm.type == exports.AniParmType.Float) {
                        let num = Number(o.checkValue);
                        if (isNaN(num)) {
                            o.checkValue = 0;
                        }
                        num = Number(o.type);
                        if (isNaN(num)) {
                            o.type = 0;
                        }
                    }
                }
            }
            return conditions;
        }
        static checkDefault(state, states) {
            let nexts = state.soloTransitions;
            let id = null;
            if (nexts && 0 < nexts.length) {
                id = nexts[0].id;
            }
            let defState = null;
            if (null != id) {
                defState = this.getStateByID(states, id);
            }
            if (null != defState && (null != defState.clip || null != defState.states)) {
                return defState.name;
            }
            for (let i = states.length - 1; i >= 0; i--) {
                if (states[i].clip) {
                    return states[i].name;
                }
            }
            return null;
        }
        static getStateByID(states, id) {
            if (states) {
                for (let i = states.length - 1; i >= 0; i--) {
                    if (states[i].id == id) {
                        return states[i];
                    }
                }
            }
            return null;
        }
    }

    exports.AnimatorUpdateMode = void 0;
    (function (AnimatorUpdateMode) {
        AnimatorUpdateMode[AnimatorUpdateMode["Normal"] = 0] = "Normal";
        AnimatorUpdateMode[AnimatorUpdateMode["LowFrame"] = 1] = "LowFrame";
        AnimatorUpdateMode[AnimatorUpdateMode["UnScaleTime"] = 2] = "UnScaleTime";
    })(exports.AnimatorUpdateMode || (exports.AnimatorUpdateMode = {}));

    class Animator2D extends Component {
        constructor() {
            super();
            this._speed = 1;
            this._updateMode = exports.AnimatorUpdateMode.Normal;
            this._lowUpdateDelty = 20;
            this._isPlaying = true;
            this._controllerLayers = [];
            this._parameters = {};
        }
        get controller() {
            return this._controller;
        }
        set controller(val) {
            if (this._controller)
                this._controller._removeReference();
            this._controller = val;
            if (val) {
                val._addReference();
                val.updateTo(this);
            }
        }
        get parameters() {
            return this._parameters;
        }
        set parameters(val) {
            this._parameters = val;
        }
        get speed() {
            return this._speed;
        }
        set speed(num) {
            this._speed = num;
        }
        get isPlaying() {
            return this._isPlaying;
        }
        _updateStateFinish(animatorState, playState) {
            if (playState._finish) {
                animatorState._eventExit();
            }
        }
        _setClipDatasToNode(stateInfo, additive, weight, controllerLayer = null) {
            var realtimeDatas = stateInfo._realtimeDatas;
            var nodes = stateInfo._clip._nodes;
            for (var i = 0, n = nodes.count; i < n; i++) {
                if (null == realtimeDatas[i])
                    continue;
                var node = nodes.getNodeByIndex(i);
                var o = this.getOwner(node);
                o && this._applyFloat(o, additive, weight, realtimeDatas[i]);
            }
        }
        _applyFloat(o, additive, weight, data) {
            var pro = o.pro;
            if (pro && pro.ower) {
                if (additive && "number" == typeof data) {
                    pro.ower[pro.key] = pro.defVal + weight * data;
                }
                else if ("number" == typeof data) {
                    pro.ower[pro.key] = weight * data;
                }
                else {
                    pro.ower[pro.key] = data;
                }
            }
        }
        getOwner(node) {
            var ret;
            if (this._ownerMap) {
                ret = this._ownerMap.get(node);
                if (ret) {
                    return ret;
                }
            }
            var property = this.owner;
            for (var j = 0, m = node.ownerPathCount; j < m; j++) {
                var ownPat = node.getOwnerPathByIndex(j);
                if ("" == ownPat) {
                    continue;
                }
                else {
                    property = property.getChildByName(ownPat);
                    if (!property)
                        break;
                }
            }
            ret = { ower: property };
            if (property) {
                var pobj = property;
                var propertyCount = node.propertyCount;
                if (1 == propertyCount) {
                    var pname = node.getPropertyByIndex(0);
                    ret.pro = { ower: property, key: pname, defVal: property[pname] };
                }
                else {
                    for (var i = 0; i < propertyCount; i++) {
                        var pname = node.getPropertyByIndex(i);
                        if (i == propertyCount - 1 || null == pobj) {
                            ret.pro = { ower: pobj, key: pname, defVal: pobj ? pobj[pname] : null };
                            break;
                        }
                        if ('_gcmds' === pname && null == pobj[pname] && pobj.graphics) {
                            pobj = pobj.graphics;
                            pname = "cmds";
                        }
                        if (null == pobj[pname] && property == pobj) {
                            pobj = null;
                            var classObj = ClassUtils.getClass(pname);
                            if (classObj) {
                                pobj = property.getComponent(classObj);
                            }
                        }
                        else {
                            pobj = pobj[pname];
                        }
                    }
                }
            }
            if (null == this._ownerMap) {
                this._ownerMap = new Map();
            }
            this._ownerMap.set(node, ret);
            return ret;
        }
        _updateClipDatas(animatorState, addtive, playStateInfo) {
            var clip = animatorState._clip;
            var clipDuration = clip._duration;
            var curPlayTime = animatorState.clipStart * clipDuration + playStateInfo._normalizedPlayTime * playStateInfo._duration;
            var currentFrameIndices = animatorState._currentFrameIndices;
            let frontPlay = true;
            clip._evaluateClipDatasRealTime(curPlayTime, currentFrameIndices, addtive, frontPlay, animatorState._realtimeDatas);
        }
        _updatePlayer(animatorState, playState, elapsedTime, loop, layerIndex) {
            let isReplay = false;
            var clipDuration = animatorState._clip._duration * (animatorState.clipEnd - animatorState.clipStart);
            var lastElapsedTime = playState._elapsedTime;
            let pAllTime = playState._playAllTime;
            playState._playAllTime += Math.abs(elapsedTime);
            elapsedTime = lastElapsedTime + elapsedTime;
            playState._lastElapsedTime = lastElapsedTime;
            playState._elapsedTime = elapsedTime;
            var normalizedTime = elapsedTime / clipDuration;
            let scale = 1;
            if (animatorState.yoyo) {
                scale = 2;
            }
            let pTime = playState._playAllTime / (clipDuration * scale);
            if (Math.floor(pAllTime / (clipDuration * scale)) < Math.floor(pTime)) {
                isReplay = true;
            }
            var playTime = normalizedTime % 1.0;
            let normalizedPlayTime = playTime < 0 ? playTime + 1.0 : playTime;
            playState._normalizedPlayTime = normalizedPlayTime;
            playState._duration = clipDuration;
            if (1 != scale) {
                normalizedTime = playState._playAllTime / (clipDuration * scale);
                playTime = normalizedTime % 1.0;
                normalizedPlayTime = playTime < 0 ? playTime + 1.0 : playTime;
                if (animatorState.yoyo) {
                    if (0.5 > normalizedPlayTime) {
                        if (!playState._frontPlay) {
                            if (0 > animatorState.speed) {
                                playState._elapsedTime = animatorState.clipEnd * pAllTime;
                                playState._normalizedPlayTime = animatorState.clipEnd;
                            }
                            else {
                                playState._elapsedTime = animatorState.clipStart * pAllTime;
                                playState._normalizedPlayTime = animatorState.clipStart;
                            }
                            playState._frontPlay = true;
                        }
                    }
                    else {
                        if (playState._frontPlay) {
                            playState._frontPlay = false;
                            if (0 > animatorState.speed) {
                                playState._elapsedTime = animatorState.clipStart * pAllTime;
                                playState._normalizedPlayTime = animatorState.clipStart;
                            }
                            else {
                                playState._elapsedTime = animatorState.clipEnd * pAllTime;
                                playState._normalizedPlayTime = animatorState.clipEnd;
                            }
                        }
                    }
                }
            }
            animatorState._eventStateUpdate(normalizedPlayTime);
            let ret = this._applyTransition(layerIndex, animatorState._eventtransition(normalizedPlayTime, this.parameters, isReplay));
            if (!ret && isReplay) {
                let absTime = playState._playAllTime / (clipDuration * scale);
                if (0 < loop && loop <= absTime) {
                    playState._finish = true;
                    if (0 > animatorState.speed) {
                        if (animatorState.yoyo) {
                            playState._elapsedTime = animatorState.clipEnd * pAllTime;
                            playState._normalizedPlayTime = animatorState.clipEnd;
                        }
                        else {
                            playState._elapsedTime = animatorState.clipStart * pAllTime;
                            playState._normalizedPlayTime = animatorState.clipStart;
                        }
                    }
                    else {
                        if (animatorState.yoyo) {
                            playState._elapsedTime = animatorState.clipStart * pAllTime;
                            playState._normalizedPlayTime = animatorState.clipStart;
                        }
                        else {
                            playState._elapsedTime = animatorState.clipEnd * pAllTime;
                            playState._normalizedPlayTime = animatorState.clipEnd;
                        }
                    }
                    return;
                }
                else {
                    animatorState._eventLoop();
                }
            }
        }
        _updateEventScript(stateInfo, playStateInfo) {
            let clip = stateInfo._clip;
            let events = clip._animationEvents;
            if (!events || 0 == events.length)
                return;
            let clipDuration = clip._duration;
            let time = playStateInfo._normalizedPlayTime * clipDuration;
            let frontPlay = playStateInfo._frontPlay;
            const speed = playStateInfo._currentState.speed;
            if (0 > speed)
                frontPlay = !frontPlay;
            let pTime = playStateInfo._parentPlayTime;
            let parentPlayTime = playStateInfo._parentPlayTime;
            if (null == parentPlayTime) {
                if (frontPlay) {
                    parentPlayTime = clipDuration * playStateInfo.animatorState.clipStart;
                }
                else {
                    parentPlayTime = clipDuration * playStateInfo.animatorState.clipEnd;
                }
            }
            if (frontPlay) {
                if (time < parentPlayTime) {
                    this._eventScript(events, parentPlayTime, time, true);
                    parentPlayTime = clipDuration * playStateInfo.animatorState.clipStart;
                }
            }
            else {
                if (time > parentPlayTime) {
                    this._eventScript(events, parentPlayTime, time, false);
                    parentPlayTime = clipDuration * playStateInfo.animatorState.clipEnd;
                }
            }
            this._eventScript(events, parentPlayTime, time, frontPlay);
            if (pTime == playStateInfo._parentPlayTime) {
                playStateInfo._parentPlayTime = time;
            }
        }
        _eventScript(events, parentPlayTime, currPlayTime, frontPlay) {
            let scripts = this.owner.components;
            if (frontPlay) {
                for (let i = 0, len = events.length; i < len; i++) {
                    let e = events[i];
                    if (e.time > parentPlayTime && e.time <= currPlayTime) {
                        for (let j = 0, m = scripts.length; j < m; j++) {
                            let script = scripts[j];
                            if (script._isScript()) {
                                let fun = script[e.eventName];
                                (fun) && (fun.apply(script, e.params));
                            }
                        }
                    }
                    else if (e.time > currPlayTime) {
                        break;
                    }
                }
            }
            else {
                for (let i = events.length - 1; i >= 0; i--) {
                    let e = events[i];
                    if (e.time < parentPlayTime && e.time >= currPlayTime) {
                        for (let j = 0, m = scripts.length; j < m; j++) {
                            let script = scripts[j];
                            if (script._isScript()) {
                                let fun = script[e.eventName];
                                (fun) && (fun.apply(script, e.params));
                            }
                        }
                    }
                    else if (e.time < currPlayTime) {
                        break;
                    }
                }
            }
        }
        _applyTransition(layerindex, transition) {
            if (!transition)
                return false;
            return this.crossFade(transition.destState.name, layerindex, transition.transstartoffset, transition.transduration);
        }
        _applyUpdateMode(delta) {
            let ret;
            switch (this._updateMode) {
                case exports.AnimatorUpdateMode.Normal:
                    ret = delta;
                    break;
                case exports.AnimatorUpdateMode.LowFrame:
                    ret = (Stat.loopCount % this._lowUpdateDelty == 0) ? delta * this._lowUpdateDelty : 0;
                    break;
                case exports.AnimatorUpdateMode.UnScaleTime:
                    ret = 0;
                    break;
            }
            return ret;
        }
        gotoAndStopByFrame(name, layerIndex, frame) {
            var controllerLayer = this._controllerLayers[layerIndex];
            if (controllerLayer) {
                var animatorState = controllerLayer.getStateByName(name);
                if (!animatorState || !animatorState._clip)
                    return;
                var allFrame = animatorState._clip._duration * animatorState._clip._frameRate;
                let normalizedTime = frame / allFrame;
                if (1 < normalizedTime)
                    normalizedTime = 1;
                this.gotoAndStop(name, layerIndex, normalizedTime);
            }
        }
        getControllerLayer(layerIndex = 0) {
            return this._controllerLayers[layerIndex];
        }
        gotoAndStop(name, layerIndex, normalizedTime) {
            var controllerLayer = this._controllerLayers[layerIndex];
            if (controllerLayer) {
                var animatorState = controllerLayer.getStateByName(name);
                if (!animatorState || !animatorState._clip)
                    return;
                var playStateInfo = controllerLayer._playStateInfo;
                var curPlayState = playStateInfo._currentState;
                var clipDuration = animatorState._clip._duration;
                var calclipduration = animatorState._clip._duration * (animatorState.clipEnd - animatorState.clipStart);
                playStateInfo._resetPlayState(clipDuration * normalizedTime, calclipduration);
                playStateInfo._normalizedPlayTime = normalizedTime;
                controllerLayer._playType = 0;
                if (curPlayState !== animatorState) {
                    playStateInfo._currentState = animatorState;
                }
                animatorState._eventStart(this, layerIndex);
                let addtive = controllerLayer.blendingMode != AnimatorControllerLayer2D.BLENDINGMODE_OVERRIDE;
                this._updateClipDatas(animatorState, addtive, playStateInfo);
                this._setClipDatasToNode(animatorState, addtive, controllerLayer.defaultWeight, controllerLayer);
                this.stop();
            }
        }
        play(name, layerIndex = 0, normalizedTime = Number.NEGATIVE_INFINITY) {
            if (this._checkEnterIndex) {
                let i = this._checkEnterIndex.indexOf(layerIndex);
                if (0 <= i) {
                    this._checkEnterIndex.splice(i, 1);
                }
            }
            this._isPlaying = true;
            var controllerLayer = this._controllerLayers[layerIndex];
            if (controllerLayer) {
                var defaultState = controllerLayer.defaultState;
                if (!name && !defaultState)
                    throw new Error("Animator:must have default clip value,please set clip property.");
                var playStateInfo = controllerLayer._playStateInfo;
                var curPlayState = playStateInfo._currentState;
                var animatorState = name ? controllerLayer.getStateByName(name) : defaultState;
                if (!animatorState._clip)
                    return;
                var clipDuration = animatorState._clip._duration;
                var calclipduration = animatorState._clip._duration * (animatorState.clipEnd - animatorState.clipStart);
                if (curPlayState !== animatorState) {
                    if (normalizedTime !== Number.NEGATIVE_INFINITY)
                        playStateInfo._resetPlayState(clipDuration * normalizedTime, calclipduration);
                    else
                        playStateInfo._resetPlayState(0.0, calclipduration);
                    controllerLayer._playType = 0;
                    playStateInfo._currentState = animatorState;
                }
                else {
                    if (normalizedTime !== Number.NEGATIVE_INFINITY) {
                        playStateInfo._resetPlayState(clipDuration * normalizedTime, calclipduration);
                        controllerLayer._playType = 0;
                    }
                }
                animatorState._eventStart(this, layerIndex);
            }
        }
        stop() {
            this._isPlaying = false;
        }
        onUpdate() {
            if (!this._isPlaying)
                return;
            if (this._checkEnterIndex) {
                for (let i = this._checkEnterIndex.length - 1; i >= 0; i--) {
                    let index = this._checkEnterIndex[i];
                    let enterTransition = this._controllerLayers[index]._enterTransition;
                    if (enterTransition.check(0, this.parameters, true)) {
                        var defaultClip = this.getDefaultState(index);
                        this.play(null, index, defaultClip.cycleOffset);
                    }
                }
            }
            var delta = this.owner.timer._delta / 1000.0;
            delta = this._applyUpdateMode(delta);
            if (0 == this.speed || 0 == delta)
                return;
            for (var i = 0, n = this._controllerLayers.length; i < n; i++) {
                var controllerLayer = this._controllerLayers[i];
                if (!controllerLayer.enable)
                    continue;
                var playStateInfo = controllerLayer._playStateInfo;
                var addtive = controllerLayer.blendingMode != AnimatorControllerLayer2D.BLENDINGMODE_OVERRIDE;
                switch (controllerLayer._playType) {
                    case 0:
                        var animatorState = playStateInfo._currentState;
                        var speed = this._speed * animatorState.speed;
                        var finish = playStateInfo._finish;
                        var loop = animatorState.loop;
                        if (-1 >= loop) {
                            var clip = animatorState._clip;
                            if (clip.islooping) {
                                loop = 0;
                            }
                            else {
                                loop = 1;
                            }
                        }
                        let dir = 1;
                        if (!playStateInfo._frontPlay) {
                            dir = -1;
                        }
                        finish || this._updatePlayer(animatorState, playStateInfo, delta * speed * dir, loop, i);
                        playStateInfo = controllerLayer._playStateInfo;
                        animatorState = playStateInfo._currentState;
                        {
                            this._updateClipDatas(animatorState, addtive, playStateInfo);
                            if (!finish) {
                                this._setClipDatasToNode(animatorState, addtive, controllerLayer.defaultWeight, controllerLayer);
                                this._updateEventScript(animatorState, playStateInfo);
                            }
                        }
                        finish || this._updateStateFinish(animatorState, playStateInfo);
                        break;
                }
            }
        }
        addControllerLayer(controllerLayer) {
            this._controllerLayers.push(controllerLayer);
        }
        crossFade(name, layerIndex = 0, normalizedTime = Number.NEGATIVE_INFINITY, transitionDuration) {
            var controllerLayer = this._controllerLayers[layerIndex];
            if (controllerLayer) {
                var destAnimatorState = controllerLayer.getStateByName(name);
                if (destAnimatorState) {
                    this.play(name, layerIndex, normalizedTime);
                    return true;
                }
                else {
                    console.warn("Invalid layerIndex " + layerIndex + ".");
                }
            }
            return false;
        }
        onAfterDeserialize() {
            let arr = this.controllerLayers;
            if (!arr || null != this.controller)
                return;
            delete this.controllerLayers;
            this._controllerLayers.length = 0;
            for (let layer of arr) {
                this.addControllerLayer(layer);
            }
        }
        onEnable() {
            if (this._checkEnterIndex)
                this._checkEnterIndex.length = 0;
            else
                this._checkEnterIndex = [];
            if (this._isPlaying) {
                for (var i = 0, n = this._controllerLayers.length; i < n; i++) {
                    if (this._controllerLayers[i].playOnWake) {
                        var defaultClip = this.getDefaultState(i);
                        if (defaultClip) {
                            let enterTransition = this._controllerLayers[i]._enterTransition;
                            if (enterTransition) {
                                this._isPlaying = true;
                                if (enterTransition.check(0, this.parameters, true)) {
                                    this.play(null, i, defaultClip.cycleOffset);
                                }
                                else {
                                    this._checkEnterIndex.push(i);
                                }
                            }
                            else {
                                this.play(null, i, defaultClip.cycleOffset);
                            }
                        }
                    }
                }
            }
        }
        getDefaultState(layerIndex = 0) {
            var controllerLayer = this._controllerLayers[layerIndex];
            return controllerLayer.defaultState;
        }
        setParamsTrigger(name) {
            this._parameters[name] = { name: name, type: exports.AniParmType.Trigger, value: true };
        }
        setParamsNumber(name, value) {
            this._parameters[name] = { name: name, type: exports.AniParmType.Float, value: value };
        }
        setParamsBool(name, value) {
            this._parameters[name] = { name: name, type: exports.AniParmType.Float, value: value };
        }
        getParamsvalue(name) {
            let parm = this._parameters[name];
            if (parm) {
                return parm.value;
            }
            return null;
        }
        onDestroy() {
            if (this._controller) {
                this._controller._removeReference();
                this._controller = null;
            }
            for (var i = 0, n = this._controllerLayers.length; i < n; i++)
                this._controllerLayers[i].destroy();
            this._controllerLayers.length = 0;
            this._isPlaying = false;
            this._parameters = null;
        }
    }

    class AnimatorState2D extends EventDispatcher {
        constructor() {
            super(...arguments);
            this._referenceCount = 0;
            this._clip = null;
            this._currentFrameIndices = null;
            this.cycleOffset = 0;
            this.speed = 1.0;
            this.clipStart = 0.0;
            this.clipEnd = 1.0;
            this.loop = -1;
            this.yoyo = false;
            this.transitions = [];
            this.soloTransitions = [];
            this._scripts = null;
            this._realtimeDatas = [];
        }
        get clip() {
            return this._clip;
        }
        set clip(value) {
            if (this._clip != value) {
                if (this._clip)
                    (this._referenceCount > 0) && (this._clip._removeReference(this._referenceCount));
                if (value) {
                    var clipNodes = value._nodes;
                    var count = clipNodes.count;
                    this._currentFrameIndices = new Int16Array(count);
                    this._resetFrameIndices();
                    (this._referenceCount > 0) && (value._addReference(this._referenceCount));
                    this._realtimeDatas.length = count;
                }
                this._clip = value;
            }
        }
        _eventStateUpdate(value) {
            this.event(AnimatorState2D.EVENT_OnStateUpdate, value);
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++)
                    this._scripts[i].onStateUpdate(value);
            }
        }
        _eventStart(animator, layerIndex) {
            this.event(AnimatorState2D.EVENT_OnStateEnter);
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++) {
                    this._scripts[i].setPlayScriptInfo(animator, layerIndex, this);
                    this._scripts[i].onStateEnter();
                }
            }
        }
        _eventExit() {
            this.event(AnimatorState2D.EVENT_OnStateExit);
            if (this._scripts) {
                for (let i = 0, n = this._scripts.length; i < n; i++) {
                    this._scripts[i].onStateExit();
                }
            }
        }
        _eventLoop() {
            this.event(AnimatorState2D.EVENT_OnStateLoop);
            if (this._scripts) {
                for (let i = 0, n = this._scripts.length; i < n; i++) {
                    if (this._scripts[i].onStateLoop)
                        this._scripts[i].onStateLoop();
                }
            }
        }
        _eventtransition(normalizeTime, paramsMap, isReplay) {
            let soloNums = this.soloTransitions.length;
            if (soloNums > 0) {
                for (var i = 0; i < soloNums; i++) {
                    if (this.soloTransitions[i].check(normalizeTime, paramsMap, isReplay))
                        return this.soloTransitions[i];
                }
                return null;
            }
            let transNums = this.transitions.length;
            for (var i = 0; i < transNums; i++) {
                if (this.transitions[i].check(normalizeTime, paramsMap, isReplay))
                    return this.transitions[i];
            }
            return null;
        }
        _resetFrameIndices() {
            for (var i = 0, n = this._currentFrameIndices.length; i < n; i++)
                this._currentFrameIndices[i] = -1;
        }
        _getReferenceCount() {
            return this._referenceCount;
        }
        _addReference(count) {
            (this._clip) && (this._clip._addReference(count));
            this._referenceCount += count;
        }
        _removeReference(count) {
            (this._clip) && (this._clip._removeReference(count));
            this._referenceCount -= count;
        }
        _clearReference() {
            this._removeReference(-this._referenceCount);
        }
        addScript(type) {
            var script = new type();
            this._scripts = this._scripts || [];
            this._scripts.push(script);
            return script;
        }
        getScript(type) {
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++) {
                    var script = this._scripts[i];
                    if (script instanceof type)
                        return script;
                }
            }
            return null;
        }
        getScripts(type) {
            var coms = null;
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++) {
                    var script = this._scripts[i];
                    if (script instanceof type) {
                        coms = coms || [];
                        coms.push(script);
                    }
                }
            }
            return coms;
        }
        clone() {
            var dest = new AnimatorState2D();
            this.cloneTo(dest);
            return dest;
        }
        cloneTo(destObject) {
            destObject.name = this.name;
            destObject.speed = this.speed;
            destObject.clip = this._clip;
        }
        destroy() {
            this._clip = null;
            this._currentFrameIndices = null;
            this._scripts = null;
            this._realtimeDatas.length = 0;
        }
    }
    AnimatorState2D.EVENT_OnStateEnter = "OnStartEnter";
    AnimatorState2D.EVENT_OnStateUpdate = "OnStateUpdate";
    AnimatorState2D.EVENT_OnStateExit = "OnStateExit";
    AnimatorState2D.EVENT_OnStateLoop = 'OnStateLoop';

    class KeyframeNode2D {
        constructor() {
            this._ownerPath = [];
            this._propertys = [];
            this._keyFrames = [];
        }
        get keyFramesCount() {
            return this._keyFrames.length;
        }
        _setOwnerPathCount(value) {
            this._ownerPath.length = value;
        }
        _setOwnerPathByIndex(index, value) {
            this._ownerPath[index] = value;
        }
        _setPropertyCount(value) {
            this._propertys.length = value;
        }
        _setPropertyByIndex(index, value) {
            this._propertys[index] = value;
        }
        _setKeyframeCount(value) {
            this._keyFrames.length = value;
        }
        _joinOwnerPath(sep) {
            return this._ownerPath.join(sep);
        }
        _joinProperty(sep) {
            return this._propertys.join(sep);
        }
        getKeyframeByIndex(index) {
            return this._keyFrames[index];
        }
        get ownerPathCount() {
            return this._ownerPath.length;
        }
        get propertyCount() {
            return this._propertys.length;
        }
        getOwnerPathByIndex(index) {
            return this._ownerPath[index];
        }
        getPropertyByIndex(index) {
            return this._propertys[index];
        }
    }

    class Keyframe2D {
        clone() {
            var dest = new Keyframe2D();
            this.cloneTo(dest);
            return dest;
        }
        cloneTo(destObject) {
            destObject.time = this.time;
        }
    }
    Keyframe2D.defaultWeight = 0.33333;

    class Animation2DEvent {
        constructor() {
        }
    }

    class AnimationClip2DParse01 {
        static READ_DATA() {
            this._DATA.offset = this._reader.getUint32();
            this._DATA.size = this._reader.getUint32();
        }
        static READ_BLOCK() {
            var count = this._BLOCK.count = this._reader.getUint16();
            var blockStarts = this._BLOCK.blockStarts = [];
            var blockLengths = this._BLOCK.blockLengths = [];
            for (var i = 0; i < count; i++) {
                blockStarts.push(this._reader.getUint32());
                blockLengths.push(this._reader.getUint32());
            }
        }
        static READ_STRINGS() {
            var offset = this._reader.getUint32();
            var count = this._reader.getUint16();
            var prePos = this._reader.pos;
            this._reader.pos = offset + this._DATA.offset;
            for (var i = 0; i < count; i++)
                this._strings[i] = this._reader.readUTFString();
            this._reader.pos = prePos;
        }
        static parse(clip, reader, version) {
            this._clip = clip;
            this._reader = reader;
            this._version = version;
            this.READ_DATA();
            this.READ_BLOCK();
            this.READ_STRINGS();
            for (var i = 0, n = this._BLOCK.count; i < n; i++) {
                var index = reader.getUint16();
                var blockName = this._strings[index];
                var fn = this["READ_" + blockName];
                if (!fn) {
                    throw new Error("model file err,no this function:" + index + " " + blockName);
                }
                else
                    fn.call(this);
            }
            this._version = null;
            this._reader = null;
            this._clip = null;
            this._strings.length = 0;
        }
        static timeToFrame(second, fps) {
            return Math.round(second * fps);
        }
        static READ_ANIMATIONS2D() {
            var i, j;
            var reader = this._reader;
            var clip = this._clip;
            var node;
            var numList = [];
            var numCount = reader.getUint16();
            numList.length = numCount;
            for (i = 0; i < numCount; i++) {
                numList[i] = reader.getFloat32();
            }
            clip._duration = numList[reader.getInt16()];
            clip.islooping = !!reader.getByte();
            clip._frameRate = reader.getInt16();
            var nodeCount = reader.getInt16();
            var nodes = clip._nodes;
            nodes.count = nodeCount;
            var nodesMap = clip._nodesMap = {};
            var nodesDic = clip._nodesDic = {};
            for (i = 0; i < nodeCount; i++) {
                node = new KeyframeNode2D();
                nodes.setNodeByIndex(i, node);
                node._indexInList = i;
                var pathLength = reader.getUint16();
                node._setOwnerPathCount(pathLength);
                for (j = 0; j < pathLength; j++) {
                    node._setOwnerPathByIndex(j, this._strings[reader.getUint16()]);
                }
                var nodePath = node._joinOwnerPath("/");
                var mapArray = nodesMap[nodePath];
                (mapArray) || (nodesMap[nodePath] = mapArray = []);
                mapArray.push(node);
                var propertyLength = reader.getUint16();
                node._setPropertyCount(propertyLength);
                for (j = 0; j < propertyLength; j++) {
                    node._setPropertyByIndex(j, this._strings[reader.getUint16()]);
                }
                var fullPath = nodePath + "." + node._joinProperty(".");
                nodesDic[fullPath] = node;
                node.fullPath = fullPath;
                node.nodePath = nodePath;
                var keyframeCount = reader.getUint16();
                for (j = 0; j < keyframeCount; j++) {
                    var k = new Keyframe2D();
                    k.time = numList[reader.getUint16()];
                    k.data = { f: this.timeToFrame(k.time, clip._frameRate), val: 0 };
                    if (1 == reader.getByte()) {
                        k.data.tweenType = this._strings[reader.getUint16()];
                    }
                    if (1 == reader.getByte()) {
                        k.data.tweenInfo = {};
                        k.data.tweenInfo.inTangent = numList[reader.getUint16()];
                        k.data.tweenInfo.outTangent = numList[reader.getUint16()];
                        if (1 == reader.getByte()) {
                            k.data.tweenInfo.inWeight = numList[reader.getUint16()];
                        }
                        if (1 == reader.getByte()) {
                            k.data.tweenInfo.outWeight = numList[reader.getUint16()];
                        }
                    }
                    var num = reader.getByte();
                    if (0 == num) {
                        k.data.val = numList[reader.getUint16()];
                    }
                    else if (1 == num) {
                        k.data.val = this._strings[reader.getUint16()];
                    }
                    else if (2 == num) {
                        k.data.val = !!reader.getByte();
                    }
                    if (1 == reader.getByte()) {
                        try {
                            k.data.extend = JSON.parse(this._strings[reader.getUint16()]);
                        }
                        catch (err) { }
                    }
                    node._keyFrames.push(k);
                }
            }
            var eventCount = reader.getUint16();
            for (i = 0; i < eventCount; i++) {
                var event = new Animation2DEvent();
                event.time = numList[reader.getUint16()];
                event.eventName = this._strings[reader.getUint16()];
                var params = [];
                var paramCount = reader.getUint16();
                (paramCount > 0) && (event.params = params = []);
                for (j = 0; j < paramCount; j++) {
                    var eventType = reader.getByte();
                    switch (eventType) {
                        case 0:
                            params.push(!!reader.getByte());
                            break;
                        case 1:
                            params.push(reader.getInt32());
                            break;
                        case 2:
                            params.push(numList[reader.getUint16()]);
                            break;
                        case 3:
                            params.push(this._strings[reader.getUint16()]);
                            break;
                        default:
                            throw new Error("unknown type.");
                    }
                }
                clip.addEvent(event);
            }
        }
    }
    AnimationClip2DParse01._strings = [];
    AnimationClip2DParse01._DATA = { offset: 0, size: 0 };
    AnimationClip2DParse01._BLOCK = { count: 0 };

    class KeyframeNodeList2D {
        constructor() {
            this._nodes = [];
        }
        get count() {
            return this._nodes.length;
        }
        set count(value) {
            this._nodes.length = value;
        }
        getNodeByIndex(index) {
            return this._nodes[index];
        }
        setNodeByIndex(index, node) {
            this._nodes[index] = node;
        }
    }

    class AnimationClip2D extends Resource {
        static _parse(data) {
            var clip = new AnimationClip2D();
            var reader = new Byte(data);
            var version = reader.readUTFString();
            switch (version) {
                case "LAYAANIMATION2D:01":
                    AnimationClip2DParse01.parse(clip, reader, version);
                    break;
                default:
                    throw "unknown animationClip version.";
            }
            return clip;
        }
        constructor() {
            super();
            this._nodes = new KeyframeNodeList2D();
            this._animationEvents = [];
        }
        duration() {
            return this._duration;
        }
        _evaluateClipDatasRealTime(playCurTime, realTimeCurrentFrameIndexes, addtive, frontPlay, outDatas) {
            var nodes = this._nodes;
            for (var i = 0, n = nodes.count; i < n; i++) {
                var node = nodes.getNodeByIndex(i);
                var nextFrameIndex;
                var keyFrames = node._keyFrames;
                var keyFramesCount = keyFrames.length;
                if (0 == keyFramesCount)
                    continue;
                var frameIndex = realTimeCurrentFrameIndexes[i];
                if (frontPlay) {
                    if ((-1 != frameIndex) && (playCurTime < keyFrames[frameIndex].time)) {
                        frameIndex = -1;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                    nextFrameIndex = frameIndex + 1;
                    while (nextFrameIndex < keyFramesCount) {
                        if (keyFrames[nextFrameIndex].time > playCurTime)
                            break;
                        frameIndex++;
                        nextFrameIndex++;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                }
                else {
                    nextFrameIndex = frameIndex + 1;
                    if ((nextFrameIndex != keyFramesCount) && (playCurTime > keyFrames[nextFrameIndex].time)) {
                        frameIndex = keyFramesCount - 1;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                    nextFrameIndex = frameIndex + 1;
                    while (frameIndex > -1) {
                        if (keyFrames[frameIndex].time < playCurTime)
                            break;
                        frameIndex--;
                        nextFrameIndex--;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                }
                var isEnd = nextFrameIndex == keyFramesCount;
                if (-1 != frameIndex) {
                    var frame = keyFrames[frameIndex];
                    if (isEnd) {
                        outDatas[i] = frame.data.val;
                    }
                    else {
                        var nextFarme = keyFrames[nextFrameIndex];
                        var d = nextFarme.time - frame.time;
                        var t;
                        if (d !== 0)
                            t = (playCurTime - frame.time) / d;
                        else
                            t = 0;
                        outDatas[i] = this._getTweenVal(frame, nextFarme, t, d);
                    }
                }
                else {
                    outDatas[i] = keyFrames[0].data.val;
                }
                if (addtive && "number" == typeof keyFrames[0].data.val) {
                    outDatas[i] = outDatas[i] - keyFrames[0].data.val;
                }
            }
        }
        _getTweenVal(frame, nextFrame, t, dur) {
            var start = frame.data;
            var end = nextFrame.data;
            if ("number" != typeof start.val || "number" != typeof end.val) {
                return start.val;
            }
            var tweenFun = AnimationClip2D.tween[start.tweenType];
            var poval = start.val;
            var oval = end.val;
            if (null != tweenFun) {
                return tweenFun(t, poval, oval - poval, 1);
            }
            var outTangent = 0;
            var inTangent = 0;
            var outWeight = NaN;
            var inWeight = NaN;
            if (null != start.tweenInfo) {
                outTangent = start.tweenInfo.outTangent;
                outWeight = start.tweenInfo.outWeight;
            }
            if (null != end.tweenInfo) {
                inTangent = end.tweenInfo.inTangent;
                inWeight = end.tweenInfo.inWeight;
            }
            if (isNaN(outWeight) || 0 >= outWeight)
                outWeight = Keyframe2D.defaultWeight;
            if (isNaN(inWeight) || 0 >= inWeight)
                inWeight = Keyframe2D.defaultWeight;
            if (isNaN(outTangent))
                outTangent = 0;
            if (isNaN(inTangent))
                inTangent = 0;
            if (Math.abs(outTangent) == Number.MAX_VALUE) {
                if (0 > outTangent) {
                    outTangent = -Infinity;
                }
                else {
                    outTangent = Infinity;
                }
            }
            if (Math.abs(inTangent) == Number.MAX_VALUE) {
                if (0 > inTangent) {
                    inTangent = -Infinity;
                }
                else {
                    inTangent = Infinity;
                }
            }
            var tnum;
            if ((!start.tweenInfo && !end.tweenInfo) || (Keyframe2D.defaultWeight == inWeight && Keyframe2D.defaultWeight == outWeight)) {
                tnum = AnimationClip2D.tween.hermiteInterpolate(outTangent, inTangent, poval, oval, t, dur);
            }
            else {
                tnum = this.hermiteCurveSplineWeight(poval, frame.time, outWeight, outTangent, oval, nextFrame.time, inWeight, inTangent, t);
            }
            return tnum;
        }
        _binarySearchEventIndex(time) {
            var start = 0;
            var end = this._animationEvents.length - 1;
            var mid;
            while (start <= end) {
                mid = (start + end) >> 1;
                var midValue = this._animationEvents[mid].time;
                if (midValue == time)
                    return mid;
                else if (midValue > time)
                    end = mid - 1;
                else
                    start = mid + 1;
            }
            return start;
        }
        hermiteCurveSplineWeight(frameValue, frametime, frameOutWeight, frameOutTangent, nextframeValue, nextframetime, nextframeInweight, nextframeIntangent, time) {
            let Eps = 2.22e-16;
            let x = time;
            let x1 = frametime;
            let y1 = frameValue;
            let wt1 = frameOutWeight;
            let x2 = nextframetime;
            let y2 = nextframeValue;
            let wt2 = nextframeInweight;
            let dx = x2 - x1;
            let dy = y2 - y1;
            dy = Math.max(Math.abs(dy), Eps) * (dy < 0 ? -1 : 1);
            let yp1 = frameOutTangent;
            let yp2 = nextframeIntangent;
            if (!Number.isFinite(yp1) || !Number.isFinite(yp2)) {
                return frameValue;
            }
            yp1 = yp1 * dx / dy;
            yp2 = yp2 * dx / dy;
            let wt2s = 1 - wt2;
            let t = 0.5;
            let t2 = 0;
            if (Math.abs(wt1 - 0.33333334) < 0.0001 && Math.abs(wt2 - 0.33333334) < 0.0001) {
                t = x;
                t2 = 1 - t;
            }
            else {
                while (true) {
                    t2 = (1 - t);
                    let fg = 3 * t2 * t2 * t * wt1 + 3 * t2 * t * t * wt2s + t * t * t - x;
                    if (Math.abs(fg) <= 2.5 * Eps)
                        break;
                    let fpg = 3 * t2 * t2 * wt1 + 6 * t2 * t * (wt2s - wt1) + 3 * t * t * (1 - wt2s);
                    let fppg = 6 * t2 * (wt2s - 2 * wt1) + 6 * t * (1 - 2 * wt2s + wt1);
                    let fpppg = 18 * wt1 - 18 * wt2s + 6;
                    t -= (6 * fg * fpg * fpg - 3 * fg * fg * fppg) / (6 * fpg * fpg * fpg - 6 * fg * fpg * fppg + fg * fg * fpppg);
                }
            }
            let y = 3 * t2 * t2 * t * wt1 * yp1 + 3 * t2 * t * t * (1 - wt2 * yp2) + t * t * t;
            return y * dy + y1;
        }
        addEvent(event) {
            var index = this._binarySearchEventIndex(event.time);
            this._animationEvents.splice(index, 0, event);
        }
    }
    AnimationClip2D.tween = {
        Linear: function (t, b, c, d) { return c * t / d + b; },
        Quad_EaseIn: function (t, b, c, d) {
            return c * (t /= d) * t + b;
        },
        Quad_EaseOut: function (t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        },
        Quad_EaseInOut: function (t, b, c, d) {
            if ((t /= d / 2) < 1)
                return c / 2 * t * t + b;
            return -c / 2 * ((--t) * (t - 2) - 1) + b;
        },
        Cubic_EaseIn: function (t, b, c, d) {
            return c * (t /= d) * t * t + b;
        },
        Cubic_EaseOut: function (t, b, c, d) {
            return c * ((t = t / d - 1) * t * t + 1) + b;
        },
        Cubic_EaseInOut: function (t, b, c, d) {
            if ((t /= d / 2) < 1)
                return c / 2 * t * t * t + b;
            return c / 2 * ((t -= 2) * t * t + 2) + b;
        },
        Quart_EaseIn: function (t, b, c, d) {
            return c * (t /= d) * t * t * t + b;
        },
        Quart_EaseOut: function (t, b, c, d) {
            return -c * ((t = t / d - 1) * t * t * t - 1) + b;
        },
        Quart_EaseInOut: function (t, b, c, d) {
            if ((t /= d / 2) < 1)
                return c / 2 * t * t * t * t + b;
            return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
        },
        Quint_EaseIn: function (t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        },
        Quint_EaseOut: function (t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        },
        Quint_EaseInOut: function (t, b, c, d) {
            if ((t /= d / 2) < 1)
                return c / 2 * t * t * t * t * t + b;
            return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
        },
        Sine_EaseIn: function (t, b, c, d) {
            return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
        },
        Sine_EaseOut: function (t, b, c, d) {
            return c * Math.sin(t / d * (Math.PI / 2)) + b;
        },
        Sine_EaseInOut: function (t, b, c, d) {
            return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
        },
        Expo_EaseIn: function (t, b, c, d) {
            return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
        },
        Expo_EaseOut: function (t, b, c, d) {
            return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
        },
        Expo_EaseInOut: function (t, b, c, d) {
            if (t == 0)
                return b;
            if (t == d)
                return b + c;
            if ((t /= d / 2) < 1)
                return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
            return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
        },
        Circ_EaseIn: function (t, b, c, d) {
            return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
        },
        Circ_EaseOut: function (t, b, c, d) {
            return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
        },
        Circ_EaseInOut: function (t, b, c, d) {
            if ((t /= d / 2) < 1)
                return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
            return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
        },
        Elastic_EaseIn: function (t, b, c, d, a, p) {
            if (t == 0)
                return b;
            if ((t /= d) == 1)
                return b + c;
            if (!p)
                p = d * .3;
            if (!a || a < Math.abs(c)) {
                a = c;
                var s = p / 4;
            }
            else
                var s = p / (2 * Math.PI) * Math.asin(c / a);
            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        },
        Elastic_EaseOut: function (t, b, c, d, a, p) {
            if (t == 0)
                return b;
            if ((t /= d) == 1)
                return b + c;
            if (!p)
                p = d * .3;
            if (!a || a < Math.abs(c)) {
                a = c;
                var s = p / 4;
            }
            else
                var s = p / (2 * Math.PI) * Math.asin(c / a);
            return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
        },
        Elastic_EaseInOut: function (t, b, c, d, a, p) {
            if (t == 0)
                return b;
            if ((t /= d / 2) == 2)
                return b + c;
            if (!p)
                p = d * (.3 * 1.5);
            if (!a || a < Math.abs(c)) {
                a = c;
                var s = p / 4;
            }
            else
                var s = p / (2 * Math.PI) * Math.asin(c / a);
            if (t < 1)
                return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;
        },
        Back_EaseIn: function (t, b, c, d, s = undefined) {
            if (s == undefined)
                s = 1.70158;
            return c * (t /= d) * t * ((s + 1) * t - s) + b;
        },
        Back_EaseOut: function (t, b, c, d, s = undefined) {
            if (s == undefined)
                s = 1.70158;
            return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
        },
        Back_EaseInOut: function (t, b, c, d, s = undefined) {
            if (s == undefined)
                s = 1.70158;
            if ((t /= d / 2) < 1)
                return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
            return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
        },
        Bounce_EaseIn: function (t, b, c, d) {
            return c - AnimationClip2D.tween.Bounce_EaseOut(d - t, 0, c, d) + b;
        },
        Bounce_EaseOut: function (t, b, c, d) {
            if ((t /= d) < (1 / 2.75)) {
                return c * (7.5625 * t * t) + b;
            }
            else if (t < (2 / 2.75)) {
                return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
            }
            else if (t < (2.5 / 2.75)) {
                return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
            }
            else {
                return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
            }
        },
        Bounce_EaseInOut: function (t, b, c, d) {
            if (t < d / 2)
                return AnimationClip2D.tween.Bounce_EaseIn(t * 2, 0, c, d) * .5 + b;
            else
                return AnimationClip2D.tween.Bounce_EaseOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
        },
        hermiteInterpolate: function (outTangent, inTangent, startValue, endValue, t, dur) {
            if (Math.abs(outTangent) == Infinity || Math.abs(inTangent) == Infinity) {
                if (0 > outTangent || 0 < inTangent)
                    return startValue;
                return startValue;
            }
            var t2 = t * t;
            var t3 = t2 * t;
            var a = 2.0 * t3 - 3.0 * t2 + 1.0;
            var b = t3 - 2.0 * t2 + t;
            var c = t3 - t2;
            var d = -2.0 * t3 + 3.0 * t2;
            return a * startValue + b * outTangent * dur + c * inTangent * dur + d * endValue;
        }
    };

    class Animation2DParm {
    }

    exports.AniConditionType = void 0;
    (function (AniConditionType) {
        AniConditionType[AniConditionType["Greater"] = 0] = "Greater";
        AniConditionType[AniConditionType["Less"] = 1] = "Less";
        AniConditionType[AniConditionType["Equals"] = 2] = "Equals";
        AniConditionType[AniConditionType["NotEqual"] = 3] = "NotEqual";
    })(exports.AniConditionType || (exports.AniConditionType = {}));
    class Animation2DCondition {
    }

    class AnimatorStateCondition {
        static conditionNameToID(name) {
            if (AnimatorStateCondition._conditionNameMap[name] != null) {
                return AnimatorStateCondition._conditionNameMap[name];
            }
            else {
                var id = this._propertyNameCounter++;
                this._conditionNameMap[name] = id;
                this._conditionNameMap[id] = name;
                return id;
            }
        }
        static conditionIDToName(id) {
            return this._conditionNameMap[id];
        }
        constructor(name = null) {
            if (!name)
                return;
            this._id = AnimatorStateCondition.conditionNameToID(name);
            this._name = name;
        }
        get id() {
            return this._id;
        }
        get name() {
            return this._name;
        }
        set name(value) {
            this._id = AnimatorStateCondition.conditionNameToID(value);
            this._name = value;
        }
        get type() {
            return this._type;
        }
        checkState(value) {
            return false;
        }
    }
    AnimatorStateCondition._conditionNameMap = {};
    AnimatorStateCondition._propertyNameCounter = 0;
    class AnimatorStateNumberCondition extends AnimatorStateCondition {
        constructor(name) {
            super(name);
            this._numberValue = 0;
            this._numberCompareFlag = exports.AniStateConditionNumberCompressType.Greater;
            this._type = exports.AniStateConditionType.Number;
        }
        get numberValue() {
            return this._numberValue;
        }
        set numberValue(value) {
            this._numberValue = value;
        }
        get compareFlag() {
            return this._numberCompareFlag;
        }
        set compareFlag(value) {
            this._numberCompareFlag = value;
        }
        checkState(value) {
            if (exports.AniStateConditionNumberCompressType.Greater == this._numberCompareFlag)
                return value > this._numberValue;
            else
                return value < this._numberValue;
        }
    }
    class AnimatorStateBoolCondition extends AnimatorStateCondition {
        constructor(name) {
            super(name);
            this._compareFlag = true;
            this._type = exports.AniStateConditionType.Bool;
        }
        get compareFlag() {
            return this._compareFlag;
        }
        set compareFlag(value) {
            this._compareFlag = value;
        }
        checkState(value) {
            return this._compareFlag == value;
        }
    }
    class AnimatorStateTriggerCondition extends AnimatorStateCondition {
        constructor(name) {
            super(name);
            this._type = exports.AniStateConditionType.Trigger;
        }
        checkState(value) {
            return value;
        }
    }

    class AnimatorTransition2D {
        constructor() {
            this.conditions = [];
            this.exitByTime = true;
            this.exitTime = 1;
            this.transduration = 0;
            this.transstartoffset = 0;
            this.mute = false;
        }
        addCondition(condition) {
            if (this.conditions.indexOf(condition) == -1) {
                this.conditions.push(condition);
            }
        }
        removeCondition(condition) {
            let index = this.conditions.indexOf(condition);
            if (index != -1) {
                this.conditions.splice(index, 0);
            }
        }
        check(normalizeTime, paramsMap, isReplay) {
            if (this.mute)
                return false;
            if (this.exitByTime && (normalizeTime < this.exitTime && !isReplay))
                return false;
            if (!this.conditions || this.conditions.length === 0)
                return true;
            if (this.isAndOperEnabled) {
                for (let i = 0; i < this.conditions.length; i++) {
                    const con = this.conditions[i];
                    const out = con.checkState(paramsMap[con.name].value);
                    if (!out)
                        return false;
                    if (con.type === exports.AniStateConditionType.Trigger) {
                        paramsMap[con.name].value = false;
                    }
                }
                return true;
            }
            else {
                for (let i = 0; i < this.conditions.length; i++) {
                    const con = this.conditions[i];
                    const out = con.checkState(paramsMap[con.name].value);
                    if (out) {
                        if (con.type === exports.AniStateConditionType.Trigger) {
                            paramsMap[con.name].value = false;
                        }
                        return true;
                    }
                }
            }
            return false;
        }
    }

    class AnimatorController2D extends Resource {
        constructor(data) {
            super();
            let obj = AnimatorControllerParse.parse(data);
            this.data = obj.ret;
            this.clipsID = obj.clipsID;
        }
        getLayers() {
            let layers = this.data.controllerLayers;
            let lArr = [];
            for (let i = layers.length - 1; i >= 0; i--) {
                let l = layers[i];
                let acl = new AnimatorControllerLayer2D(l.name);
                lArr.unshift(acl);
                for (let k in l) {
                    if ("name" == k || "states" == k || null == l[k]) {
                        continue;
                    }
                    try {
                        acl[k] = l[k];
                    }
                    catch (err) {
                        console.error(err);
                    }
                }
                this.getState(l.states, acl, this.data);
            }
            return lArr;
        }
        createState(states, idCatch, acl) {
            if (!states)
                return null;
            let ret = {};
            let defID = null;
            for (let i = states.length - 1; i >= 0; i--) {
                let obj = states[i];
                let childStates = obj.states;
                if (childStates) {
                    let groupRet = this.createState(childStates, idCatch, acl);
                    if (groupRet) {
                        idCatch[obj.id] = groupRet.states[groupRet.id];
                    }
                    continue;
                }
                if (0 > Number(obj.id)) {
                    if ("-1" == obj.id) {
                        let transitions = obj.soloTransitions;
                        if (transitions && 0 < transitions.length) {
                            defID = transitions[0].id;
                        }
                    }
                    continue;
                }
                let state = new AnimatorState2D();
                idCatch[obj.id] = state;
                ret[obj.id] = state;
                for (let k in obj) {
                    try {
                        if ("scripts" == k) {
                            let scripts = obj[k];
                            if (scripts && Array.isArray(scripts)) {
                                for (let k = scripts.length - 1; k >= 0; k--) {
                                    let uuid = scripts[k];
                                    if (uuid && 0 == uuid.indexOf("res://")) {
                                        uuid = uuid.substring(6);
                                    }
                                    let c = ClassUtils.getClass(uuid);
                                    if (c) {
                                        state.addScript(c);
                                    }
                                }
                            }
                            continue;
                        }
                        else if ("soloTransitions" == k) {
                            continue;
                        }
                        else if (null != obj[k]) {
                            state[k] = obj[k];
                        }
                    }
                    catch (err) { }
                }
                acl.addState(state);
            }
            return { id: defID, states: ret };
        }
        getState(states, acl, data) {
            if (states) {
                let idCatch = {};
                this.createState(states, idCatch, acl);
                this.setTransitions(states, idCatch, acl, data);
            }
        }
        setExitTransition(exitRet, transitions, idCatch, data, pExitRet) {
            for (let id in exitRet) {
                let state = idCatch[id];
                if (state) {
                    let ats = state.transitions;
                    let sts = state.soloTransitions;
                    let linArr = exitRet[id];
                    for (let i = transitions.length - 1; i >= 0; i--) {
                        let t = transitions[i];
                        if ("-3" == t.id) {
                            if (null == pExitRet[id]) {
                                pExitRet[id] = [];
                            }
                            pExitRet[id].push(t);
                            continue;
                        }
                        for (let j = linArr.length - 1; j >= 0; j--) {
                            let t2 = linArr[j];
                            let ato = new AnimatorTransition2D();
                            ato.destState = idCatch[t.id];
                            if (t.conditions) {
                                this.addConditions(t.conditions, ato, data);
                            }
                            if (t2.conditions) {
                                this.addConditions(t2.conditions, ato, data);
                            }
                            for (let k in t) {
                                if ("solo" == k || "id" == k || "conditions" == k) {
                                    continue;
                                }
                                else {
                                    ato[k] = t[k];
                                }
                            }
                            if (t.solo) {
                                sts.unshift(ato);
                            }
                            else {
                                ats.unshift(ato);
                            }
                        }
                    }
                }
            }
        }
        _getAnimatorTransition2D(o, idCatch, data) {
            let ato = new AnimatorTransition2D();
            if (idCatch[o.id]) {
                ato.destState = idCatch[o.id];
            }
            if (o.conditions) {
                this.addConditions(o.conditions, ato, data);
            }
            for (let k in o) {
                if ("solo" == k || "id" == k || "conditions" == k) {
                    continue;
                }
                else {
                    ato[k] = o[k];
                }
            }
            return ato;
        }
        setTransitions(states, idCatch, acl, data, pState) {
            if (!states)
                return null;
            let exitRet = {};
            for (let i = states.length - 1; i >= 0; i--) {
                let obj = states[i];
                if (obj.states) {
                    let exitTransition = this.setTransitions(obj.states, idCatch, acl, data, obj);
                    if (exitTransition) {
                        let transitions = obj.soloTransitions;
                        if (transitions) {
                            this.setExitTransition(exitTransition, transitions, idCatch, data, exitRet);
                        }
                    }
                }
            }
            for (let i = states.length - 1; i >= 0; i--) {
                let obj = states[i];
                if (obj.states) {
                    continue;
                }
                if ("-1" == obj.id) {
                    if (obj.soloTransitions && 0 < obj.soloTransitions.length) {
                        if (null == pState) {
                            acl.defaultState = idCatch[obj.soloTransitions[0].id];
                            acl._enterTransition = this._getAnimatorTransition2D(obj.soloTransitions[0], idCatch, data);
                        }
                        else {
                            idCatch[pState.id] = idCatch[obj.soloTransitions[0].id];
                        }
                        continue;
                    }
                }
                else if ("-2" == obj.id) {
                    let transitions = obj.soloTransitions;
                    if (transitions) {
                        for (let j = transitions.length - 1; j >= 0; j--) {
                            let o = transitions[j];
                            let destState = idCatch[o.id];
                            if (destState) {
                                for (let idk in idCatch) {
                                    let state = idCatch[idk];
                                    let ato = this._getAnimatorTransition2D(o, idCatch, data);
                                    if (o.solo) {
                                        state.soloTransitions.unshift(ato);
                                    }
                                    else {
                                        state.transitions.unshift(ato);
                                    }
                                }
                            }
                        }
                    }
                    continue;
                }
                else if ("-3" == obj.id) {
                    continue;
                }
                let soloTransitions = obj.soloTransitions;
                if (soloTransitions && idCatch[obj.id]) {
                    let ats = idCatch[obj.id].transitions;
                    let sts = idCatch[obj.id].soloTransitions;
                    for (let j = soloTransitions.length - 1; j >= 0; j--) {
                        let o = soloTransitions[j];
                        if ("-3" == o.id) {
                            if (null == exitRet[obj.id]) {
                                exitRet[obj.id] = [];
                            }
                            exitRet[obj.id].push(o);
                            continue;
                        }
                        let ato = this._getAnimatorTransition2D(o, idCatch, data);
                        if (o.solo) {
                            sts.unshift(ato);
                        }
                        else {
                            ats.unshift(ato);
                        }
                    }
                }
            }
            return exitRet;
        }
        addConditions(arr, ato, data) {
            let parms = data.animatorParams;
            if (null == parms || 0 == parms.length)
                return;
            for (let i = 0, len = arr.length; i < len; i++) {
                let o = arr[i];
                let parm = null;
                for (let j = parms.length - 1; j >= 0; j--) {
                    if (parms[j].id == o.id) {
                        parm = parms[j];
                        break;
                    }
                }
                if (null == parm) {
                    return;
                }
                let c;
                if (parm.type == exports.AniParmType.Bool) {
                    let b = new AnimatorStateBoolCondition(parm.name);
                    b.compareFlag = Boolean(o.checkValue);
                    c = b;
                }
                else if (parm.type == exports.AniParmType.Float) {
                    let n = new AnimatorStateNumberCondition(parm.name);
                    n.numberValue = Number(o.checkValue);
                    n.compareFlag = o.type;
                    c = n;
                }
                else if (parm.type == exports.AniParmType.Trigger) {
                    let t = new AnimatorStateTriggerCondition(parm.name);
                    c = t;
                }
                ato.addCondition(c);
            }
        }
        updateTo(a) {
            let currLayer = a._controllerLayers;
            for (let i = 0, len = currLayer.length; i < len; i++) {
                currLayer[i].destroy();
            }
            currLayer.length = 0;
            let layers = this.getLayers();
            for (let i = 0, len = layers.length; i < len; i++) {
                a.addControllerLayer(layers[i]);
            }
            let parms = this.data.animatorParams;
            if (parms) {
                let setParm = {};
                for (let i = parms.length - 1; i >= 0; i--) {
                    let p = parms[i];
                    let sp = new Animation2DParm();
                    sp.name = p.name;
                    sp.type = p.type;
                    sp.value = p.val;
                    setParm[p.name] = sp;
                }
                a.parameters = setParm;
            }
        }
    }

    class Script extends Component {
        _isScript() {
            return true;
        }
        setupScript() {
            let owner = this.owner;
            let func;
            if (!(this.onTriggerEnter == Script.prototype.onTriggerEnter))
                owner.on(Event.TRIGGER_ENTER, this, this.onTriggerEnter);
            if (!(this.onTriggerStay == Script.prototype.onTriggerStay))
                owner.on(Event.TRIGGER_STAY, this, this.onTriggerStay);
            if (!(this.onTriggerExit == Script.prototype.onTriggerExit))
                owner.on(Event.TRIGGER_EXIT, this, this.onTriggerExit);
            if (!(this.onCollisionEnter == Script.prototype.onCollisionEnter))
                owner.on(Event.COLLISION_ENTER, this, this.onCollisionEnter);
            if (!(this.onCollisionStay == Script.prototype.onCollisionStay))
                owner.on(Event.COLLISION_STAY, this, this.onCollisionStay);
            if (!(this.onCollisionExit == Script.prototype.onCollisionExit))
                owner.on(Event.COLLISION_EXIT, this, this.onCollisionExit);
            if (func = this.onJointBreak)
                owner.on(Event.JOINT_BREAK, this, func);
            if (func = this.onMouseDown)
                owner.on(Event.MOUSE_DOWN, this, func);
            if (func = this.onMouseUp)
                owner.on(Event.MOUSE_UP, this, func);
            if (func = this.onRightMouseDown)
                owner.on(Event.RIGHT_MOUSE_DOWN, this, func);
            if (func = this.onRightMouseUp)
                owner.on(Event.RIGHT_MOUSE_UP, this, func);
            if (func = this.onMouseMove)
                owner.on(Event.MOUSE_MOVE, this, func);
            if (func = this.onMouseDrag)
                owner.on(Event.MOUSE_DRAG, this, func);
            if (func = this.onMouseDragEnd)
                owner.on(Event.MOUSE_DRAG_END, this, func);
            if (func = this.onMouseOver)
                owner.on(Event.MOUSE_OVER, this, func);
            if (func = this.onMouseOut)
                owner.on(Event.MOUSE_OUT, this, func);
            if (func = this.onMouseClick)
                owner.on(Event.CLICK, this, func);
            if (func = this.onMouseDoubleClick)
                owner.on(Event.DOUBLE_CLICK, this, func);
            if (func = this.onMouseRightClick)
                owner.on(Event.RIGHT_CLICK, this, func);
            if (func = this.onKeyDown)
                ILaya.stage.on(Event.KEY_DOWN, this, func);
            if (func = this.onKeyPress)
                ILaya.stage.on(Event.KEY_PRESS, this, func);
            if (func = this.onKeyUp)
                ILaya.stage.on(Event.KEY_UP, this, func);
            owner.event(Event._Add_Script);
        }
    }

    exports.TextResourceFormat = void 0;
    (function (TextResourceFormat) {
        TextResourceFormat[TextResourceFormat["Buffer"] = 0] = "Buffer";
        TextResourceFormat[TextResourceFormat["Plain"] = 1] = "Plain";
        TextResourceFormat[TextResourceFormat["JSON"] = 2] = "JSON";
        TextResourceFormat[TextResourceFormat["XML"] = 3] = "XML";
    })(exports.TextResourceFormat || (exports.TextResourceFormat = {}));
    class TextResource extends Resource {
        constructor(data, format) {
            super();
            this.data = data;
            this.format = format;
        }
    }

    class TextAssetLoader {
        load(task) {
            return task.loader.fetch(task.url, "text", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return new TextResource(data, exports.TextResourceFormat.Plain);
            });
        }
    }
    class BytesAssetLoader {
        load(task) {
            return task.loader.fetch(task.url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return new TextResource(data, exports.TextResourceFormat.Buffer);
            });
        }
    }
    class JsonAssetLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return new TextResource(data, exports.TextResourceFormat.JSON);
            });
        }
    }
    class XMLAssetLoader {
        load(task) {
            return task.loader.fetch(task.url, "xml", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return new TextResource(data, exports.TextResourceFormat.XML);
            });
        }
    }
    Loader.registerLoader(["txt", "csv"], TextAssetLoader, Loader.TEXT);
    Loader.registerLoader(["bin", "bytes", "fui"], BytesAssetLoader, Loader.BUFFER);
    Loader.registerLoader(["json"], JsonAssetLoader, Loader.JSON);
    Loader.registerLoader(["xml"], XMLAssetLoader, Loader.XML);

    class AtlasLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(0.2), task.options).then(data => {
                if (!data)
                    return null;
                let toloadPics = [];
                if (data.meta && data.meta.image) {
                    let folderPath = "";
                    let i = task.url.lastIndexOf("/");
                    if (i != -1)
                        folderPath = task.url.substring(0, i + 1);
                    let query = "";
                    i = task.url.lastIndexOf("?");
                    if (i != -1)
                        query = task.url.substring(i);
                    let pics = data.meta.image.split(",");
                    for (let pic of pics)
                        toloadPics.push(task.loader.load(folderPath + pic + query, null, task.progress.createCallback()));
                }
                else {
                    toloadPics.push(task.loader.load(Utils.replaceFileExtension(task.url, "png"), null, task.progress.createCallback()));
                }
                return Promise.all(toloadPics).then(pics => {
                    pics = pics.filter(pic => pic != null);
                    let baseUrl = task.options.baseUrl || "";
                    let frames = data.frames;
                    let directory = (data.meta && data.meta.prefix != null) ? data.meta.prefix : task.url.substring(0, task.url.lastIndexOf(".")) + "/";
                    let subTextures = [];
                    let scaleRate = 1;
                    if (data.meta && data.meta.scale && data.meta.scale != 1)
                        scaleRate = parseFloat(data.meta.scale);
                    for (let tPic of pics)
                        tPic.scaleRate = scaleRate;
                    for (let name in frames) {
                        let obj = frames[name];
                        let tPic = pics[obj.frame.idx ? obj.frame.idx : 0];
                        if (!tPic)
                            continue;
                        let url = baseUrl + directory + (obj.filename || name);
                        let tt = Texture.create(tPic, obj.frame.x, obj.frame.y, obj.frame.w, obj.frame.h, obj.spriteSourceSize.x, obj.spriteSourceSize.y, obj.sourceSize.w, obj.sourceSize.h);
                        tt._sizeGrid = obj.sizeGrid;
                        tt._stateNum = obj.stateNum;
                        task.loader.cacheRes(url, tt);
                        tt.url = url;
                        subTextures.push(tt);
                    }
                    return new AtlasResource(directory, pics, subTextures);
                });
            });
        }
    }
    Loader.registerLoader(["atlas"], AtlasLoader, Loader.ATLAS);

    class HDRTextureInfo {
        static _parseHDRTexture(data, propertyParams = null, constructParams = null) {
            let hdrInfo = HDRTextureInfo.getHDRInfo(data);
            let texture = new Texture2D(hdrInfo.width, hdrInfo.height, hdrInfo.format, false, false, false);
            texture.setHDRData(hdrInfo);
            if (propertyParams) {
                if (propertyParams.wrapModeU != null)
                    texture.wrapModeU = propertyParams.wrapModeU;
                if (propertyParams.wrapModeV != null)
                    texture.wrapModeV = propertyParams.wrapModeV;
                if (propertyParams.filterMode != null)
                    texture.filterMode = propertyParams.filterMode;
                if (propertyParams.anisoLevel != null)
                    texture.anisoLevel = propertyParams.anisoLevel;
            }
            return texture;
        }
        static getHDRInfo(source) {
            let data = new Uint8Array(source);
            let readByteOffset = 0;
            const readLine = () => {
                let lineStr = HDRTextureInfo.getLineString(data, readByteOffset);
                readByteOffset += lineStr.length + 1;
                return lineStr;
            };
            let identifier = readLine();
            if (identifier != "#?RADIANCE") {
                throw "HDR image: identifier wrong.";
            }
            let commandsMap = new Map();
            let line = "";
            do {
                line = readLine();
                if (line[0] != "#") {
                    let commands = line.split("=");
                    commandsMap.set(commands[0], commands[1]);
                }
            } while (line != "");
            let hdrFormat = commandsMap.get("FORMAT");
            if (hdrFormat != "32-bit_rle_rgbe") {
                throw "HDR image: unsupported format.";
            }
            let resolutionStr = readLine();
            let resolutions = resolutionStr.split(" ");
            let decreaseY = resolutions[0] == "-Y";
            let decreaseX = resolutions[2] == "-X";
            let height = parseInt(resolutions[1]);
            let width = parseInt(resolutions[3]);
            let hdrInfo = new HDRTextureInfo(source, readByteOffset, decreaseX, decreaseY, width, height, exports.TextureFormat.R32G32B32A32);
            return hdrInfo;
        }
        static getLineString(data, readByteOffset) {
            let dataLength = data.length;
            let index = readByteOffset;
            let res = "";
            let char = "";
            while (index < dataLength && char != "\n") {
                res = `${res}${char}`;
                char = String.fromCharCode(data[index]);
                index++;
            }
            return res;
        }
        constructor(source, byteOffset, decreaseX, decreaseY, width, height, format) {
            this.source = source;
            this.byteOffset = byteOffset;
            this.decreaseX = decreaseX;
            this.decreaseY = decreaseY;
            this.width = width;
            this.height = height;
            this.format = format;
        }
        get_32_bit_rle_rgbe() {
            let width = this.width;
            let height = this.height;
            this.decreaseX;
            this.decreaseY;
            let data = new Uint8Array(this.source, this.byteOffset);
            let dataIndex = 0;
            let rgbeBuffer = new ArrayBuffer(width * 4);
            let rgbeArray = new Uint8Array(rgbeBuffer);
            let pixelBuffer = new ArrayBuffer(width * height * 4 * 3);
            let pixelArray = new Float32Array(pixelBuffer);
            for (let y = height; y > 0; y--) {
                data[dataIndex++];
                data[dataIndex++];
                let c = data[dataIndex++];
                let d = data[dataIndex++];
                let scanlineLength = (c << 8) | d;
                if (scanlineLength != width) {
                    throw "HDR info: scanlineLength wrong.";
                }
                let index = 0;
                for (let i = 0; i < 4; i++) {
                    let endIndex = (i + 1) * scanlineLength;
                    while (index < endIndex) {
                        let a = data[dataIndex++];
                        let b = data[dataIndex++];
                        if (a > 128) {
                            let count = a - 128;
                            if (count > endIndex - index) {
                                throw "HDR info: ??";
                            }
                            while (count-- > 0) {
                                rgbeArray[index++] = b;
                            }
                        }
                        else {
                            let count = a;
                            if (count == 0 || count > endIndex - index) {
                                throw "HDR info: ??";
                            }
                            rgbeArray[index++] = b;
                            if (--count > 0) {
                                for (let j = 0; j < count; j++) {
                                    rgbeArray[index++] = data[dataIndex++];
                                }
                            }
                        }
                    }
                }
                for (let i = 0; i < scanlineLength; i++) {
                    let r = rgbeArray[i];
                    let g = rgbeArray[i + scanlineLength];
                    let b = rgbeArray[i + 2 * scanlineLength];
                    let e = rgbeArray[i + 3 * scanlineLength];
                    let index = (height - y) * scanlineLength * 3 + i * 3;
                    const Ldexp = (mantissa, exponent) => {
                        if (exponent > 1023) {
                            return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);
                        }
                        if (exponent < -1074) {
                            return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);
                        }
                        return mantissa * Math.pow(2, exponent);
                    };
                    if (e > 0) {
                        let exponent = Ldexp(1.0, e - (128 + 8));
                        pixelArray[index] = r * exponent;
                        pixelArray[index + 1] = g * exponent;
                        pixelArray[index + 2] = b * exponent;
                    }
                    else {
                        pixelArray[index] = 0;
                        pixelArray[index + 1] = 0;
                        pixelArray[index + 2] = 0;
                    }
                }
            }
            return pixelArray;
        }
        readScanLine() {
            let width = this.width;
            let height = this.height;
            let decreaseX = this.decreaseX;
            let decreaseY = this.decreaseY;
            let n = 3;
            if (this.format == exports.TextureFormat.R32G32B32A32) {
                n = 4;
            }
            let pixelArray = new Float32Array(width * height * n);
            let scanlineArray = new Uint8Array(width * 4);
            let data = new Uint8Array(this.source, this.byteOffset);
            let dataLength = data.length;
            let dataIndex = 0;
            const getc = () => {
                if (dataIndex >= dataLength) {
                    throw "HDR info: data wrong.";
                }
                return data[dataIndex++];
            };
            const wrong = () => {
                throw "HDR info: data wrong.";
            };
            for (let y = (height - 1); y >= 0; y--) {
                this.readcolors(scanlineArray, getc, wrong);
                for (let i = 0; i < width; i++) {
                    let index = 4 * i;
                    let byter = scanlineArray[index];
                    let byteg = scanlineArray[index + 1];
                    let byteb = scanlineArray[index + 2];
                    let bytee = scanlineArray[index + 3];
                    let offsetY = y;
                    let offsetX = i;
                    if (decreaseY) {
                        offsetY = height - 1 - y;
                    }
                    if (decreaseX) {
                        offsetX = width - 1 - i;
                    }
                    let pixelIndex = offsetY * width * n + offsetX * n;
                    if (bytee == 0) {
                        pixelArray[pixelIndex] = 0;
                        pixelArray[pixelIndex + 1] = 0;
                        pixelArray[pixelIndex + 2] = 0;
                        if (n == 4) {
                            pixelArray[pixelIndex + 3] = 1;
                        }
                    }
                    else {
                        let f = ldexp(1.0, bytee - (128 + 8));
                        pixelArray[pixelIndex] = (byter + 0.5) * f;
                        pixelArray[pixelIndex + 1] = (byteg + 0.5) * f;
                        pixelArray[pixelIndex + 2] = (byteb + 0.5) * f;
                        if (n == 4) {
                            pixelArray[pixelIndex + 3] = 1;
                        }
                    }
                }
            }
            return pixelArray;
        }
        readcolors(scanlineArray, getc, wrong) {
            const setScanLineData = (w, channel, value) => {
                scanlineArray[w * 4 + channel] = value;
            };
            let width = this.width;
            let unnormalizedr = getc();
            let unnormalizedg = getc();
            let unnormalizedb = getc();
            let unnormalizede = getc();
            if (width < 8 || width > 32767) {
                this.olddreadcolors(scanlineArray, getc, unnormalizedr, unnormalizedg, unnormalizedb, unnormalizede);
                return;
            }
            if (unnormalizedr != 2 || unnormalizedg != 2 || unnormalizedb & 128) {
                this.olddreadcolors(scanlineArray, getc, unnormalizedr, unnormalizedg, unnormalizedb, unnormalizede);
                return;
            }
            if ((unnormalizedb << 8 | unnormalizede) != width) {
                wrong();
            }
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < width;) {
                    let code = getc();
                    if (code > 128) {
                        code &= 127;
                        let val = getc();
                        if (j + code > width) {
                            wrong();
                        }
                        while (code--) {
                            setScanLineData(j++, i, val);
                        }
                    }
                    else {
                        if (j + code > width) {
                            wrong();
                        }
                        while (code--) {
                            let val = getc();
                            setScanLineData(j++, i, val);
                        }
                    }
                }
            }
        }
        olddreadcolors(scanlineArray, getc, r, g, b, e) {
            let rshift = 0;
            let len = this.width;
            scanlineArray[0] = r;
            scanlineArray[1] = g;
            scanlineArray[2] = b;
            scanlineArray[3] = e;
            for (let w = 1; w < len; w++) {
                let unnormalizedr = getc();
                let unnormalizedg = getc();
                let unnormalizedb = getc();
                let unnormalizede = getc();
                let scanIndex = w * 4;
                scanlineArray[scanIndex] = unnormalizedr;
                scanlineArray[scanIndex + 1] = unnormalizedg;
                scanlineArray[scanIndex + 2] = unnormalizedb;
                scanlineArray[scanIndex + 3] = unnormalizede;
                if (unnormalizedr == 1 && unnormalizedg == 1 && unnormalizedb == 1) {
                    let lastIndex = scanIndex - 4;
                    for (let i = unnormalizede << rshift; i > 0; i--) {
                        scanlineArray[scanIndex] = scanlineArray[lastIndex];
                        scanlineArray[scanIndex + 1] = scanlineArray[lastIndex + 1];
                        scanlineArray[scanIndex + 2] = scanlineArray[lastIndex + 2];
                        scanlineArray[scanIndex + 3] = scanlineArray[lastIndex + 3];
                    }
                    rshift += 8;
                }
                else {
                    rshift = 0;
                }
            }
        }
        color_color(col, clr) {
            let f = 0;
            if (clr.w == 0) {
                col.x = col.y = col.z = 0;
            }
            else {
                f = ldexp(1.0, clr.w - (128 + 8));
                col.x = (clr.x) * f;
                col.y = (clr.y) * f;
                col.z = (clr.z) * f;
            }
        }
    }
    HDRTextureInfo.HDRTEXTURE = "HDRTEXTURE";
    function ldexp(value, exponent) {
        return value * Math.pow(2, exponent);
    }

    var internalResources;
    class Texture2DLoader {
        constructor() {
            if (!internalResources) {
                internalResources = {
                    "WhiteTexture.png": Texture2D.whiteTexture,
                    "BlackTexture.png": Texture2D.blackTexture,
                    "GrayTexture.png": Texture2D.grayTexture,
                    "NormalTexture.png": Texture2D.normalTexture,
                };
            }
        }
        load(task) {
            if (task.url.indexOf("internal/") != -1) {
                let tex = internalResources[Utils.getBaseName(task.url)];
                if (tex)
                    return Promise.resolve(tex);
            }
            let meta;
            if (!task.url.startsWith("data:")) {
                meta = AssetDb.inst.metaMap[task.url];
                if (!meta && LayaEnv.isPreview) {
                    return AssetDb.inst.getMeta(task.url, task.uuid).then(meta => {
                        return this.load2(task, meta);
                    });
                }
            }
            return this.load2(task, meta);
        }
        load2(task, meta) {
            var _a, _b, _c;
            let constructParams;
            let propertyParams;
            let ext = task.ext;
            let url = task.url;
            if (meta) {
                let platform = Browser.platform;
                let fileIndex = ((_a = meta.platforms) === null || _a === void 0 ? void 0 : _a[platform]) || 0;
                let fileInfo = ((_b = meta.files) === null || _b === void 0 ? void 0 : _b[fileIndex]) || {};
                if (fileInfo.file) {
                    url = AssetDb.inst.getSubAssetURL(url, task.uuid, fileInfo.file, fileInfo.ext);
                    ext = fileInfo.ext;
                }
                constructParams = [0, 0, (_c = fileInfo.format) !== null && _c !== void 0 ? _c : 1, meta.mipmap, meta.readWrite, meta.sRGB];
                propertyParams = {
                    wrapModeU: meta.wrapMode,
                    wrapModeV: meta.wrapMode,
                    filterMode: meta.filterMode,
                    anisoLevel: meta.anisoLevel,
                    premultiplyAlpha: !!meta.pma,
                    hdrEncodeFormat: meta.hdrEncodeFormat,
                };
            }
            else {
                constructParams = task.options.constructParams;
                propertyParams = task.options.propertyParams;
            }
            let compress = compressedFormats.indexOf(ext) != -1 ? ext : null;
            if (compress != null) {
                return task.loader.fetch(url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                    if (!data)
                        return null;
                    let tex;
                    switch (compress) {
                        case "dds":
                            let ddsInfo = DDSTextureInfo.getDDSTextureInfo(data);
                            if (ddsInfo.isCube) {
                                let cls = ClassUtils.getClass("TextureCube");
                                if (cls) {
                                    let srgb = constructParams ? !!constructParams[5] : false;
                                    let tc = new cls(ddsInfo.width, ddsInfo.format, ddsInfo.mipmapCount > 1, srgb);
                                    tc.setDDSData(ddsInfo);
                                    tex = tc;
                                }
                                else {
                                    return null;
                                }
                            }
                            else {
                                tex = Texture2D._parseDDS(data, propertyParams, constructParams);
                            }
                            break;
                        case "ktx":
                            let ktxInfo = KTXTextureInfo.getKTXTextureInfo(data);
                            if (ktxInfo.dimension == exports.TextureDimension.Cube) {
                                let cls = ClassUtils.getClass("TextureCube");
                                if (cls) {
                                    let tc = new cls(ktxInfo.width, ktxInfo.format, ktxInfo.mipmapCount > 1, ktxInfo.sRGB);
                                    tc.setKTXData(ktxInfo);
                                    tex = tc;
                                }
                                else
                                    return null;
                            }
                            else if (ktxInfo.dimension == exports.TextureDimension.Tex2D) {
                                tex = Texture2D._parseKTX(data, propertyParams, constructParams);
                            }
                            break;
                        case "pvr":
                            tex = Texture2D._parsePVR(data, propertyParams, constructParams);
                            break;
                        case "hdr":
                            tex = HDRTextureInfo._parseHDRTexture(data, propertyParams, constructParams);
                            break;
                        case "lanit.ls":
                            tex = Texture2D._SimpleAnimatorTextureParse(data, propertyParams, constructParams);
                            break;
                    }
                    let obsoluteInst = task.obsoluteInst;
                    if (obsoluteInst && Object.getPrototypeOf(obsoluteInst) == Object.getPrototypeOf(tex))
                        tex = this.move(obsoluteInst, tex);
                    if (propertyParams && propertyParams.hdrEncodeFormat)
                        tex.hdrEncodeFormat = propertyParams.hdrEncodeFormat;
                    if (meta) {
                        tex._sizeGrid = meta.sizeGrid;
                        tex._stateNum = meta.stateNum;
                    }
                    return tex;
                });
            }
            else {
                let options = task.options;
                let premultiplyAlpha = (propertyParams && propertyParams.premultiplyAlpha) ? "premultiply" : "none";
                if (options.useWorkerLoader && premultiplyAlpha === "none")
                    options = Object.assign({ workerLoaderOptions: { premultiplyAlpha } }, options);
                return task.loader.fetch(url, "image", task.progress.createCallback(), options).then(img => {
                    if (LayaGL.textureContext.needBitmap) {
                        if (img instanceof ImageBitmap)
                            return img;
                        else
                            return createImageBitmap(img, options.workerLoaderOptions || { premultiplyAlpha });
                    }
                    else {
                        return img;
                    }
                }).then(bitmapimage => {
                    if (!bitmapimage)
                        return null;
                    let tex = Texture2D._parseImage(bitmapimage, propertyParams, constructParams);
                    let obsoluteInst = task.obsoluteInst;
                    if (obsoluteInst && Object.getPrototypeOf(obsoluteInst) == Object.getPrototypeOf(tex))
                        tex = this.move(obsoluteInst, tex);
                    if (meta) {
                        tex._sizeGrid = meta.sizeGrid;
                        tex._stateNum = meta.stateNum;
                    }
                    return tex;
                });
            }
        }
        move(obsoluteInst, tex) {
            obsoluteInst._texture = tex._texture;
            obsoluteInst._format = tex.format;
            obsoluteInst.width = tex.width;
            obsoluteInst.height = tex.height;
            obsoluteInst.obsolute = false;
            delete Resource._idResourcesMap[tex.id];
            return obsoluteInst;
        }
    }
    class RenderTextureLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                let rt = task.obsoluteInst;
                if (rt)
                    rt.recreate(data.width, data.height, data.colorFormat, data.depthFormat, data.generateMipmap, data.multiSamples, data.generateDepthTexture, data.sRGB);
                else
                    rt = new RenderTexture(data.width, data.height, data.colorFormat, data.depthFormat, data.generateMipmap, data.multiSamples, data.generateDepthTexture, data.sRGB);
                if (null != data.anisoLevel)
                    rt.anisoLevel = data.anisoLevel;
                if (null != data.filterMode)
                    rt.filterMode = data.filterMode;
                if (null != data.wrapModeU)
                    rt.wrapModeU = data.wrapModeU;
                if (null != data.wrapModeV)
                    rt.wrapModeV = data.wrapModeV;
                return rt;
            });
        }
    }
    class VideoTextureLoader {
        load(task) {
            let inst = task.obsoluteInst || new VideoTexture();
            inst.source = task.url;
            return Promise.resolve(inst);
        }
    }
    const propertyParams2d = { premultiplyAlpha: true };
    const constructParams2d = [null, null, exports.TextureFormat.R8G8B8A8, false, false, true];
    class TextureLoader {
        wrapTex2D(task, tex2D) {
            if (!tex2D)
                return null;
            let tex = task.obsoluteInst;
            if (tex) {
                tex.setTo(tex2D);
                tex.obsolute = false;
                tex._sizeGrid = tex2D._sizeGrid;
                tex._stateNum = tex2D._stateNum;
                tex.event("reload");
                if (tex._clipCache) {
                    tex._clipCache.forEach(t => {
                        t.event("reload");
                        t._sizeGrid = tex._sizeGrid;
                        t._stateNum = tex._stateNum;
                    });
                }
            }
            else {
                tex = new Texture(tex2D);
                tex._sizeGrid = tex2D._sizeGrid;
                tex._stateNum = tex2D._stateNum;
            }
            return tex;
        }
        load(task) {
            let tex2D = task.loader.getRes(task.url, Loader.TEXTURE2D);
            if (!tex2D || tex2D.obsolute) {
                let url = { url: task.url, type: Loader.TEXTURE2D };
                if (!task.options.propertyParams)
                    url.propertyParams = propertyParams2d;
                else if (task.options.propertyParams.premultiplyAlpha == null)
                    url.propertyParams = Object.assign({}, propertyParams2d, task.options.propertyParams);
                if (!task.options.constructParams)
                    url.constructParams = constructParams2d;
                else if (task.options.constructParams[5] == null)
                    url.constructParams = Object.assign([], constructParams2d, task.options.constructParams);
                return task.loader.load(url, task.options, task.progress.createCallback()).then(tex2D => {
                    return this.wrapTex2D(task, tex2D);
                });
            }
            else
                return Promise.resolve(this.wrapTex2D(task, tex2D));
        }
    }
    const compressedFormats = ["ktx", "pvr", "dds", "hdr", "exr", "lanit.ls"];
    const videoFormats = ["mp4", "webm"];
    Loader.registerLoader(["tga", "tif", "tiff", "png", "jpg", "jpeg", "webp", "rendertexture", ...videoFormats, ...compressedFormats], TextureLoader, Loader.IMAGE, true);
    Loader.registerLoader([], Texture2DLoader, Loader.TEXTURE2D, true);
    Loader.registerLoader(["rendertexture"], RenderTextureLoader, Loader.TEXTURE2D, true);
    Loader.registerLoader(videoFormats, VideoTextureLoader, Loader.TEXTURE2D);

    class AnimationClip2DLoader {
        load(task) {
            return task.loader.fetch(task.url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return AnimationClip2D._parse(data);
            });
        }
    }
    Loader.registerLoader(["mc"], AnimationClip2DLoader);

    class AnimationController2DLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(0.2), task.options).then(data => {
                let ret = new AnimatorController2D(data);
                if (ret.data && ret.data.controllerLayers) {
                    let layers = ret.data.controllerLayers;
                    let promises = [];
                    for (let i = layers.length - 1; i >= 0; i--) {
                        let states = layers[i].states;
                        this.loadStates(states, promises, task);
                    }
                    return Promise.all(promises).then(deps => {
                        ret.addDeps(deps);
                        return ret;
                    });
                }
                else
                    return ret;
            });
        }
        loadStates(states, promises, task) {
            let basePath = URL.getPath(task.url);
            for (let j = states.length - 1; j >= 0; j--) {
                if (states[j].clip && states[j].clip._$uuid) {
                    let url = URL.getResURLByUUID(states[j].clip._$uuid);
                    if (!url.startsWith("res://"))
                        url = URL.join(basePath, url);
                    promises.push(task.loader.load(url).then(res => {
                        states[j].clip = res;
                        return res;
                    }));
                }
                if (states[j].states) {
                    this.loadStates(states[j].states, promises, task);
                }
            }
        }
    }
    Loader.registerLoader(["mcc"], AnimationController2DLoader);

    class NullLoader {
        load(task) {
            return Promise.resolve(null);
        }
    }
    Loader.registerLoader(["lighting"], NullLoader);

    class BitmapFontLoader {
        load(task) {
            let picUrl = Utils.replaceFileExtension(task.url, "png");
            return Promise.all([
                task.loader.fetch(task.url, "xml", task.progress.createCallback(0.2), task.options),
                task.loader.load(picUrl, task.options, task.progress.createCallback(0.8))
            ]).then(([xml, tex]) => {
                if (!xml || !tex)
                    return null;
                let font = new BitmapFont();
                font.parseFont(xml, tex);
                return font;
            });
        }
    }
    Loader.registerLoader(["fnt"], BitmapFontLoader, Loader.FONT);

    const testString = "LayaTTFFont";
    class TTFFontLoader {
        load(task) {
            let fontName = Utils.replaceFileExtension(Utils.getBaseName(task.url), "");
            if (LayaEnv.isConch) {
                return task.loader.fetch(task.url, "arraybuffer").then(data => {
                    if (data)
                        window["conch"].registerFont(fontName, data);
                    return { family: fontName };
                });
            }
            else if (window.FontFace) {
                let fontFace = new window.FontFace(fontName, "url('" + URL.postFormatURL(URL.formatURL(task.url)) + "')");
                document.fonts.add(fontFace);
                return fontFace.load().then(() => {
                    return fontFace;
                });
            }
            else {
                let fontTxt = "40px " + fontName;
                let txtWidth = Browser.measureText(testString, fontTxt).width;
                let fontStyle = Browser.createElement("style");
                fontStyle.type = "text/css";
                document.body.appendChild(fontStyle);
                fontStyle.textContent = "@font-face { font-family:'" + fontName + "'; src:url('" + URL.postFormatURL(URL.formatURL(task.url)) + "');}";
                return new Promise((resolve) => {
                    let checkComplete = () => {
                        if (Browser.measureText(testString, fontTxt).width != txtWidth)
                            complete();
                    };
                    let complete = () => {
                        ILaya.systemTimer.clear(this, checkComplete);
                        ILaya.systemTimer.clear(this, complete);
                        resolve({ family: fontName });
                    };
                    ILaya.systemTimer.once(10000, this, complete);
                    ILaya.systemTimer.loop(20, this, checkComplete);
                });
            }
        }
    }
    Loader.registerLoader(["ttf", "woff", "woff2", "otf"], TTFFontLoader, Loader.TTF);

    class MaterialParser {
        static parse(data) {
            let props = data.props;
            switch (data.version) {
                case "LAYAMATERIAL:01":
                case "LAYAMATERIAL:02":
                case "LAYAMATERIAL:03":
                    let mat = MaterialParser.parseLegacy(data);
                    mat.oldparseEndEvent();
                    return mat;
                case "LAYAMATERIAL:04":
                    break;
                default:
                    throw new Error(`unkonwn material version: ${data.version}`);
            }
            let mat = new Material();
            mat.setShaderName(props.type);
            let renderQueue;
            for (let key in props) {
                switch (key) {
                    case "type":
                    case "name":
                        break;
                    case "defines":
                        let defineNames = props[key];
                        for (let i = 0, n = defineNames.length; i < n; i++) {
                            let define = Shader3D.getDefineByName(defineNames[i]);
                            mat._shaderValues.addDefine(define);
                        }
                        break;
                    case "textures":
                        let textures = props[key];
                        for (let i = 0, n = textures.length; i < n; i++) {
                            let texture = textures[i];
                            let path = texture.path;
                            (path) && (mat._shaderValues.setTexture(Shader3D.propertyNameToID(texture.name), Loader.getBaseTexture(path)));
                        }
                        break;
                    case "renderQueue":
                        renderQueue = props[key];
                        break;
                    case "alphaTest":
                        mat.alphaTest = props[key];
                        break;
                    case "materialRenderMode":
                        mat.materialRenderMode = props[key];
                        break;
                    default:
                        let property = props[key];
                        let uniName = Shader3D.propertyNameToID(key);
                        switch (uniName) {
                            case Shader3D.CULL:
                                mat.cull = property;
                                break;
                            case Shader3D.BLEND:
                                mat.blend = property;
                                break;
                            case Shader3D.BLEND_SRC:
                                mat.blendSrc = property;
                                break;
                            case Shader3D.BLEND_DST:
                                mat.blendDst = property;
                                break;
                            case Shader3D.BLEND_DST_ALPHA:
                                mat.blendDstAlpha = property;
                                break;
                            case Shader3D.BLEND_SRC_ALPHA:
                                mat.blendSrcAlpha = property;
                                break;
                            case Shader3D.BLEND_SRC_RGB:
                                mat.blendSrcRGB = property;
                                break;
                            case Shader3D.BLEND_SRC_RGB:
                                mat.blendDstRGB = property;
                                break;
                            case Shader3D.DEPTH_TEST:
                                mat.depthTest = property;
                                break;
                            case Shader3D.DEPTH_WRITE:
                                mat.depthWrite = !!props[key];
                                break;
                            case Shader3D.STENCIL_TEST:
                                mat.stencilTest = property;
                                break;
                            case Shader3D.STENCIL_Op:
                                mat.stencilOp = property;
                                break;
                            case Shader3D.STENCIL_Ref:
                                mat.stencilRef = property;
                                break;
                            case Shader3D.STENCIL_WRITE:
                                mat.stencilWrite = property;
                                break;
                            default:
                                if (!property.length) {
                                    if (typeof property == 'boolean')
                                        mat._shaderValues.setBool(uniName, props[key]);
                                    else {
                                        mat._shaderValues.setNumber(uniName, props[key]);
                                    }
                                }
                                else {
                                    var vectorValue = property;
                                    switch (vectorValue.length) {
                                        case 2:
                                            mat._shaderValues.setVector2(uniName, new Vector2(vectorValue[0], vectorValue[1]));
                                            break;
                                        case 3:
                                            mat._shaderValues.setVector3(uniName, new Vector3(vectorValue[0], vectorValue[1], vectorValue[2]));
                                            break;
                                        case 4:
                                            if (mat._shaderValues.getColor(uniName)) {
                                                mat._shaderValues.setColor(uniName, new Color(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]));
                                            }
                                            else
                                                mat._shaderValues.setVector(uniName, new Vector4(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]));
                                            break;
                                        case 9:
                                            let matrix3 = new Matrix3x3();
                                            matrix3.elements = new Float32Array(vectorValue);
                                            mat._shaderValues.setMatrix3x3(uniName, matrix3);
                                            break;
                                        case 16:
                                            let matrix4 = new Matrix4x4();
                                            matrix4.elements = new Float32Array(vectorValue);
                                            mat._shaderValues.setMatrix4x4(uniName, matrix4);
                                            break;
                                        default:
                                            mat._shaderValues.setBuffer(uniName, vectorValue);
                                    }
                                }
                                break;
                        }
                }
            }
            if (null != renderQueue) {
                mat.renderQueue = renderQueue;
            }
            return mat;
        }
        static collectLinks(data, basePath) {
            var _a;
            let urls = [];
            let textures = (_a = data.props) === null || _a === void 0 ? void 0 : _a.textures;
            if (textures) {
                for (let i = 0, n = textures.length; i < n; i++) {
                    let tex2D = textures[i];
                    let tex2DPath = tex2D.path;
                    if (tex2DPath) {
                        tex2D.path = URL.join(basePath, tex2DPath);
                        urls.push({ url: tex2D.path, type: Loader.TEXTURE2D, constructParams: tex2D.constructParams, propertyParams: tex2D.propertyParams });
                    }
                }
            }
            return urls;
        }
        static parseLegacy(data) {
            let jsonData = data;
            let props = jsonData.props;
            let mat;
            let classType = props.type;
            let clas = ClassUtils.getClass(classType);
            if (!clas && classType && classType.startsWith("Laya."))
                clas = ClassUtils.getClass(classType.substring(5));
            if (clas)
                mat = new clas();
            else {
                mat = new Material();
                mat.setShaderName(classType);
            }
            switch (jsonData.version) {
                case "LAYAMATERIAL:01":
                case "LAYAMATERIAL:02":
                    for (let key in props) {
                        switch (key) {
                            case "type":
                                break;
                            case "vectors":
                                let vectors = props[key];
                                for (let i = 0, n = vectors.length; i < n; i++) {
                                    let vector = vectors[i];
                                    let vectorValue = vector.value;
                                    switch (vectorValue.length) {
                                        case 2:
                                            mat[vector.name] = new Vector2(vectorValue[0], vectorValue[1]);
                                            break;
                                        case 3:
                                            if (mat[vector.name] instanceof Color) {
                                                mat[vector.name] = new Color(vectorValue[0], vectorValue[1], vectorValue[2], 1.0);
                                            }
                                            else
                                                mat[vector.name] = new Vector3(vectorValue[0], vectorValue[1], vectorValue[2]);
                                            break;
                                        case 4:
                                            if (mat[vector.name] instanceof Color) {
                                                mat[vector.name] = new Color(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]);
                                            }
                                            else
                                                mat[vector.name] = new Vector4(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]);
                                            break;
                                        default:
                                            throw new Error("unknown material color length: " + vectorValue.length);
                                    }
                                }
                                break;
                            case "colors":
                                let colors = props[key];
                                for (let i = 0, n = colors.length; i < n; i++) {
                                    let color = colors[i];
                                    let vectorValue = color.value;
                                    mat[color.name] = new Color(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]);
                                }
                                break;
                            case "textures":
                                let textures = props[key];
                                for (let i = 0, n = textures.length; i < n; i++) {
                                    let texture = textures[i];
                                    let path = texture.path;
                                    (path) && (mat[texture.name] = Loader.getBaseTexture(path));
                                }
                                break;
                            case "defines":
                                let defineNames = props[key];
                                for (let i = 0, n = defineNames.length; i < n; i++) {
                                    let define = Shader3D.getDefineByName(defineNames[i]);
                                    mat._shaderValues.addDefine(define);
                                }
                                break;
                            case "renderStates":
                                let renderStatesData = props[key];
                                let renderStateData = renderStatesData[0];
                                mat.blend = renderStateData.blend;
                                mat.cull = this._getRenderStateParams(renderStateData.cull);
                                mat.depthTest = this._getRenderStateParams(renderStateData.depthTest);
                                mat.depthWrite = renderStateData.depthWrite;
                                mat.blendSrc = this._getRenderStateParams(renderStateData.srcBlend);
                                mat.blendDst = this._getRenderStateParams(renderStateData.dstBlend);
                                break;
                            case "cull":
                                mat.cull = this._getRenderStateParams(props[key]);
                                break;
                            case "blend":
                                mat.blend = this._getRenderStateParams(props[key]);
                                break;
                            case "depthWrite":
                                mat.depthWrite = !!props[key];
                                break;
                            case "srcBlend":
                                mat.blendSrc = this._getRenderStateParams(props[key]);
                                break;
                            case "dstBlend":
                                mat.blendDst = this._getRenderStateParams(props[key]);
                                break;
                            case "depthTest":
                                mat.depthTest = this._getRenderStateParams(props[key]);
                                break;
                            case "blendDst":
                                mat.blendDst = this._getRenderStateParams(props[key]);
                                break;
                            case "blendSrc":
                                mat.blendSrc = this._getRenderStateParams(props[key]);
                                break;
                            default:
                                mat[key] = props[key];
                        }
                    }
                    break;
                case "LAYAMATERIAL:03":
                    for (let key in props) {
                        switch (key) {
                            case "type":
                            case "name":
                                break;
                            case "defines":
                                let defineNames = props[key];
                                for (let i = 0, n = defineNames.length; i < n; i++) {
                                    let define = Shader3D.getDefineByName(defineNames[i]);
                                    mat._shaderValues.addDefine(define);
                                }
                                break;
                            case "textures":
                                let textures = props[key];
                                for (let i = 0, n = textures.length; i < n; i++) {
                                    let texture = textures[i];
                                    let path = texture.path;
                                    (path) && (mat._shaderValues.setTexture(Shader3D.propertyNameToID(texture.name), Loader.getBaseTexture(path)));
                                }
                                break;
                            case "renderQueue":
                                mat.renderQueue = props[key];
                                break;
                            default:
                                let property = props[key];
                                let uniName = Shader3D.propertyNameToID(key);
                                switch (uniName) {
                                    case Shader3D.CULL:
                                        mat.cull = this._getRenderStateParams(property);
                                        break;
                                    case Shader3D.BLEND:
                                        mat.blend = this._getRenderStateParams(property);
                                        break;
                                    case Shader3D.BLEND_SRC:
                                        mat.blendSrc = this._getRenderStateParams(property);
                                        break;
                                    case Shader3D.BLEND_DST:
                                        mat.blendDst = this._getRenderStateParams(property);
                                        break;
                                    case Shader3D.DEPTH_TEST:
                                        mat.depthTest = this._getRenderStateParams(property);
                                        break;
                                    case Shader3D.DEPTH_WRITE:
                                        mat.depthWrite = !!props[key];
                                        break;
                                    default:
                                        if (!property.length) {
                                            if (typeof property == 'boolean')
                                                mat._shaderValues.setBool(uniName, props[key]);
                                            else {
                                                mat._shaderValues.setNumber(uniName, props[key]);
                                            }
                                        }
                                        else {
                                            var vectorValue = property;
                                            switch (vectorValue.length) {
                                                case 2:
                                                    mat._shaderValues.setVector2(uniName, new Vector2(vectorValue[0], vectorValue[1]));
                                                    break;
                                                case 3:
                                                    mat._shaderValues.setVector3(uniName, new Vector3(vectorValue[0], vectorValue[1], vectorValue[2]));
                                                    break;
                                                case 4:
                                                    if (mat._shaderValues.getColor(uniName)) {
                                                        mat._shaderValues.setColor(uniName, new Color(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]));
                                                    }
                                                    else
                                                        mat._shaderValues.setVector(uniName, new Vector4(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]));
                                                    break;
                                                default:
                                                    throw new Error("unknown material color length: " + vectorValue.length);
                                            }
                                        }
                                        break;
                                }
                        }
                    }
                    break;
                default:
                    throw new Error("unknown material version: " + jsonData.version);
            }
            return mat;
        }
        static _getRenderStateParams(type) {
            switch (type) {
                case 0x0300:
                    return exports.BlendFactor.SourceColor;
                case 0x0301:
                    return exports.BlendFactor.OneMinusSourceColor;
                case 0x0306:
                    return exports.BlendFactor.DestinationColor;
                case 0x0307:
                    return exports.BlendFactor.OneMinusDestinationColor;
                case 0x0302:
                    return exports.BlendFactor.SourceAlpha;
                case 0x0303:
                    return exports.BlendFactor.OneMinusSourceAlpha;
                case 0x0304:
                    return exports.BlendFactor.DestinationAlpha;
                case 0x0305:
                    return exports.BlendFactor.OneMinusDestinationAlpha;
                case 0x0308:
                    return exports.BlendFactor.SourceAlphaSaturate;
                case 0x8006:
                    return exports.BlendEquationSeparate.ADD;
                case 0x800A:
                    return exports.BlendEquationSeparate.SUBTRACT;
                case 0x800B:
                    return exports.BlendEquationSeparate.REVERSE_SUBTRACT;
                case 0x0200:
                    return exports.CompareFunction.Never;
                case 0x0201:
                    return exports.CompareFunction.Less;
                case 0x0202:
                    return exports.CompareFunction.Equal;
                case 0x0203:
                    return exports.CompareFunction.LessEqual;
                case 0x0204:
                    return exports.CompareFunction.Greater;
                case 0x0205:
                    return exports.CompareFunction.NotEqual;
                case 0x0206:
                    return exports.CompareFunction.GreaterEqual;
                case 0x0207:
                    return exports.CompareFunction.Always;
                default:
                    return type;
            }
        }
    }

    class MaterialLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(0.3), task.options).then(data => {
                if (!data)
                    return null;
                let basePath = URL.getPath(task.url);
                let urls = MaterialParser.collectLinks(data, basePath);
                if (data.version === "LAYAMATERIAL:04") {
                    let shaderName = data.props.type;
                    if (!Shader3D.find(shaderName)) {
                        let url = AssetDb.inst.shaderName_to_URL(shaderName);
                        if (url)
                            urls.push(url);
                        else {
                            return AssetDb.inst.shaderName_to_URL_async(shaderName).then(url => {
                                if (url)
                                    urls.push(url);
                                else if (data.props.shaderPath)
                                    urls.push(URL.join(basePath, data.props.shaderPath));
                                else
                                    Loader.warn(`unknown shaderName: ${shaderName}`);
                                return this.load2(task, data, urls);
                            });
                        }
                    }
                }
                return this.load2(task, data, urls);
            });
        }
        load2(task, data, urls) {
            if (urls.length == 0) {
                let mat = MaterialParser.parse(data);
                let obsoluteInst = task.obsoluteInst;
                if (obsoluteInst)
                    mat = this.move(obsoluteInst, mat);
                return Promise.resolve(mat);
            }
            let options = Object.assign({}, task.options);
            options.initiator = task;
            delete options.cache;
            delete options.ignoreCache;
            return task.loader.load(urls, options, task.progress.createCallback()).then(() => {
                let mat = MaterialParser.parse(data);
                let obsoluteInst = task.obsoluteInst;
                if (task.obsoluteInst)
                    mat = this.move(obsoluteInst, mat);
                return mat;
            });
        }
        move(obsoluteInst, mat) {
            obsoluteInst._shaderValues.reset();
            obsoluteInst.setShaderName(mat._shader.name);
            mat._shaderValues.cloneTo(obsoluteInst._shaderValues);
            obsoluteInst.materialRenderMode = mat.materialRenderMode;
            obsoluteInst.renderQueue = mat.renderQueue;
            obsoluteInst.obsolute = false;
            mat.destroy();
            return obsoluteInst;
        }
    }
    Loader.registerLoader(["lmat"], MaterialLoader, Loader.MATERIAL, true);

    class ParseJSON {
        static parse(str) {
            return this.parseStart(str);
        }
        static findIndex(str, i, fstr, len) {
            var fi = str.indexOf(fstr, i + 1);
            if (0 > fi) {
                fi = len;
            }
            return { str: str.substring(i + 1, fi), i: fi };
        }
        static finCurrObj() {
            this.type = 1;
            if (null == this.cobj) {
                return null;
            }
            if (0 == this.currArr.length) {
                if (this.cobj.k) {
                    this.ret[this.cobj.k] = this.cobj.val;
                }
                return null;
            }
            else {
                var pobj = this.currArr.pop();
                if (this.cobj.k) {
                    if (Array.isArray(pobj.val)) {
                        if (null != this.cobj.k) {
                            var obj = {};
                            obj[this.cobj.k] = this.cobj.val;
                            pobj.val.push(obj);
                        }
                    }
                    else {
                        pobj.val[this.cobj.k] = this.cobj.val;
                    }
                }
                else if (Array.isArray(this.cobj.val)) {
                    if (Array.isArray(pobj.val)) {
                        pobj.val.push(this.cobj.val);
                    }
                    else {
                        pobj.val = this.cobj.val;
                    }
                }
                else ;
                return pobj;
            }
        }
        static formatVal(str) {
            if (null == str) {
                return null;
            }
            var numVal = Number(str);
            if (!isNaN(numVal)) {
                return numVal;
            }
            if ("false" == str.toLowerCase()) {
                return false;
            }
            else if ("true" == str.toLowerCase()) {
                return true;
            }
            else if ("null" == str) {
                return null;
            }
            return str;
        }
        static finCurrStr() {
            if (null != this.currStr) {
                this.currStr = this.currStr.trim();
                if ("" != this.currStr) {
                    if (null != this.cobj) {
                        if (Array.isArray(this.cobj.val)) {
                            this.cobj.val.push(this.formatVal(this.currStr));
                        }
                        else {
                            this.cobj.val = this.formatVal(this.currStr);
                            this.cobj = this.finCurrObj();
                        }
                    }
                    this.currStr = "";
                }
            }
        }
        static parseStart(str) {
            this.len = str.length;
            var i = 0;
            this.ret = {};
            this.currStr = null;
            this.currArr = [];
            this.cobj = null;
            this.type = 0;
            while (i < this.len) {
                var c = str.charAt(i);
                if ("/" == c) {
                    if (i + 1 < this.len) {
                        i += 1;
                        var cNext = str.charAt(i);
                        var cstr = null;
                        if ("/" == cNext) {
                            cstr = "\n";
                        }
                        else if ("*" == cNext) {
                            cstr = "*/";
                        }
                        if (null != cstr) {
                            this.finCurrStr();
                            var fi = str.indexOf(cstr, i);
                            if (0 > fi) {
                                console.log("没有找到注释结尾，应该是一直注释到最后了");
                                i = this.len;
                            }
                            else {
                                i = fi + cstr.length - 1;
                            }
                        }
                    }
                }
                else if ("}" == c) {
                    if (null != this.cobj) {
                        this.finCurrStr();
                        if (null != this.cobj) {
                            this.cobj = this.finCurrObj();
                        }
                    }
                    this.currStr = "";
                    this.type = 1;
                }
                else if ("{" == c) {
                    this.currStr = "";
                    this.type = 1;
                }
                else if ("'" == c || "\"" == c || "‘" == c || "“" == c) {
                    if ("‘" == c) {
                        c = "’";
                    }
                    else if ("“" == c) {
                        c = "”";
                    }
                    var obj = this.findIndex(str, i, c, this.len);
                    if (2 == this.type && null != this.cobj && Array.isArray(this.cobj.val)) {
                        if (null != this.currStr) {
                            this.currStr = this.currStr.trim();
                            if ("" != this.currStr) {
                                this.cobj.val.push(this.formatVal(this.currStr));
                            }
                        }
                        this.cobj.val.push(obj.str);
                        this.currStr = "";
                    }
                    else if (null != this.currStr) {
                        this.currStr += obj.str;
                    }
                    i = obj.i;
                }
                else if (";" == c || "," == c || "\n" == c) {
                    this.finCurrStr();
                }
                else if ("]" == c) {
                    if (null != this.currStr && null != this.cobj && Array.isArray(this.cobj.val)) {
                        this.currStr = this.currStr.trim();
                        if ("" != this.currStr) {
                            this.cobj.val.push(this.formatVal(this.currStr));
                        }
                    }
                    if (null != this.cobj) {
                        this.cobj = this.finCurrObj();
                        this.cobj = this.finCurrObj();
                    }
                    this.currStr = "";
                }
                else if ("[" == c) {
                    if (2 != this.type) {
                        console.warn("没有key值，忽略掉一个数组");
                    }
                    else {
                        if (null != this.cobj) {
                            this.currArr.push(this.cobj);
                        }
                        this.cobj = { val: [] };
                    }
                }
                else if (":" == c) {
                    if (null != this.currStr && 1 == this.type) {
                        this.type = 2;
                        if (null != this.cobj) {
                            this.currArr.push(this.cobj);
                        }
                        if (null != this.cobj && Array.isArray(this.cobj.val)) {
                            var pcobj = this.cobj;
                            this.cobj = { val: {} };
                            pcobj.val.push(this.cobj.val);
                            this.currArr.push(this.cobj);
                        }
                        this.cobj = { k: this.currStr.trim(), val: {} };
                        this.currStr = "";
                    }
                }
                else if (null != this.currStr) {
                    this.currStr += c;
                }
                i++;
            }
            return this.ret;
        }
    }

    const CGBlock = ["GLSL Start", "GLSL End"];
    const split = ["#defineGLSL", "#endGLSL"];
    const shaderBlock = ["Shader3D Start", "Shader3D End"];
    const shaderDataOBJ = {
        "Color": exports.ShaderDataType.Color,
        "Int": exports.ShaderDataType.Int,
        "Bool": exports.ShaderDataType.Bool,
        "Float": exports.ShaderDataType.Float,
        "Vector2": exports.ShaderDataType.Vector2,
        "Vector3": exports.ShaderDataType.Vector3,
        "Vector4": exports.ShaderDataType.Vector4,
        "Matrix4x4": exports.ShaderDataType.Matrix4x4,
        "Matrix3x3": exports.ShaderDataType.Matrix3x3,
        "Texture2D": exports.ShaderDataType.Texture2D,
        "TextureCube": exports.ShaderDataType.TextureCube,
        "Texture2DArray": exports.ShaderDataType.Texture2DArray,
        "Texture3D": exports.ShaderDataType.Texture3D,
    };
    class ShaderParser {
        static parse(data, basePath) {
            let obj = ShaderParser.getShaderBlock(data);
            let cgmap = ShaderParser.getCGBlock(data);
            ShaderParser.bindCG(obj, cgmap);
            let shader = Shader3D.parse(obj, basePath);
            return shader;
        }
        static compileToTree(sliceFlag, data, sliceIndex) {
            if (sliceIndex == sliceFlag.length)
                return [data];
            let slicedata = sliceFlag[sliceIndex];
            let splitmap = data.split(slicedata);
            if (splitmap.length == 1)
                return splitmap;
            let map = [];
            for (let i = 0, n = splitmap.length; i < n; i++) {
                map = map.concat(ShaderParser.compileToTree(sliceFlag, splitmap[i], sliceIndex + 1));
                (i != n - 1) && map.push(slicedata);
            }
            return map;
        }
        static getMapKey(value) {
            let index = value.indexOf("\n");
            value = value.slice(0, index).replace("\r", "");
            value = value.slice(0, index).replace(" ", "");
            value = value.trim();
            return value;
        }
        static getShaderBlock(source) {
            let shaderObj = null;
            try {
                let i1 = source.indexOf(shaderBlock[0]);
                if (i1 == -1)
                    throw new Error(`no '${shaderBlock[0]}' tag`);
                let i2 = source.indexOf(shaderBlock[1]);
                if (i2 == -1)
                    throw new Error(`no '${shaderBlock[1]}' tag`);
                let shaderData = source.substring(i1 + shaderBlock[0].length, i2);
                shaderObj = ParseJSON.parse(shaderData);
            }
            catch (err) {
                console.error("Shader parse error: " + err + "\n" + source.substring(0, 100) + "...");
            }
            return shaderObj;
        }
        static getCGBlock(source) {
            let cgmap = {};
            try {
                let i1 = source.indexOf(CGBlock[0]);
                if (i1 == -1)
                    throw new Error(`no '${shaderBlock[0]}' tag`);
                let i2 = source.indexOf(CGBlock[1]);
                if (i2 == -1)
                    throw new Error(`no '${shaderBlock[1]}' tag`);
                let cgdata = source.substring(i1, i2);
                let map = ShaderParser.compileToTree(split, cgdata, 0);
                for (let i = 0, n = map.length; i < n; i++) {
                    let value = map[i];
                    if (value == split[0]) {
                        i += 1;
                        let datavalue = map[i];
                        let key = ShaderParser.getMapKey(datavalue);
                        cgmap[key] = datavalue.slice(datavalue.indexOf("\n"), datavalue.length - 1);
                    }
                }
            }
            catch (err) {
                console.error("Shader parse error: " + err + "\n" + source.substring(0, 100) + "...");
            }
            return cgmap;
        }
        static bindCG(shaderObj, cgmap) {
            let passArray = shaderObj.shaderPass;
            if (passArray) {
                passArray.forEach(element => {
                    if (element.VS) {
                        element.VS = cgmap[element.VS];
                    }
                    if (element.FS) {
                        element.FS = cgmap[element.FS];
                    }
                });
            }
            let attributemap = shaderObj.attributeMap;
            if (attributemap) {
                let indexofAttribute = 0;
                for (let i in attributemap) {
                    if (attributemap[i] instanceof Array) {
                        let dataArray = attributemap[i];
                        let type = ShaderParser.getShaderDataType(dataArray[0]);
                        if (type == null) {
                            console.warn(`${shaderObj.name}: unkown attribute type '${dataArray[0]}'`);
                            continue;
                        }
                        attributemap[i] = [dataArray[1], type];
                    }
                    else {
                        let type = ShaderParser.getShaderDataType(attributemap[i]);
                        if (type == null) {
                            console.warn(`${shaderObj.name}: unkown attribute type '${attributemap[i]}'`);
                            continue;
                        }
                        attributemap[i] = [indexofAttribute, type];
                        indexofAttribute++;
                    }
                }
            }
            let uniformMap = shaderObj.uniformMap;
            if (uniformMap) {
                let defaultmap = {};
                shaderObj.defaultValue = defaultmap;
                let newUniformMap = {};
                shaderObj.uniformMap = newUniformMap;
                for (let k in uniformMap) {
                    let entry = uniformMap[k];
                    if (entry.serializable === false)
                        continue;
                    let dataType = ShaderParser.getShaderDataType(entry.type);
                    if (dataType == null) {
                        console.warn(`${shaderObj.name}: unkown uniform type '${entry.type}'`);
                        continue;
                    }
                    if (entry.default != null)
                        defaultmap[k] = ShaderParser.getDefaultData(dataType, entry.default);
                    if (entry.block) {
                        let block = newUniformMap[entry.block];
                        if (!block)
                            newUniformMap[entry.block] = block = {};
                        block[k] = dataType;
                    }
                    else
                        newUniformMap[k] = dataType;
                }
            }
        }
        static getShaderDataType(value) {
            return shaderDataOBJ[value];
        }
        static getDefaultData(type, data) {
            switch (type) {
                case exports.ShaderDataType.Int:
                case exports.ShaderDataType.Float:
                case exports.ShaderDataType.Bool:
                    return data;
                case exports.ShaderDataType.Vector2:
                    return new Vector2(data[0], data[1]);
                case exports.ShaderDataType.Vector3:
                    return new Vector3(data[0], data[1], data[2]);
                case exports.ShaderDataType.Vector4:
                    return new Vector4(data[0], data[1], data[2], data[3]);
                case exports.ShaderDataType.Color:
                    return new Color(data[0], data[1], data[2], data[3]);
                case exports.ShaderDataType.Matrix4x4:
                    let mat = new Matrix4x4();
                    mat.cloneByArray(data);
                    return mat;
                case exports.ShaderDataType.Matrix3x3:
                    let mat3 = new Matrix3x3();
                    mat3.cloneByArray(data);
                    return mat3;
                case exports.ShaderDataType.Texture2D:
                    let tex = null;
                    if (data == "white")
                        tex = Texture2D.whiteTexture;
                    else if (data == "black")
                        tex = Texture2D.blackTexture;
                    else if (data == "gray")
                        tex = Texture2D.grayTexture;
                    else if (data == "normal")
                        tex = Texture2D.normalTexture;
                    return tex;
                case exports.ShaderDataType.TextureCube:
                    let texcube = TextureCube.grayTexture;
                    if (data == "white")
                        texcube = TextureCube.whiteTexture;
                    else if (data == "black")
                        texcube = TextureCube.blackTexture;
                    else if (data == "gray")
                        texcube = TextureCube.grayTexture;
                    return texcube;
            }
        }
    }

    class ShaderLoader {
        load(task) {
            let url = task.url;
            if (task.ext === "bps")
                url = AssetDb.inst.getSubAssetURL(url, task.uuid, "0", "shader");
            return task.loader.fetch(url, "text", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                let obj = ShaderParser.getShaderBlock(data);
                let cgmap = ShaderParser.getCGBlock(data);
                ShaderParser.bindCG(obj, cgmap);
                if (!obj.name || !obj.uniformMap)
                    return null;
                let basePath = URL.getPath(task.url);
                let passArray = obj.shaderPass;
                return Promise.all(passArray.map(pass => ShaderCompile.compileAsync(pass.VS, pass.FS, basePath))).then(compiledObjs => {
                    var _a;
                    if (compiledObjs.findIndex(obj => obj == null) != -1) {
                        Loader.warn("some pass null " + task.url);
                        return null;
                    }
                    let shader = Shader3D.add(obj.name, obj.enableInstancing, obj.supportReflectionProbe);
                    shader._surportVolumetricGI = obj.surportVolumetricGI;
                    let subshader = new SubShader(obj.attributeMap ? obj.attributeMap : SubShader.DefaultAttributeMap, obj.uniformMap, obj.defaultValue);
                    shader.addSubShader(subshader);
                    for (let i in passArray) {
                        let pass = subshader._addShaderPass(compiledObjs[i], passArray[i].pipeline);
                        pass.statefirst = (_a = passArray[i].statefirst) !== null && _a !== void 0 ? _a : false;
                        ShaderCompile.getRenderState(passArray[i].renderState, pass.renderState);
                    }
                    return shader;
                });
            });
        }
    }
    Loader.registerLoader(["shader", "bps"], ShaderLoader);

    class GLSLLoader {
        load(task) {
            let url = task.url;
            return task.loader.fetch(url, "text", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return ShaderCompile.addInclude(task.url, data, true);
            });
        }
    }
    Loader.registerLoader(["glsl", "vs", "fs"], GLSLLoader);

    class WebAudioLoader {
        load(task) {
            return task.loader.fetch(task.url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return WebAudioSound.ctx.decodeAudioData(data);
            });
        }
    }
    Loader.registerLoader(["mp3", "wav", "ogg"], WebAudioLoader, Loader.SOUND);

    let c = ClassUtils.regClass;
    c("Record", Object);
    c("Node", Node);
    c("Sprite", Sprite);
    c("Widget", Widget);
    c("Text", Text);
    c("Input", Input);
    c("AnimationBase", AnimationBase);
    c("Animation", Animation);
    c("FrameAnimation", FrameAnimation);
    c("EffectAnimation", EffectAnimation);
    c("SoundNode", SoundNode);
    c("VideoNode", VideoNode);
    c("Scene", Scene);
    c("Stage", Stage);
    c("Component", Component);
    c("Script", Script);
    c("BitmapFont", BitmapFont);
    c("BlurFilter", BlurFilter);
    c("ColorFilter", ColorFilter);
    c("GlowFilter", GlowFilter);
    c("Point", Point);
    c("Rectangle", Rectangle);
    c("Texture", Texture);
    c("Texture2D", Texture2D);
    c("Prefab", Prefab);
    c("Animator2D", Animator2D);
    c("AnimatorControllerLayer2D", AnimatorControllerLayer2D);
    c("AnimatorState2D", AnimatorState2D);
    c("AnimationClip2D", AnimationClip2D);
    c("AnimatorController2D", AnimatorController2D);
    c("Animation2DParm", Animation2DParm);
    c("Animation2DCondition", Animation2DCondition);
    c("Vector2", Vector2);
    c("Vector3", Vector3);
    c("Vector4", Vector4);
    c("Quaternion", Quaternion);
    c("Color", Color);
    c("Matrix", Matrix);
    c("Matrix3x3", Matrix3x3);
    c("Matrix4x4", Matrix4x4);

    class BlendState {
        static create(blendType, colorBlendhash, alphaBlendComponent) {
        }
        constructor(blendType) {
            this.blendType = 0;
        }
    }
    BlendState._blend_All_pool = {};
    BlendState._blend_seperate_pool = {};
    class BlendComponent {
        static getHash(blendOperationGLData, sourceBlendFactor, destinationFactor) {
            return (blendOperationGLData) + (sourceBlendFactor << 3) + (destinationFactor << 7);
        }
        static getBlendComponent(blendOperationGLData, sourceBlendFactor, destinationFactor) {
            let index = BlendComponent.getHash(blendOperationGLData, sourceBlendFactor, destinationFactor);
            if (!BlendComponent._pool[index])
                BlendComponent._pool[index] = new BlendComponent(blendOperationGLData, sourceBlendFactor, destinationFactor, index);
            return BlendComponent._pool[index];
        }
        constructor(blendOperationGLData, sourceBlendFactor, destinationFactor, hashindex) {
            this._hashIndex = 0;
            this._hashIndex = hashindex;
            this._blendOperationGLData = blendOperationGLData;
            this._sourceBlendFactor = sourceBlendFactor;
            this._destinationFactor = destinationFactor;
        }
    }
    BlendComponent._pool = {};

    class Buffer {
        get bufferUsage() {
            return this._bufferUsage;
        }
        constructor(targetType, bufferUsageType) {
            this._byteLength = 0;
            this._bufferType = targetType;
            this._bufferUsage = bufferUsageType;
        }
        destroy() {
        }
    }

    class DepthState {
    }

    class IndexBuffer extends Buffer {
        constructor(targetType, bufferUsageType) {
            super(targetType, bufferUsageType);
            this._indexType = exports.IndexFormat.UInt16;
        }
    }

    class StencilState {
    }

    class SubUniformBufferData extends UnifromBufferData {
        constructor(uniformParamsStat, bufferOffset) {
            super(uniformParamsStat);
            this._isInPool = false;
            this._needUpdate = false;
            this._realByte = 0;
            this._offset = bufferOffset;
            this._realByte = this._bytelength;
            this._bytelength = Math.ceil(this._bytelength / 256) * 256;
        }
    }

    class VertexAttributeLayout {
        static getVertexLayoutByPool(vertexs) {
            let pool = VertexAttributeLayout._pool;
            for (var i in pool) {
                let layout = pool[i];
                if (layout.deepthEqaul(vertexs)) {
                    return layout;
                }
            }
            return new VertexAttributeLayout(vertexs);
        }
        constructor(vertexs) {
            this.VAElements = new Array();
            this.attributeByteSize = new Array();
            this.instanceMode = new Array();
            for (let i = 0; i < vertexs.length; i++) {
                let vaelements = [];
                let oneAttributeSize = vertexs[i].vertexDeclaration.vertexStride;
                let vdec = vertexs[i].vertexDeclaration._VAElements;
                for (let j = 0; j < vdec.length; j++) {
                    vaelements.push({ format: vdec[j].format, stride: vdec[j].stride, shaderLocation: vdec[j].shaderLocation });
                }
                this.attributeByteSize.push(oneAttributeSize);
                this.VAElements.push(vaelements);
                this.instanceMode.push(vertexs[i].instanceBuffer);
            }
            this.id = VertexAttributeLayout.IPoint;
            VertexAttributeLayout._pool[VertexAttributeLayout.IPoint++] = this;
        }
        deepthEqaul(vertexs) {
            if (vertexs.length != this.VAElements.length) {
                return false;
            }
            for (var i = 0; i < vertexs.length; i++) {
                let vaelemets = vertexs[i]._vertexDeclaration._VAElements;
                let thisVaeEs = this.VAElements[i];
                if (vaelemets.length != thisVaeEs.length) {
                    return false;
                }
                else {
                    for (var ii = 0, nn = vaelemets.length; ii < nn; ii++) {
                        let v0 = vaelemets[ii];
                        let v1 = thisVaeEs[ii];
                        if (v0.format != v1.format || v0.stride != v1.stride || v0.shaderLocation != v1.shaderLocation)
                            return false;
                    }
                }
            }
            return true;
        }
    }
    VertexAttributeLayout.IPoint = 0;
    VertexAttributeLayout._pool = {};

    class VertexBuffer extends Buffer {
        get vertexDeclaration() {
            return this._vertexDeclaration;
        }
        set vertexDeclaration(value) {
            this._vertexDeclaration = value;
        }
        get instanceBuffer() {
            return this._instanceBuffer;
        }
        set instanceBuffer(value) {
            this._instanceBuffer = value;
        }
        constructor(targetType, bufferUsageType) {
            super(targetType, bufferUsageType);
            this._instanceBuffer = false;
            this._vertexDeclaration = null;
        }
    }

    class ShaderDefine {
        constructor(index, value) {
            this._index = index;
            this._value = value;
        }
    }

    class AnimatorState2DScript {
        setPlayScriptInfo(animator, layerindex, playstate) {
            this.playStateInfo.animator = animator;
            this.playStateInfo.layerindex = layerindex;
            this.playStateInfo.playState = playstate;
        }
        constructor() {
            this.playStateInfo = { animator: null, layerindex: -1, playState: null };
        }
        onStateEnter() {
        }
        onStateUpdate(normalizeTime) {
        }
        onStateExit() {
        }
        onStateLoop() {
        }
    }

    class Keyboard {
    }
    Keyboard.NUMBER_0 = 48;
    Keyboard.NUMBER_1 = 49;
    Keyboard.NUMBER_2 = 50;
    Keyboard.NUMBER_3 = 51;
    Keyboard.NUMBER_4 = 52;
    Keyboard.NUMBER_5 = 53;
    Keyboard.NUMBER_6 = 54;
    Keyboard.NUMBER_7 = 55;
    Keyboard.NUMBER_8 = 56;
    Keyboard.NUMBER_9 = 57;
    Keyboard.A = 65;
    Keyboard.B = 66;
    Keyboard.C = 67;
    Keyboard.D = 68;
    Keyboard.E = 69;
    Keyboard.F = 70;
    Keyboard.G = 71;
    Keyboard.H = 72;
    Keyboard.I = 73;
    Keyboard.J = 74;
    Keyboard.K = 75;
    Keyboard.L = 76;
    Keyboard.M = 77;
    Keyboard.N = 78;
    Keyboard.O = 79;
    Keyboard.P = 80;
    Keyboard.Q = 81;
    Keyboard.R = 82;
    Keyboard.S = 83;
    Keyboard.T = 84;
    Keyboard.U = 85;
    Keyboard.V = 86;
    Keyboard.W = 87;
    Keyboard.X = 88;
    Keyboard.Y = 89;
    Keyboard.Z = 90;
    Keyboard.F1 = 112;
    Keyboard.F2 = 113;
    Keyboard.F3 = 114;
    Keyboard.F4 = 115;
    Keyboard.F5 = 116;
    Keyboard.F6 = 117;
    Keyboard.F7 = 118;
    Keyboard.F8 = 119;
    Keyboard.F9 = 120;
    Keyboard.F10 = 121;
    Keyboard.F11 = 122;
    Keyboard.F12 = 123;
    Keyboard.F13 = 124;
    Keyboard.F14 = 125;
    Keyboard.F15 = 126;
    Keyboard.NUMPAD = 21;
    Keyboard.NUMPAD_0 = 96;
    Keyboard.NUMPAD_1 = 97;
    Keyboard.NUMPAD_2 = 98;
    Keyboard.NUMPAD_3 = 99;
    Keyboard.NUMPAD_4 = 100;
    Keyboard.NUMPAD_5 = 101;
    Keyboard.NUMPAD_6 = 102;
    Keyboard.NUMPAD_7 = 103;
    Keyboard.NUMPAD_8 = 104;
    Keyboard.NUMPAD_9 = 105;
    Keyboard.NUMPAD_ADD = 107;
    Keyboard.NUMPAD_DECIMAL = 110;
    Keyboard.NUMPAD_DIVIDE = 111;
    Keyboard.NUMPAD_ENTER = 108;
    Keyboard.NUMPAD_MULTIPLY = 106;
    Keyboard.NUMPAD_SUBTRACT = 109;
    Keyboard.SEMICOLON = 186;
    Keyboard.EQUAL = 187;
    Keyboard.COMMA = 188;
    Keyboard.MINUS = 189;
    Keyboard.PERIOD = 190;
    Keyboard.SLASH = 191;
    Keyboard.BACKQUOTE = 192;
    Keyboard.LEFTBRACKET = 219;
    Keyboard.BACKSLASH = 220;
    Keyboard.RIGHTBRACKET = 221;
    Keyboard.QUOTE = 222;
    Keyboard.ALTERNATE = 18;
    Keyboard.BACKSPACE = 8;
    Keyboard.CAPS_LOCK = 20;
    Keyboard.COMMAND = 15;
    Keyboard.CONTROL = 17;
    Keyboard.DELETE = 46;
    Keyboard.ENTER = 13;
    Keyboard.ESCAPE = 27;
    Keyboard.PAGE_UP = 33;
    Keyboard.PAGE_DOWN = 34;
    Keyboard.END = 35;
    Keyboard.HOME = 36;
    Keyboard.LEFT = 37;
    Keyboard.UP = 38;
    Keyboard.RIGHT = 39;
    Keyboard.DOWN = 40;
    Keyboard.SHIFT = 16;
    Keyboard.SPACE = 32;
    Keyboard.TAB = 9;
    Keyboard.INSERT = 45;

    class KeyLocation {
    }
    KeyLocation.STANDARD = 0;
    KeyLocation.LEFT = 1;
    KeyLocation.RIGHT = 2;
    KeyLocation.NUM_PAD = 3;

    class ButtonEffect {
        constructor() {
            this._curState = 0;
            this.effectScale = 1.5;
            this.tweenTime = 300;
        }
        set target(tar) {
            this._tar = tar;
            tar.on(Event.MOUSE_DOWN, this, this.toChangedState);
            tar.on(Event.MOUSE_UP, this, this.toInitState);
            tar.on(Event.MOUSE_OUT, this, this.toInitState);
        }
        toChangedState() {
            this._curState = 1;
            if (this._curTween)
                Tween.clear(this._curTween);
            this._curTween = Tween.to(this._tar, { scaleX: this.effectScale, scaleY: this.effectScale }, this.tweenTime, Ease[this.effectEase], Handler.create(this, this.tweenComplete));
        }
        toInitState() {
            if (this._curState == 2)
                return;
            if (this._curTween)
                Tween.clear(this._curTween);
            this._curState = 2;
            this._curTween = Tween.to(this._tar, { scaleX: 1, scaleY: 1 }, this.tweenTime, Ease[this.backEase], Handler.create(this, this.tweenComplete));
        }
        tweenComplete() {
            this._curState = 0;
            this._curTween = null;
        }
    }

    class EffectBase extends Component {
        constructor() {
            super(...arguments);
            this.duration = 1000;
            this.delay = 0;
            this.repeat = 0;
            this.autoDestroyAtComplete = true;
        }
        _onAwake() {
            this.target = this.target || this.owner;
            if (this.autoDestroyAtComplete)
                this._comlete = Handler.create(this.target, this.target.destroy, null, false);
            if (this.eventName)
                this.owner.on(this.eventName, this, this._exeTween);
            else
                this._exeTween();
        }
        _exeTween() {
            this._tween = this._doTween();
            this._tween.repeat = this.repeat;
        }
        _doTween() {
            return null;
        }
        onReset() {
            this.duration = 1000;
            this.delay = 0;
            this.repeat = 0;
            this.ease = null;
            this.target = null;
            if (this.eventName) {
                this.owner.off(this.eventName, this, this._exeTween);
                this.eventName = null;
            }
            if (this._comlete) {
                this._comlete.recover();
                this._comlete = null;
            }
            if (this._tween) {
                this._tween.clear();
                this._tween = null;
            }
        }
    }

    class FadeIn extends EffectBase {
        _doTween() {
            this.target.alpha = 0;
            return Tween.to(this.target, { alpha: 1 }, this.duration, Ease[this.ease], this._comlete, this.delay);
        }
    }

    class FadeOut extends EffectBase {
        _doTween() {
            this.target.alpha = 1;
            return Tween.to(this.target, { alpha: 0 }, this.duration, Ease[this.ease], this._comlete, this.delay);
        }
    }

    class CommandEncoder {
        constructor() {
            this._idata = [];
        }
        getArrayData() {
            return this._idata;
        }
        getCount() {
            return this._idata.length;
        }
        addShaderUniform(variable) {
            this._idata.push(variable);
        }
    }

    class QuickTestTool {
        static getMCDName(type) {
            return QuickTestTool._typeToNameDic[type];
        }
        static showRenderTypeInfo(type, force = false) {
            if (!force && QuickTestTool.showedDic[type])
                return;
            QuickTestTool.showedDic[type] = true;
            if (!QuickTestTool._rendertypeToStrDic[type]) {
                var arr = [];
                var tType;
                tType = 1;
                while (tType <= type) {
                    if (tType & type) {
                        arr.push(QuickTestTool.getMCDName(tType & type));
                    }
                    tType = tType << 1;
                }
                QuickTestTool._rendertypeToStrDic[type] = arr.join(",");
            }
            console.log("cmd:", QuickTestTool._rendertypeToStrDic[type]);
        }
        static __init__() {
            QuickTestTool._typeToNameDic[SpriteConst.ALPHA] = "ALPHA";
            QuickTestTool._typeToNameDic[SpriteConst.TRANSFORM] = "TRANSFORM";
            QuickTestTool._typeToNameDic[SpriteConst.TEXTURE] = "TEXTURE";
            QuickTestTool._typeToNameDic[SpriteConst.GRAPHICS] = "GRAPHICS";
            QuickTestTool._typeToNameDic[SpriteConst.CHILDS] = "CHILDS";
            QuickTestTool._typeToNameDic[SpriteConst.TRANSFORM | SpriteConst.ALPHA] = "TRANSFORM|ALPHA";
            QuickTestTool._typeToNameDic[SpriteConst.CANVAS] = "CANVAS";
            QuickTestTool._typeToNameDic[SpriteConst.BLEND] = "BLEND";
            QuickTestTool._typeToNameDic[SpriteConst.FILTERS] = "FILTERS";
            QuickTestTool._typeToNameDic[SpriteConst.MASK] = "MASK";
            QuickTestTool._typeToNameDic[SpriteConst.CLIP] = "CLIP";
        }
        constructor() {
        }
        render(context, x, y) {
            QuickTestTool._addType(this._renderType);
            QuickTestTool.showRenderTypeInfo(this._renderType);
            RenderSprite.renders[this._renderType]._fun(this, context, x + this._x, y + this._y);
            this._repaint = 0;
        }
        _stageRender(context, x, y) {
            QuickTestTool._countStart();
            QuickTestTool._PreStageRender.call(ILaya.stage, context, x, y);
            QuickTestTool._countEnd();
        }
        static _countStart() {
            var key;
            for (key in QuickTestTool._countDic) {
                QuickTestTool._countDic[key] = 0;
            }
        }
        static _countEnd() {
            QuickTestTool._i++;
            if (QuickTestTool._i > 60) {
                QuickTestTool.showCountInfo();
                QuickTestTool._i = 0;
            }
        }
        static _addType(type) {
            if (!QuickTestTool._countDic[type]) {
                QuickTestTool._countDic[type] = 1;
            }
            else {
                QuickTestTool._countDic[type] += 1;
            }
        }
        static showCountInfo() {
            console.log("===================");
            var key;
            for (key in QuickTestTool._countDic) {
                console.log("count:" + QuickTestTool._countDic[key]);
                QuickTestTool.showRenderTypeInfo(key, true);
            }
        }
        static enableQuickTest() {
            QuickTestTool.__init__();
            Sprite["prototype"]["render"] = QuickTestTool["prototype"]["render"];
            QuickTestTool._PreStageRender = Stage["prototype"]["render"];
            Stage["prototype"]["render"] = QuickTestTool["prototype"]["_stageRender"];
        }
    }
    QuickTestTool.showedDic = {};
    QuickTestTool._rendertypeToStrDic = {};
    QuickTestTool._typeToNameDic = {};
    QuickTestTool._countDic = {};
    QuickTestTool._i = 0;

    exports.RenderClearFlag = void 0;
    (function (RenderClearFlag) {
        RenderClearFlag[RenderClearFlag["Nothing"] = 0] = "Nothing";
        RenderClearFlag[RenderClearFlag["Color"] = 1] = "Color";
        RenderClearFlag[RenderClearFlag["Depth"] = 2] = "Depth";
        RenderClearFlag[RenderClearFlag["Stencil"] = 4] = "Stencil";
    })(exports.RenderClearFlag || (exports.RenderClearFlag = {}));

    exports.RenderDrawMode = void 0;
    (function (RenderDrawMode) {
        RenderDrawMode[RenderDrawMode["TRIANGLES"] = 0] = "TRIANGLES";
        RenderDrawMode[RenderDrawMode["POINTS"] = 1] = "POINTS";
        RenderDrawMode[RenderDrawMode["LINES"] = 2] = "LINES";
    })(exports.RenderDrawMode || (exports.RenderDrawMode = {}));

    exports.RenderIndexMode = void 0;
    (function (RenderIndexMode) {
        RenderIndexMode[RenderIndexMode["UNSIGNED_BYTE"] = 0] = "UNSIGNED_BYTE";
        RenderIndexMode[RenderIndexMode["UNSIGNED_SHORT"] = 1] = "UNSIGNED_SHORT";
        RenderIndexMode[RenderIndexMode["UNSIGNED_INT"] = 2] = "UNSIGNED_INT";
    })(exports.RenderIndexMode || (exports.RenderIndexMode = {}));

    exports.RenderStateType = void 0;
    (function (RenderStateType) {
        RenderStateType[RenderStateType["DepthTest"] = 0] = "DepthTest";
        RenderStateType[RenderStateType["DepthMask"] = 1] = "DepthMask";
        RenderStateType[RenderStateType["DepthFunc"] = 2] = "DepthFunc";
        RenderStateType[RenderStateType["StencilTest"] = 3] = "StencilTest";
        RenderStateType[RenderStateType["StencilMask"] = 4] = "StencilMask";
        RenderStateType[RenderStateType["StencilFunc"] = 5] = "StencilFunc";
        RenderStateType[RenderStateType["StencilOp"] = 6] = "StencilOp";
        RenderStateType[RenderStateType["BlendType"] = 7] = "BlendType";
        RenderStateType[RenderStateType["BlendEquation"] = 8] = "BlendEquation";
        RenderStateType[RenderStateType["BlendEquationSeparate"] = 9] = "BlendEquationSeparate";
        RenderStateType[RenderStateType["BlendFunc"] = 10] = "BlendFunc";
        RenderStateType[RenderStateType["BlendFuncSeperate"] = 11] = "BlendFuncSeperate";
        RenderStateType[RenderStateType["CullFace"] = 12] = "CullFace";
        RenderStateType[RenderStateType["FrontFace"] = 13] = "FrontFace";
    })(exports.RenderStateType || (exports.RenderStateType = {}));

    exports.TextureCompareMode = void 0;
    (function (TextureCompareMode) {
        TextureCompareMode[TextureCompareMode["None"] = 0] = "None";
        TextureCompareMode[TextureCompareMode["LEQUAL"] = 1] = "LEQUAL";
        TextureCompareMode[TextureCompareMode["GEQUAL"] = 2] = "GEQUAL";
        TextureCompareMode[TextureCompareMode["LESS"] = 3] = "LESS";
        TextureCompareMode[TextureCompareMode["GREATER"] = 4] = "GREATER";
        TextureCompareMode[TextureCompareMode["EQUAL"] = 5] = "EQUAL";
        TextureCompareMode[TextureCompareMode["NOTEQUAL"] = 6] = "NOTEQUAL";
        TextureCompareMode[TextureCompareMode["ALWAYS"] = 7] = "ALWAYS";
        TextureCompareMode[TextureCompareMode["NEVER"] = 8] = "NEVER";
    })(exports.TextureCompareMode || (exports.TextureCompareMode = {}));

    exports.TextureDecodeFormat = void 0;
    (function (TextureDecodeFormat) {
        TextureDecodeFormat[TextureDecodeFormat["Normal"] = 0] = "Normal";
        TextureDecodeFormat[TextureDecodeFormat["RGBM"] = 1] = "RGBM";
    })(exports.TextureDecodeFormat || (exports.TextureDecodeFormat = {}));

    class GLSLCodeGenerator {
        static glslAttributeString(attributeMap) {
            let res = "";
            for (const key in attributeMap) {
                let type = getAttributeType(attributeMap[key][1]);
                if (type != "") {
                    res = `${res}attribute ${type} ${key};\n`;
                }
            }
            return res;
        }
        static glslUniformString(uniformsMap, useUniformBlock) {
            if (useUniformBlock) {
                let blocksStr = "";
                let uniformsStr = "";
                for (const key in uniformsMap) {
                    if (typeof uniformsMap[key] == "object") {
                        let blockUniforms = uniformsMap[key];
                        blocksStr += `uniform ${key} {\n`;
                        for (const uniformName in blockUniforms) {
                            let dataType = blockUniforms[uniformName];
                            let typeStr = getAttributeType(dataType);
                            if (typeStr != "") {
                                blocksStr += `${typeStr} ${uniformName};\n`;
                            }
                        }
                        blocksStr += "};\n";
                    }
                    else {
                        let dataType = uniformsMap[key];
                        let typeStr = getAttributeType(dataType);
                        if (typeStr != "") {
                            uniformsStr += `uniform ${typeStr} ${key};\n`;
                        }
                    }
                }
                return blocksStr + uniformsStr;
            }
            else {
                let uniformsStr = "";
                for (const key in uniformsMap) {
                    if (typeof uniformsMap[key] == "object") {
                        let blockUniforms = uniformsMap[key];
                        for (const uniformName in blockUniforms) {
                            let dataType = blockUniforms[uniformName];
                            let typeStr = getAttributeType(dataType);
                            if (typeStr != "") {
                                uniformsStr += `uniform ${typeStr} ${uniformName};\n`;
                            }
                        }
                    }
                    else {
                        let dataType = uniformsMap[key];
                        let typeStr = getAttributeType(dataType);
                        if (typeStr != "") {
                            uniformsStr += `uniform ${typeStr} ${key};\n`;
                        }
                    }
                }
                return uniformsStr;
            }
        }
        static GLShaderLanguageProcess3D(defineString, attributeMap, uniformMap, VS, FS) {
            var clusterSlices = Config3D.lightClusterCount;
            var defMap = {};
            var vertexHead;
            var fragmentHead;
            var defineStr = "";
            let useUniformBlock = Config3D._uniformBlock;
            let attributeglsl = GLSLCodeGenerator.glslAttributeString(attributeMap);
            let uniformglsl = GLSLCodeGenerator.glslUniformString(uniformMap, useUniformBlock);
            if (LayaGL.renderEngine.getParams(exports.RenderParams.SHADER_CAPAILITY_LEVEL) > 30) {
                defineString.push("GRAPHICS_API_GLES3");
                vertexHead =
                    `#version 300 es
#if defined(GL_FRAGMENT_PRECISION_HIGH)
    precision highp float;
    precision highp int;
    precision highp sampler2DArray;
    precision highp sampler3D;
#else
    precision mediump float;
    precision mediump int;
    precision mediump sampler2DArray;
    precision mediump sampler3D;
#endif
layout(std140, column_major) uniform;
#define attribute in
#define varying out
#define textureCube texture
#define texture2D texture
${attributeglsl}
${uniformglsl}
`;
                fragmentHead =
                    `#version 300 es
#if defined(GL_FRAGMENT_PRECISION_HIGH)
    precision highp float;
    precision highp int;
    precision highp sampler2DArray;
	precision highp sampler3D;
#else
    precision mediump float;
    precision mediump int;
    precision mediump sampler2DArray;
	precision mediump sampler3D;
#endif
layout(std140, column_major) uniform;
#define varying in
out highp vec4 pc_fragColor;
#define gl_FragColor pc_fragColor
#define gl_FragDepthEXT gl_FragDepth
#define texture2D texture
#define textureCube texture
#define texture2DProj textureProj
#define texture2DLodEXT textureLod
#define texture2DProjLodEXT textureProjLod
#define textureCubeLodEXT textureLod
#define texture2DGradEXT textureGrad
#define texture2DProjGradEXT textureProjGrad
#define textureCubeGradEXT textureGrad
${uniformglsl}`;
            }
            else {
                vertexHead =
                    `#if defined(GL_FRAGMENT_PRECISION_HIGH)
    precision highp float;
    precision highp int;
#else
    precision mediump float;
    precision mediump int;
#endif
${attributeglsl}
${uniformglsl}`;
                fragmentHead =
                    `#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif

#ifdef GL_OES_standard_derivatives
	#extension GL_OES_standard_derivatives : enable 
#endif

#if defined(GL_FRAGMENT_PRECISION_HIGH)
    precision highp float;
    precision highp int;
#else
    precision mediump float;
    precision mediump int;
#endif

#if !defined(GL_EXT_shader_texture_lod)
    #define texture1DLodEXT texture1D
    #define texture2DLodEXT texture2D
    #define texture2DProjLodEXT texture2DProj
    #define texture3DLodEXT texture3D
    #define textureCubeLodEXT textureCube
#endif
${uniformglsl}`;
            }
            defineStr += "#define MAX_LIGHT_COUNT " + Config3D.maxLightCount + "\n";
            defineStr += "#define MAX_LIGHT_COUNT_PER_CLUSTER " + Config3D._maxAreaLightCountPerClusterAverage + "\n";
            defineStr += "#define CLUSTER_X_COUNT " + clusterSlices.x + "\n";
            defineStr += "#define CLUSTER_Y_COUNT " + clusterSlices.y + "\n";
            defineStr += "#define CLUSTER_Z_COUNT " + clusterSlices.z + "\n";
            defineStr += "#define MORPH_MAX_COUNT " + Config3D.maxMorphTargetCount + "\n";
            defineStr += "#define SHADER_CAPAILITY_LEVEL " + LayaGL.renderEngine.getParams(exports.RenderParams.SHADER_CAPAILITY_LEVEL) + "\n";
            for (var i = 0, n = defineString.length; i < n; i++) {
                var def = defineString[i];
                defineStr += "#define " + def + "\n";
                defMap[def] = true;
            }
            var vs = VS.toscript(defMap, []);
            var vsVersion = '';
            if (vs[0].indexOf('#version') == 0) {
                vsVersion = vs[0] + '\n';
                vs.shift();
            }
            var ps = FS.toscript(defMap, []);
            var psVersion = '';
            if (ps[0].indexOf('#version') == 0) {
                psVersion = ps[0] + '\n';
                ps.shift();
            }
            let dstVS = vsVersion + vertexHead + defineStr + vs.join('\n');
            let detFS = psVersion + fragmentHead + defineStr + ps.join('\n');
            return { vs: dstVS, fs: detFS };
        }
    }
    function getAttributeType(type) {
        switch (type) {
            case exports.ShaderDataType.Int:
                return "int";
            case exports.ShaderDataType.Bool:
                return "bool";
            case exports.ShaderDataType.Float:
                return "float";
            case exports.ShaderDataType.Vector2:
                return "vec2";
            case exports.ShaderDataType.Vector3:
                return "vec3";
            case exports.ShaderDataType.Vector4:
            case exports.ShaderDataType.Color:
                return "vec4";
            case exports.ShaderDataType.Matrix4x4:
                return "mat4";
            case exports.ShaderDataType.Matrix3x3:
                return "mat3";
            case exports.ShaderDataType.Texture2D:
                return "sampler2D";
            case exports.ShaderDataType.TextureCube:
                return "samplerCube";
            case exports.ShaderDataType.Texture2DArray:
                if (LayaGL.renderEngine.getCapable(exports.RenderCapable.Texture3D)) {
                    return "sampler2DArray";
                }
                else {
                    return "";
                }
            case exports.ShaderDataType.Texture3D:
                if (LayaGL.renderEngine.getCapable(exports.RenderCapable.Texture3D)) {
                    return "sampler3D";
                }
                else {
                    return "";
                }
            default:
                return "";
        }
    }

    class ShaderVariable {
        constructor() {
            this.onID = ShaderVariable.pointID++;
            this.textureID = -1;
        }
    }
    ShaderVariable.pointID = 0;

    class Viewport {
        constructor(x, y, width, height) {
            this.minDepth = 0.0;
            this.maxDepth = 1.0;
            this.x = x !== null && x !== void 0 ? x : 0;
            this.y = y !== null && y !== void 0 ? y : 0;
            this.width = width !== null && width !== void 0 ? width : 0;
            this.height = height !== null && height !== void 0 ? height : 0;
        }
        project(source, matrix, out) {
            Vector3.transformV3ToV4(source, matrix, out);
            var x = out.x, y = out.y, z = out.z;
            var w = out.w;
            if (w !== 1.0) {
                x = x / w;
                y = y / w;
                z = z / w;
            }
            out.x = (x + 1.0) * 0.5 * this.width + this.x;
            out.y = (-y + 1.0) * 0.5 * this.height + this.y;
            out.z = z * (this.maxDepth - this.minDepth) + this.minDepth;
        }
        unprojectFromMat(source, matrix, out) {
            var matrixEleme = matrix.elements;
            out.x = (((source.x - this.x) / this.width) * 2.0) - 1.0;
            out.y = -((((source.y - this.y) / this.height) * 2.0) - 1.0);
            out.z = (source.z - this.minDepth) / (this.maxDepth - this.minDepth);
            var a = (((out.x * matrixEleme[3]) + (out.y * matrixEleme[7])) + (out.z * matrixEleme[11])) + matrixEleme[15];
            Vector3.transformV3ToV3(out, matrix, out);
            if (a !== 1.0) {
                out.x = out.x / a;
                out.y = out.y / a;
                out.z = out.z / a;
            }
        }
        unprojectFromWVP(source, projection, view, world, out) {
            Matrix4x4.multiply(projection, view, _tempMatrix4x4);
            (world) && (Matrix4x4.multiply(_tempMatrix4x4, world, _tempMatrix4x4));
            _tempMatrix4x4.invert(_tempMatrix4x4);
            this.unprojectFromMat(source, _tempMatrix4x4, out);
        }
        set(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        cloneTo(out) {
            out.x = this.x;
            out.y = this.y;
            out.width = this.width;
            out.height = this.height;
            out.minDepth = this.minDepth;
            out.maxDepth = this.maxDepth;
        }
    }
    Viewport._tempViewport = new Viewport(0, 0, 0, 0);
    const _tempMatrix4x4 = new Matrix4x4();

    class VertexMesh2D {
        static getVertexDeclaration(vertexFlags, compatible = true) {
            let verDecs = [];
            for (let i = 0, len = vertexFlags.length; i < len; i++) {
                let vertexFlag = vertexFlags[i];
                let verDec = VertexMesh2D._vertexDeclarationMap[vertexFlag + (compatible ? "_0" : "_1")];
                if (!verDec) {
                    var subFlags = vertexFlag.split(",");
                    var offset = 0;
                    var elements = [];
                    for (let j = 0, n = subFlags.length; j < n; j++) {
                        var element;
                        switch (subFlags[i]) {
                            case "POSITION":
                                element = new VertexElement(offset, VertexElementFormat.Vector3, VertexMesh.MESH_POSITION0);
                                offset += 8;
                                break;
                            case "COLOR":
                                element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_COLOR0);
                                offset += 16;
                                break;
                            case "UV":
                                element = new VertexElement(offset, VertexElementFormat.Vector2, VertexMesh.MESH_TEXTURECOORDINATE0);
                                offset += 8;
                                break;
                            case "BLENDWEIGHT":
                                element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_BLENDWEIGHT0);
                                offset += 16;
                                break;
                            case "BLENDINDICES":
                                if (compatible) {
                                    element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_BLENDINDICES0);
                                    offset += 16;
                                }
                                else {
                                    element = new VertexElement(offset, VertexElementFormat.Byte4, VertexMesh.MESH_BLENDINDICES0);
                                    offset += 4;
                                }
                                break;
                            default:
                                throw "VertexMesh: unknown vertex flag.";
                        }
                        elements.push(element);
                    }
                    verDec = new VertexDeclaration(offset, elements);
                    VertexMesh2D._vertexDeclarationMap[vertexFlag + (compatible ? "_0" : "_1")] = verDec;
                    verDecs.push(verDec);
                }
            }
            return verDecs;
        }
    }
    VertexMesh2D._vertexDeclarationMap = {};
    class Mesh2D extends Resource {
        static load(url, complete) {
            ILaya.loader.load(url, complete, null, Loader.MESH);
        }
        get vertexBuffers() {
            return this._vertexBuffers;
        }
        get indexBuffer() {
            return this._indexBuffer;
        }
        get vertexCount() {
            return this._vertexCount;
        }
        get indexCount() {
            return this._indexBuffer.indexCount;
        }
        get subMeshCount() {
            return this._subMeshes.length;
        }
        get indexFormat() {
            return this._indexFormat;
        }
        set indexFormat(value) {
            this._indexFormat = value;
            this._subMeshes.forEach(element => {
                element.indexFormat = value;
            });
        }
        constructor() {
            super();
            this._instanceBufferStateType = 0;
            this._vertexBuffers = null;
            this._indexBuffer = null;
            this._vertexCount = 0;
            this._indexFormat = exports.IndexFormat.UInt16;
            this._bufferState = LayaGL.renderDeviceFactory.createBufferState();
            this._subMeshes = [];
            this.destroyedImmediately = Config.destroyResourceImmediatelyDefault;
        }
        _disposeResource() {
            for (let i = 0, n = this._subMeshes.length; i < n; i++)
                this._subMeshes[i].destroy();
            for (let i = 0, n = this._vertexBuffers.length; i < n; i++)
                this._vertexBuffers[i].destroy();
            this._indexBuffer && this._indexBuffer.destroy();
            this._bufferState.destroy();
            this._instanceBufferState && this._instanceBufferState.destroy();
            this._instanceWorldVertexBuffer && this._instanceWorldVertexBuffer.destroy();
            this._instanceSimpleAniVertexBuffer && this._instanceSimpleAniVertexBuffer.destroy();
            this._setCPUMemory(0);
            this._setGPUMemory(0);
            this._bufferState = null;
            this._instanceBufferState = null;
            this._vertexBuffers = null;
            this._indexBuffer = null;
            this._subMeshes = null;
            this._indexBuffer = null;
        }
        _setSubMeshes(subMeshes) {
            this._subMeshes = subMeshes;
        }
        _setBuffer(vertexBuffer, indexBuffer) {
            var bufferState = this._bufferState;
            bufferState.applyState([vertexBuffer], indexBuffer);
        }
        getSubMesh(index) {
            return this._subMeshes[index];
        }
        setVertices(vertices) {
            for (let i = 0, len = vertices.length; i < len; i++) {
                if (vertices[i] && this._vertexBuffers[i]) {
                    this._vertexBuffers[i].setData(vertices[i], 0, 0, vertices[i].byteLength);
                }
            }
        }
        setIndices(indices) {
            var format;
            if (indices instanceof Uint32Array)
                format = exports.IndexFormat.UInt32;
            else if (indices instanceof Uint16Array)
                format = exports.IndexFormat.UInt16;
            else if (indices instanceof Uint8Array)
                format = exports.IndexFormat.UInt8;
            let indexBuffer = this._indexBuffer;
            if (this._indexFormat !== format || indexBuffer.indexCount !== indices.length) {
                indexBuffer.destroy();
                this._indexBuffer = indexBuffer = LayaGL.renderDeviceFactory.createIndexBuffer(exports.BufferUsage.Static);
                indexBuffer.indexCount = indexBuffer.indexCount;
                indexBuffer.indexType = format;
            }
            indexBuffer._setIndexData(indices, 0);
            this.indexFormat = format;
        }
    }

    class RenderTextureCube extends RenderTexture {
        constructor(size, colorFormat, depthFormat, generateMipmap, multiSamples) {
            super(size, size, colorFormat, depthFormat, generateMipmap, multiSamples);
            this.faceIndex = 0;
        }
        _createRenderTarget() {
            this._dimension = exports.TextureDimension.Cube;
            this._renderTarget = LayaGL.textureContext.createRenderTargetCubeInternal(this.width, this._format, this._depthStencilFormat, this._generateMipmap, this._gammaSpace, this._multiSamples);
            this._texture = this._renderTarget._textures[0];
        }
    }

    class Texture3D extends BaseTexture {
        static get defaultTexture() {
            return this._defaultTexture;
        }
        static __init__() {
            if (LayaGL.renderEngine.getCapable(exports.RenderCapable.Texture3D)) {
                this._defaultTexture = new Texture3D(1, 1, 1, exports.TextureFormat.R8G8B8A8, false, false);
                this._defaultTexture.lock = true;
                this._defaultTexture.setPixelsData(new Uint8Array([255, 255, 255, 255]));
            }
        }
        constructor(width, height, depth, format, mipmap = true, sRGB = false) {
            super(width, height, format);
            this._dimension = exports.TextureDimension.Tex3D;
            this.depth = depth;
            this._gammaSpace = sRGB;
            let context = LayaGL.textureContext;
            this._texture = context.createTexture3DInternal(this._dimension, width, height, depth, format, mipmap, sRGB, false);
        }
        setPixelsData(source) {
            let texture = this._texture;
            let context = LayaGL.textureContext;
            context.setTexture3DPixelsData(texture, source, this.depth, false, false);
        }
        setSubPixelsData(xOffset, yOffset, zOffset, width, height, depth, pixels, mipmapLevel, generateMipmap) {
            let texture = this._texture;
            let context = LayaGL.textureContext;
            context.setTexture3DSubPixelsData(texture, pixels, mipmapLevel, generateMipmap, xOffset, yOffset, zOffset, width, height, depth, false, false);
        }
    }

    class WebGLRTMgr {
        static getRT(w, h) {
            w = w | 0;
            h = h | 0;
            if (w >= 10000) {
                console.error('getRT error! w too big');
            }
            var ret;
            ret = new RenderTexture2D(w, h, exports.RenderTargetFormat.R8G8B8A8, exports.RenderTargetFormat.None);
            return ret;
        }
        static releaseRT(rt) {
            rt.destroy();
            return;
        }
    }
    WebGLRTMgr.dict = {};

    class System {
        static changeDefinition(name, classObj) {
            window.Laya[name] = classObj;
            var str = name + "=classObj";
            window['eval'](str);
        }
    }

    class Base64Tool {
        static init() {
            if (Base64Tool.lookup)
                return;
            Base64Tool.lookup = new Uint8Array(256);
            for (var i = 0; i < Base64Tool.chars.length; i++) {
                Base64Tool.lookup[Base64Tool.chars.charCodeAt(i)] = i;
            }
        }
        static isBase64String(str) {
            return Base64Tool.reg.test(str);
        }
        static encode(arraybuffer) {
            var bytes = new Uint8Array(arraybuffer), i, len = bytes["length"], base64 = "";
            for (i = 0; i < len; i += 3) {
                base64 += Base64Tool.chars[bytes[i] >> 2];
                base64 += Base64Tool.chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
                base64 += Base64Tool.chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
                base64 += Base64Tool.chars[bytes[i + 2] & 63];
            }
            if ((len % 3) === 2) {
                base64 = base64.substring(0, base64.length - 1) + "=";
            }
            else if (len % 3 === 1) {
                base64 = base64.substring(0, base64.length - 2) + "==";
            }
            return base64;
        }
        static decode(base64) {
            Base64Tool.init();
            var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
            if (base64[base64.length - 1] === "=") {
                bufferLength--;
                if (base64[base64.length - 2] === "=") {
                    bufferLength--;
                }
            }
            var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
            for (i = 0; i < len; i += 4) {
                encoded1 = Base64Tool.lookup[base64.charCodeAt(i)];
                encoded2 = Base64Tool.lookup[base64.charCodeAt(i + 1)];
                encoded3 = Base64Tool.lookup[base64.charCodeAt(i + 2)];
                encoded4 = Base64Tool.lookup[base64.charCodeAt(i + 3)];
                if (p + 1 > bufferLength)
                    continue;
                bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
                if (p + 1 > bufferLength)
                    continue;
                bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
                if (p + 1 > bufferLength)
                    continue;
                bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
            }
            return arraybuffer;
        }
    }
    Base64Tool.chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    Base64Tool.reg = /^\s*data:([a-z]+\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s]*?)\s*$/i;
    Base64Tool.reghead = /^\s*data:([a-z]+\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,/i;
    Base64Tool.lookup = null;

    function arrayBufferSlice(start, end) {
        var arrU8List = new Uint8Array(this, start, end - start);
        var newU8List = new Uint8Array(arrU8List.length);
        newU8List.set(arrU8List);
        return newU8List.buffer;
    }
    function uint8ArraySlice() {
        var sz = this.length;
        var dec = new Uint8Array(this.length);
        for (var i = 0; i < sz; i++)
            dec[i] = this[i];
        return dec;
    }
    function float32ArraySlice() {
        var sz = this.length;
        var dec = new Float32Array(this.length);
        for (var i = 0; i < sz; i++)
            dec[i] = this[i];
        return dec;
    }
    function uint16ArraySlice(...arg) {
        var sz;
        var dec;
        var i;
        if (arg.length === 0) {
            sz = this.length;
            dec = new Uint16Array(sz);
            for (i = 0; i < sz; i++)
                dec[i] = this[i];
        }
        else if (arg.length === 2) {
            var start = arg[0];
            var end = arg[1];
            if (end > start) {
                sz = end - start;
                dec = new Uint16Array(sz);
                for (i = start; i < end; i++)
                    dec[i - start] = this[i];
            }
            else {
                dec = new Uint16Array(0);
            }
        }
        return dec;
    }
    ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice = arrayBufferSlice);
    Float32Array.prototype.slice || (Float32Array.prototype.slice = float32ArraySlice);
    Uint16Array.prototype.slice || (Uint16Array.prototype.slice = uint16ArraySlice);
    Uint8Array.prototype.slice || (Uint8Array.prototype.slice = uint8ArraySlice);

    const _rect = new Rectangle();
    const _ptPoint = new Point();
    class HitArea {
        contains(x, y, sp) {
            if (!HitArea._isHitGraphic(x, y, sp, this._hit))
                return false;
            return !HitArea._isHitGraphic(x, y, sp, this._unHit);
        }
        static _isHitGraphic(x, y, sp, graphic) {
            if (!graphic)
                return false;
            let cmds = graphic.cmds;
            if (cmds.length == 0)
                return false;
            let len = cmds.length;
            for (let i = 0; i < len; i++) {
                let cmd = cmds[i];
                if (!cmd)
                    continue;
                switch (cmd.cmdID) {
                    case "Translate":
                        x -= cmd.tx;
                        y -= cmd.ty;
                }
                if (HitArea._isHitCmd(x, y, sp, cmd))
                    return true;
            }
            return false;
        }
        static _isHitCmd(x, y, sp, cmd) {
            if (!cmd)
                return false;
            var rst = false;
            switch (cmd.cmdID) {
                case "DrawRect":
                    if (cmd.percent)
                        _rect.setTo(cmd.x * sp.width, cmd.y * sp.height, cmd.width * sp.width, cmd.height * sp.height);
                    else
                        _rect.setTo(cmd.x, cmd.y, cmd.width, cmd.height);
                    rst = _rect.contains(x, y);
                    break;
                case "DrawCircle":
                    let r = cmd.radius;
                    var d;
                    if (cmd.percent) {
                        x -= cmd.x * sp.width;
                        y -= cmd.y * sp.height;
                        r *= sp.width;
                    }
                    else {
                        x -= cmd.x;
                        y -= cmd.y;
                    }
                    d = x * x + y * y;
                    rst = d < r * r;
                    break;
                case "DrawPoly":
                    x -= cmd.x;
                    y -= cmd.y;
                    rst = HitArea._ptInPolygon(x, y, cmd.points);
                    break;
            }
            return rst;
        }
        static _ptInPolygon(x, y, areaPoints) {
            var p = _ptPoint;
            p.setTo(x, y);
            var nCross = 0;
            var p1x, p1y, p2x, p2y;
            var len;
            len = areaPoints.length;
            for (var i = 0; i < len; i += 2) {
                p1x = areaPoints[i];
                p1y = areaPoints[i + 1];
                p2x = areaPoints[(i + 2) % len];
                p2y = areaPoints[(i + 3) % len];
                if (p1y == p2y)
                    continue;
                if (p.y < Math.min(p1y, p2y))
                    continue;
                if (p.y >= Math.max(p1y, p2y))
                    continue;
                var tx = (p.y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x;
                if (tx > p.x)
                    nCross++;
            }
            return (nCross % 2 == 1);
        }
        get hit() {
            if (!this._hit)
                this._hit = new Graphics();
            return this._hit;
        }
        set hit(value) {
            this._hit = value;
        }
        get unHit() {
            if (!this._unHit)
                this._unHit = new Graphics();
            return this._unHit;
        }
        set unHit(value) {
            this._unHit = value;
        }
        onAfterDeserialize() {
            if (LayaEnv.isPlaying) {
                if (this._hitCmds) {
                    this.hit.cmds = this._hitCmds;
                    delete this._hitCmds;
                }
                if (this._unHitCmds) {
                    this.unHit.cmds = this._unHitCmds;
                    delete this._unHitCmds;
                }
            }
        }
    }
    ClassUtils.regClass("HitArea", HitArea);

    class Log {
        static enable() {
            if (!Log._logdiv) {
                Log._logdiv = Browser.createElement('div');
                Log._logdiv.style.cssText = "border:white;padding:4px;overflow-y:auto;z-index:1000000;background:rgba(100,100,100,0.6);color:white;position: absolute;left:0px;top:0px;width:50%;height:50%;";
                Browser.document.body.appendChild(Log._logdiv);
                Log._btn = Browser.createElement("button");
                Log._btn.innerText = "Hide";
                Log._btn.style.cssText = "z-index:1000001;position: absolute;left:10px;top:10px;";
                Log._btn.onclick = Log.toggle;
                Browser.document.body.appendChild(Log._btn);
            }
        }
        static toggle() {
            var style = Log._logdiv.style;
            if (style.display === "") {
                Log._btn.innerText = "Show";
                style.display = "none";
            }
            else {
                Log._btn.innerText = "Hide";
                style.display = "";
            }
        }
        static print(value) {
            if (Log._logdiv) {
                if (Log._count >= Log.maxCount)
                    Log.clear();
                Log._count++;
                Log._logdiv.innerText += value + "\n";
                if (Log.autoScrollToBottom) {
                    if (Log._logdiv.scrollHeight - Log._logdiv.scrollTop - Log._logdiv.clientHeight < 50) {
                        Log._logdiv.scrollTop = Log._logdiv.scrollHeight;
                    }
                }
            }
        }
        static clear() {
            Log._logdiv.innerText = "";
            Log._count = 0;
        }
    }
    Log._count = 0;
    Log.maxCount = 50;
    Log.autoScrollToBottom = true;

    let DATANUM = 300;
    class PerfData {
        constructor(id, color, name, scale) {
            this.scale = 1.0;
            this.datas = new Array(DATANUM);
            this.datapos = 0;
            this.id = id;
            this.color = color;
            this.name = name;
            this.scale = scale;
        }
        addData(v) {
            this.datas[this.datapos] = v;
            this.datapos++;
            this.datapos %= DATANUM;
        }
    }

    class PerfHUD extends Sprite {
        constructor() {
            super();
            this.datas = [];
            this.xdata = new Array(PerfHUD.DATANUM);
            this.ydata = new Array(PerfHUD.DATANUM);
            this.hud_width = 800;
            this.hud_height = 200;
            this.gMinV = 0;
            this.gMaxV = 100;
            this.textSpace = 40;
            this.sttm = 0;
            PerfHUD.inst = this;
            this._renderType |= SpriteConst.CUSTOM;
            this._setCustomRender();
            this.addDataDef(0, 0xffffff, 'frame', 1.0);
            this.addDataDef(1, 0x00ff00, 'update', 1.0);
            this.addDataDef(2, 0xff0000, 'flush', 1.0);
            PerfHUD._now = performance ? performance.now.bind(performance) : Date.now;
        }
        now() {
            return PerfHUD._now();
        }
        start() {
            this.sttm = PerfHUD._now();
        }
        end(i) {
            var dt = PerfHUD._now() - this.sttm;
            this.updateValue(i, dt);
        }
        config(w, h) {
            this.hud_width = w;
            this.hud_height = h;
        }
        addDataDef(id, color, name, scale) {
            this.datas[id] = new PerfData(id, color, name, scale);
        }
        updateValue(id, v) {
            this.datas[id].addData(v);
        }
        v2y(v) {
            return this._y + this.hud_height * (1 - (v - this.gMinV) / this.gMaxV);
        }
        drawHLine(ctx, v, color, text) {
            var sx = this._x;
            var sy = this.v2y(v);
            ctx.fillText(text, sx, sy - 6, null, 'green', null);
            sx += this.textSpace;
            ctx.fillStyle = color;
            ctx.fillRect(sx, sy, this._x + this.hud_width, 1, null);
        }
        customRender(ctx, x, y) {
            var now = performance.now();
            if (PerfHUD._lastTm <= 0)
                PerfHUD._lastTm = now;
            this.updateValue(0, now - PerfHUD._lastTm);
            PerfHUD._lastTm = now;
            ctx.save();
            ctx.fillRect(this._x, this._y, this.hud_width, this.hud_height + 4, '#000000cc');
            ctx.globalAlpha = 0.9;
            this.drawHLine(ctx, 0, 'green', '    0');
            this.drawHLine(ctx, 10, 'green', '  10');
            this.drawHLine(ctx, 16.667, 'red', ' ');
            this.drawHLine(ctx, 20, 'green', '50|20');
            this.drawHLine(ctx, 16.667 * 2, 'yellow', '');
            this.drawHLine(ctx, 16.667 * 3, 'yellow', '');
            this.drawHLine(ctx, 16.667 * 4, 'yellow', '');
            this.drawHLine(ctx, 50, 'green', '20|50');
            this.drawHLine(ctx, 100, 'green', '10|100');
            for (var di = 0, sz = this.datas.length; di < sz; di++) {
                var cd = this.datas[di];
                if (!cd)
                    continue;
                var dtlen = cd.datas.length;
                var dx = (this.hud_width - this.textSpace) / dtlen;
                var cx = cd.datapos;
                var _cx = this._x + this.textSpace;
                ctx.fillStyle = cd.color;
                for (var dtsz = dtlen; cx < dtsz; cx++) {
                    var sty = this.v2y(cd.datas[cx] * cd.scale);
                    ctx.fillRect(_cx, sty, dx, this.hud_height + this._y - sty, null);
                    _cx += dx;
                }
                for (cx = 0; cx < cd.datapos; cx++) {
                    sty = this.v2y(cd.datas[cx] * cd.scale);
                    ctx.fillRect(_cx, sty, dx, this.hud_height + this._y - sty, null);
                    _cx += dx;
                }
            }
            ctx.restore();
        }
    }
    PerfHUD._lastTm = 0;
    PerfHUD._now = null;
    PerfHUD.DATANUM = 300;
    PerfHUD.drawTexTm = 0;

    class PoolCache {
        constructor() {
            this.maxCount = 1000;
        }
        getCacheList() {
            return Pool.getPoolBySign(this.sign);
        }
        tryDispose(force) {
            var list;
            list = Pool.getPoolBySign(this.sign);
            if (list.length > this.maxCount) {
                list.splice(this.maxCount, list.length - this.maxCount);
            }
        }
        static addPoolCacheManager(sign, maxCount = 100) {
            var cache;
            cache = new PoolCache();
            cache.sign = sign;
            cache.maxCount = maxCount;
            CacheManger.regCacheByFunction(cache.tryDispose.bind(cache), cache.getCacheList.bind(cache));
        }
    }

    class StringKey {
        constructor() {
            this._strsToID = {};
            this._idToStrs = [];
            this._length = 0;
        }
        add(str) {
            var index = this._strsToID[str];
            if (index != null)
                return index;
            this._idToStrs[this._length] = str;
            return this._strsToID[str] = this._length++;
        }
        getID(str) {
            var index = this._strsToID[str];
            return index == null ? -1 : index;
        }
        getName(id) {
            var str = this._idToStrs[id];
            return str == null ? undefined : str;
        }
    }

    class TimeLine extends EventDispatcher {
        constructor() {
            super(...arguments);
            this._tweenDic = {};
            this._tweenDataList = [];
            this._currTime = 0;
            this._lastTime = 0;
            this._startTime = 0;
            this._index = 0;
            this._gidIndex = 0;
            this._firstTweenDic = {};
            this._startTimeSort = false;
            this._endTimeSort = false;
            this._loopKey = false;
            this.scale = 1;
            this._frameRate = 60;
            this._frameIndex = 0;
            this._total = 0;
        }
        static to(target, props, duration, ease = null, offset = 0) {
            return (new TimeLine()).to(target, props, duration, ease, offset);
        }
        static from(target, props, duration, ease = null, offset = 0) {
            return (new TimeLine()).from(target, props, duration, ease, offset);
        }
        to(target, props, duration, ease = null, offset = 0) {
            return this._create(target, props, duration, ease, offset, true);
        }
        from(target, props, duration, ease = null, offset = 0) {
            return this._create(target, props, duration, ease, offset, false);
        }
        _create(target, props, duration, ease, offset, isTo) {
            var tTweenData = Pool.getItemByClass("tweenData", tweenData);
            tTweenData.isTo = isTo;
            tTweenData.type = 0;
            tTweenData.target = target;
            tTweenData.duration = duration;
            tTweenData.data = props;
            tTweenData.startTime = this._startTime + offset;
            tTweenData.endTime = tTweenData.startTime + tTweenData.duration;
            tTweenData.ease = ease;
            this._startTime = Math.max(tTweenData.endTime, this._startTime);
            this._tweenDataList.push(tTweenData);
            this._startTimeSort = true;
            this._endTimeSort = true;
            return this;
        }
        addLabel(label, offset) {
            var tTweenData = Pool.getItemByClass("tweenData", tweenData);
            tTweenData.type = 1;
            tTweenData.data = label;
            tTweenData.endTime = tTweenData.startTime = this._startTime + offset;
            this._labelDic || (this._labelDic = {});
            this._labelDic[label] = tTweenData;
            this._tweenDataList.push(tTweenData);
            return this;
        }
        removeLabel(label) {
            if (this._labelDic && this._labelDic[label]) {
                var tTweenData = this._labelDic[label];
                if (tTweenData) {
                    var tIndex = this._tweenDataList.indexOf(tTweenData);
                    if (tIndex > -1) {
                        this._tweenDataList.splice(tIndex, 1);
                    }
                }
                delete this._labelDic[label];
            }
        }
        gotoTime(time) {
            if (this._tweenDataList == null || this._tweenDataList.length == 0)
                return;
            var tTween;
            var tObject;
            for (var p in this._firstTweenDic) {
                tObject = this._firstTweenDic[p];
                if (tObject) {
                    for (var tDataP in tObject) {
                        if (tDataP in tObject.diyTarget) {
                            tObject.diyTarget[tDataP] = tObject[tDataP];
                        }
                    }
                }
            }
            for (p in this._tweenDic) {
                tTween = this._tweenDic[p];
                tTween.clear();
                delete this._tweenDic[p];
            }
            this._index = 0;
            this._gidIndex = 0;
            this._currTime = time;
            this._lastTime = Browser.now();
            var tTweenDataCopyList;
            if (this._endTweenDataList == null || this._endTimeSort) {
                this._endTimeSort = false;
                this._endTweenDataList = tTweenDataCopyList = this._tweenDataList.concat();
                function Compare(paraA, paraB) {
                    if (paraA.endTime > paraB.endTime) {
                        return 1;
                    }
                    else if (paraA.endTime < paraB.endTime) {
                        return -1;
                    }
                    else {
                        return 0;
                    }
                }
                tTweenDataCopyList.sort(Compare);
            }
            else {
                tTweenDataCopyList = this._endTweenDataList;
            }
            var tTweenData;
            for (var i = 0, n = tTweenDataCopyList.length; i < n; i++) {
                tTweenData = tTweenDataCopyList[i];
                if (tTweenData.type == 0) {
                    if (time >= tTweenData.endTime) {
                        this._index = Math.max(this._index, i + 1);
                        var props = tTweenData.data;
                        if (tTweenData.isTo) {
                            for (var tP in props) {
                                tTweenData.target[tP] = props[tP];
                            }
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            for (i = 0, n = this._tweenDataList.length; i < n; i++) {
                tTweenData = this._tweenDataList[i];
                if (tTweenData.type == 0) {
                    if (time >= tTweenData.startTime && time < tTweenData.endTime) {
                        this._index = Math.max(this._index, i + 1);
                        this._gidIndex++;
                        tTween = Pool.getItemByClass("tween", Tween);
                        tTween._create(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete, [this._gidIndex]), 0, false, tTweenData.isTo, true, false);
                        tTween.setStartTime(this._currTime - (time - tTweenData.startTime));
                        tTween._updateEase(this._currTime);
                        tTween.gid = this._gidIndex;
                        this._tweenDic[this._gidIndex] = tTween;
                    }
                }
            }
        }
        gotoLabel(Label) {
            if (this._labelDic == null)
                return;
            var tLabelData = this._labelDic[Label];
            if (tLabelData)
                this.gotoTime(tLabelData.startTime);
        }
        pause() {
            ILaya.timer.clear(this, this._update);
        }
        resume() {
            this.play(this._currTime, this._loopKey);
        }
        play(timeOrLabel = 0, loop = false) {
            if (!this._tweenDataList)
                return;
            if (this._startTimeSort) {
                this._startTimeSort = false;
                function Compare(paraA, paraB) {
                    if (paraA.startTime > paraB.startTime) {
                        return 1;
                    }
                    else if (paraA.startTime < paraB.startTime) {
                        return -1;
                    }
                    else {
                        return 0;
                    }
                }
                this._tweenDataList.sort(Compare);
                for (var i = 0, n = this._tweenDataList.length; i < n; i++) {
                    var tTweenData = this._tweenDataList[i];
                    if (tTweenData != null && tTweenData.type == 0) {
                        var tTarget = tTweenData.target;
                        var gid = (tTarget.$_GID || (tTarget.$_GID = Utils.getGID()));
                        var tSrcData = null;
                        if (this._firstTweenDic[gid] == null) {
                            tSrcData = {};
                            tSrcData.diyTarget = tTarget;
                            this._firstTweenDic[gid] = tSrcData;
                        }
                        else {
                            tSrcData = this._firstTweenDic[gid];
                        }
                        for (var p in tTweenData.data) {
                            if (tSrcData[p] == null) {
                                tSrcData[p] = tTarget[p];
                            }
                        }
                    }
                }
            }
            if (typeof (timeOrLabel) == 'string') {
                this.gotoLabel(timeOrLabel);
            }
            else {
                this.gotoTime(timeOrLabel);
            }
            this._loopKey = loop;
            this._lastTime = Browser.now();
            ILaya.timer.frameLoop(1, this, this._update);
        }
        _update() {
            if (this._currTime >= this._startTime) {
                if (this._loopKey) {
                    this._complete();
                    if (!this._tweenDataList)
                        return;
                    this.gotoTime(0);
                }
                else {
                    for (var p in this._tweenDic) {
                        tTween = this._tweenDic[p];
                        tTween.complete();
                    }
                    this.pause();
                    this._complete();
                    return;
                }
            }
            var tNow = Browser.now();
            var tFrameTime = tNow - this._lastTime;
            var tCurrTime = this._currTime += tFrameTime * this.scale;
            this._lastTime = tNow;
            for (p in this._tweenDic) {
                tTween = this._tweenDic[p];
                tTween._updateEase(tCurrTime);
            }
            var tTween;
            if (this._tweenDataList.length != 0 && this._index < this._tweenDataList.length) {
                var tTweenData = this._tweenDataList[this._index];
                if (tCurrTime >= tTweenData.startTime) {
                    this._index++;
                    if (tTweenData.type == 0) {
                        this._gidIndex++;
                        tTween = Pool.getItemByClass("tween", Tween);
                        tTween._create(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete, [this._gidIndex]), 0, false, tTweenData.isTo, true, false);
                        tTween.setStartTime(tCurrTime);
                        tTween.gid = this._gidIndex;
                        this._tweenDic[this._gidIndex] = tTween;
                        tTween._updateEase(tCurrTime);
                    }
                    else {
                        this.event(Event.LABEL, tTweenData.data);
                    }
                }
            }
        }
        _animComplete(index) {
            var tTween = this._tweenDic[index];
            if (tTween)
                delete this._tweenDic[index];
        }
        _complete() {
            this.event(Event.COMPLETE);
        }
        get index() {
            return this._frameIndex;
        }
        set index(value) {
            this._frameIndex = value;
            this.gotoTime(this._frameIndex / this._frameRate * 1000);
        }
        get total() {
            this._total = Math.floor(this._startTime / 1000 * this._frameRate);
            return this._total;
        }
        reset() {
            var p;
            if (this._labelDic) {
                for (p in this._labelDic) {
                    delete this._labelDic[p];
                }
            }
            var tTween;
            for (p in this._tweenDic) {
                tTween = this._tweenDic[p];
                tTween.clear();
                delete this._tweenDic[p];
            }
            for (p in this._firstTweenDic) {
                delete this._firstTweenDic[p];
            }
            this._endTweenDataList = null;
            if (this._tweenDataList && this._tweenDataList.length) {
                var i, len;
                len = this._tweenDataList.length;
                for (i = 0; i < len; i++) {
                    if (this._tweenDataList[i])
                        this._tweenDataList[i].destroy();
                }
            }
            this._tweenDataList.length = 0;
            this._currTime = 0;
            this._lastTime = 0;
            this._startTime = 0;
            this._index = 0;
            this._gidIndex = 0;
            this.scale = 1;
            ILaya.timer.clear(this, this._update);
        }
        destroy() {
            this.reset();
            this._labelDic = null;
            this._tweenDic = null;
            this._tweenDataList = null;
            this._firstTweenDic = null;
        }
    }
    class tweenData {
        constructor() {
            this.type = 0;
            this.isTo = true;
        }
        destroy() {
            this.target = null;
            this.ease = null;
            this.data = null;
            this.isTo = true;
            this.type = 0;
            Pool.recover("tweenData", this);
        }
    }

    class WasmAdapter {
        static create(module, wasmFile) {
            var _a;
            let webDir;
            if (typeof document != 'undefined') {
                webDir = (_a = document.currentScript) === null || _a === void 0 ? void 0 : _a.src;
                if (webDir)
                    webDir = webDir.substring(0, webDir.replace(/[?#].*/, "").lastIndexOf("/") + 1);
            }
            return () => {
                let moduleArg = {};
                if (WasmAdapter.instantiateWasm != null) {
                    moduleArg["instantiateWasm"] = function (imports, receiveInstance) {
                        return WasmAdapter.instantiateWasm(wasmFile, imports).then(exports => {
                            receiveInstance(exports["instance"]);
                            return exports;
                        });
                    };
                }
                moduleArg["locateFile"] = function (path, scriptDirectory) {
                    if (WasmAdapter.locateFile != null)
                        wasmFile = WasmAdapter.locateFile(path, scriptDirectory, webDir);
                    else
                        wasmFile = scriptDirectory + path;
                    return wasmFile;
                };
                return module(moduleArg);
            };
        }
    }
    WasmAdapter.Memory = typeof (WebAssembly) !== "undefined" ? WebAssembly.Memory : null;

    class PerfTools {
        static begin(block) {
        }
        static end(block) {
        }
    }
    class PerformanceDefine {
    }
    window.PerformanceDefine = PerformanceDefine;
    function PERF_BEGIN(block) {
        PerfTools.begin(block);
    }
    window.PERF_BEGIN = PERF_BEGIN;
    function PERF_END(block) {
        PerfTools.end(block);
    }
    window.PERF_BEGIN = PERF_END;
    function PERF_FRAMECLEAR() {
    }
    window.PERF_FRAMECLEAR = PERF_FRAMECLEAR;

    exports.BaseRender2DType = void 0;
    (function (BaseRender2DType) {
        BaseRender2DType[BaseRender2DType["baseRenderNode"] = 0] = "baseRenderNode";
        BaseRender2DType[BaseRender2DType["spine"] = 1] = "spine";
        BaseRender2DType[BaseRender2DType["particle"] = 2] = "particle";
        BaseRender2DType[BaseRender2DType["spineSimple"] = 3] = "spineSimple";
    })(exports.BaseRender2DType || (exports.BaseRender2DType = {}));
    exports.Render2DOrderMode = void 0;
    (function (Render2DOrderMode) {
        Render2DOrderMode[Render2DOrderMode["elementIndex"] = 0] = "elementIndex";
        Render2DOrderMode[Render2DOrderMode["ysort"] = 1] = "ysort";
    })(exports.Render2DOrderMode || (exports.Render2DOrderMode = {}));
    class BaseRenderNode2D extends Component {
        _getcommonUniformMap() {
            return ["sprite2D"];
        }
        _getRect() {
            return null;
        }
        _transformChange() {
        }
        get sharedMaterial() {
            return this._materials[0];
        }
        set sharedMaterial(value) {
            var lastValue = this._materials[0];
            if (lastValue !== value) {
                this._materials[0] = value;
                this._changeMaterialReference(lastValue, value);
                this._renderElements[0] && this._setRenderElement2DMaterial(this._renderElements[0], value);
            }
        }
        _setRenderElement2DMaterial(element, material) {
            element.subShader = material._shader.getSubShaderAt(0);
            element.materialShaderData = material._shaderValues;
        }
        _changeMaterialReference(lastValue, value) {
            (lastValue) && (lastValue._removeReference());
            (value) && (value._addReference());
        }
        constructor() {
            super();
            this._renderType = exports.BaseRender2DType.baseRenderNode;
            this._renderUpdateMask = 0;
            this._layer = 0;
            this._renderid = BaseRenderNode2D._uniqueIDCounter++;
            this._spriteShaderData = LayaGL.renderDeviceFactory.createShaderData(null);
            this._renderType = exports.BaseRender2DType.baseRenderNode;
            this._ordingMode = exports.Render2DOrderMode.elementIndex;
            this._layer = 1;
        }
        _onEnable() {
            super._onEnable();
            if (this.owner) {
                this.owner.renderNode2D = this;
            }
        }
        _onDisable() {
            if (this.owner) {
                this.owner.renderNode2D = null;
            }
        }
        _onDestroy() {
            for (var i = 0, n = this._materials.length; i < n; i++) {
                let m = this._materials[i];
                m && !m.destroyed && m._removeReference();
            }
            this._spriteShaderData.destroy();
            this.owner = null;
        }
        clear() {
            this._renderElements.length = 0;
        }
    }
    BaseRenderNode2D._uniqueIDCounter = 0;

    class CommandUniformMap {
        constructor(stateName) {
        }
        addShaderUniform(propertyID, propertyKey, uniformtype, block = null) {
            throw "need override it";
        }
        addShaderUniformArray(propertyID, propertyName, uniformtype, arrayLength, block = "") {
            throw "need override it";
        }
        addShaderBlockUniform(propertyID, blockname, blockProperty) {
            throw "need override it";
        }
    }

    class UniformBufferBlock {
        constructor(sn, cluster, index, size, alignedSize, user) {
            this.destroyed = false;
            this.sn = sn;
            this.cluster = cluster;
            this.index = index;
            this.size = size;
            this.alignedSize = alignedSize;
            this.offset = alignedSize * index;
            this.user = user;
            this.uploadNum = 0;
            this.moved = false;
        }
        needUpload() {
            this.uploadNum++;
            this.cluster.needUpload[this.index] = true;
        }
        destroy() {
            if (!this.destroyed) {
                this.cluster = null;
                this.user = null;
                this.destroyed = true;
                return true;
            }
            console.warn('UniformBufferBlock: object alreay destroyed!');
            return false;
        }
    }

    class UniformBufferCluster {
        constructor(blockSize, blockNum, manager) {
            this.sn = 0;
            this.needUpload = [];
            this.destroyed = false;
            this.blocks = [];
            this.expand = 10;
            this.manager = manager;
            this.blockSize = blockSize;
            this.blockNum = blockNum;
            this.totalSize = blockSize * blockNum;
            this.data = new ArrayBuffer(this.totalSize);
            this.move = new Uint8Array(this.blockSize);
            this.buffer = this.manager.createGPUBuffer(this.totalSize);
            this.needUpload.length = this.blockNum;
            this.needUpload.fill(false);
            this.manager.statisGPUMemory(this.totalSize);
        }
        get usedNum() {
            return this.blocks.length;
        }
        _expandBuffer() {
            let expandNum = this.blockNum;
            this.blockNum += this.expand;
            if (this.blockNum > this.manager.clusterMaxBlock)
                this.blockNum = this.manager.clusterMaxBlock;
            expandNum = this.blockNum - expandNum;
            this.totalSize = this.blockSize * this.blockNum;
            const expandSize = this.blockSize * this.expand;
            this.needUpload = this.needUpload.concat(new Array(expandNum).fill(false));
            const newArrayBuffer = new ArrayBuffer(this.totalSize);
            new Uint8Array(newArrayBuffer).set(new Uint8Array(this.data));
            this.data = newArrayBuffer;
            this.buffer = this.manager.createGPUBuffer(this.totalSize);
            this.manager.statisGPUMemory(expandSize);
            this.blocks.forEach(block => block && block.user.notifyGPUBufferChange());
            this.manager.renderContext.notifyGPUBufferChange();
        }
        _moveBlock(index) {
            const len = this.blocks.length;
            if (index >= len)
                return;
            const dataView = new Uint8Array(this.data);
            const size = this.blockSize;
            for (let i = index + 1; i < len; i++) {
                const start = i * size;
                const end = start + size;
                const target = start - size;
                dataView.copyWithin(target, start, end);
                this.needUpload[i - 1] = this.needUpload[i];
                this.blocks[i - 1] = this.blocks[i];
                if (this.blocks[i - 1]) {
                    this.blocks[i - 1].index--;
                    this.blocks[i - 1].offset -= size;
                    this.blocks[i - 1].user.notifyGPUBufferChange();
                }
            }
            this.blocks.length--;
            this.manager.renderContext.notifyGPUBufferChange();
        }
        getBlock(size, user) {
            const alignedSize = roundUp(size, this.manager.byteAlign);
            if (alignedSize !== this.blockSize) {
                console.warn('WebGPUBufferCluster: 获取内存块时, 长度错误!');
                return null;
            }
            const index = this._getBlockWithExpand();
            const bb = new UniformBufferBlock(this.manager.snCounter++, this, index, size, alignedSize, user);
            this.blocks[index] = bb;
            return bb;
        }
        freeBlock(bb) {
            const index = this.blocks.indexOf(bb);
            if (index !== -1) {
                if (index === this.blocks.length - 1) {
                    this.blocks.length--;
                }
                else {
                    this.blocks[index] = null;
                    this.needUpload[index] = false;
                }
                bb.destroy();
                return true;
            }
            return false;
        }
        upload() {
            let count = 0;
            let bytes = 0;
            let next = false;
            let startIndex = -1;
            let endIndex = -1;
            let offset = 0;
            let size = 0;
            for (let i = 0, len = this.blocks.length; i < len; i++) {
                if (this.needUpload[i]) {
                    if (startIndex === -1)
                        startIndex = i;
                    endIndex = i;
                    next = true;
                    this.needUpload[i] = false;
                }
                else {
                    if (next) {
                        offset = startIndex * this.blockSize;
                        size = (endIndex - startIndex + 1) * this.blockSize;
                        this.manager.writeBuffer(this.buffer, this.data, offset, size);
                        count++;
                        bytes += size;
                        startIndex = -1;
                        endIndex = -1;
                        next = false;
                    }
                }
            }
            if (next) {
                offset = startIndex * this.blockSize;
                size = (endIndex - startIndex + 1) * this.blockSize;
                this.manager.writeBuffer(this.buffer, this.data, offset, size);
                count++;
                bytes += size;
            }
            this.manager.uploadNum += count;
            this.manager.uploadByte += bytes;
            this.manager.statisUpload(count, bytes);
        }
        optimize() {
            for (let i = this.blocks.length - 1; i > -1; i--) {
                const bb = this.blocks[i];
                if (bb && bb.uploadNum > this.manager.uploadThreshold && !bb.moved && i > 0) {
                    const needUpload = this.needUpload[i];
                    const size = this.blockSize;
                    const dataView = new Uint8Array(this.data);
                    this.move.set(new Uint8Array(this.data, size * i, size));
                    for (let j = i - 1; j >= 0; j--) {
                        const start = j * size;
                        const end = start + size;
                        const target = start + size;
                        dataView.copyWithin(target, start, end);
                        this.needUpload[j + 1] = this.needUpload[j];
                        this.blocks[j + 1] = this.blocks[j];
                        if (this.blocks[j + 1]) {
                            this.blocks[j + 1].index++;
                            this.blocks[j + 1].offset += size;
                            this.blocks[j + 1].user.notifyGPUBufferChange();
                        }
                    }
                    dataView.set(this.move);
                    this.needUpload[0] = needUpload;
                    bb.index = 0;
                    bb.offset = 0;
                    bb.moved = true;
                    this.blocks[0] = bb;
                    this.blocks[0].user.notifyGPUBufferChange();
                    this.manager.renderContext.notifyGPUBufferChange();
                    this.manager.moveNum++;
                    break;
                }
            }
        }
        removeHole() {
            for (let i = this.blocks.length - 1; i > -1; i--) {
                if (!this.blocks[i]) {
                    this._moveBlock(i);
                    break;
                }
            }
        }
        clear(blockNum) {
            this.blocks.forEach(block => block && block.destroy());
            this.blocks.length = 0;
            if (blockNum != undefined && blockNum > 0 && blockNum !== this.blockNum) {
                this.blockNum = blockNum;
                this.totalSize = this.blockSize * this.blockNum;
                this.buffer = this.manager.createGPUBuffer(this.totalSize);
                this.data = new ArrayBuffer(this.totalSize);
            }
            else {
                this.blockNum = 0;
                this.totalSize = 0;
                this.buffer = null;
                this.data = null;
            }
            this.needUpload.length = this.blockNum;
            this.needUpload.fill(false);
        }
        _getBlockWithExpand() {
            for (let i = this.blocks.length - 1; i > -1; i--) {
                if (!this.blocks[i])
                    return i;
            }
            if (this.blocks.length < this.blockNum)
                return this.blocks.length;
            else {
                this._expandBuffer();
                return this.blocks.length;
            }
        }
        destroy() {
            var _a;
            if (!this.destroyed) {
                this.clear();
                (_a = this.buffer.destroy) !== null && _a !== void 0 ? _a : this.buffer.destroy();
                this.manager.statisGPUMemory(-this.totalSize);
                this.destroyed = true;
                return true;
            }
            console.warn('UniformBufferCluster: object alreay destroyed!');
            return false;
        }
    }

    function roundUp(n, align) {
        return (((n + align - 1) / align) | 0) * align;
    }
    function roundDown(n, align) {
        const res = (((n + align - 1) / align) | 0) * align;
        return res > n ? res - align : res;
    }
    class UniformBufferManager {
        constructor(useBigBuffer) {
            this.useBigBuffer = true;
            this.destroyed = false;
            this.snCounter = 0;
            this.byteAlign = 256;
            this.clusterMaxBlock = 256;
            this.uploadThreshold = 200;
            this.moveNum = 0;
            this.uploadNum = 0;
            this.uploadByte = 0;
            this.removeHoleTimer = 0;
            this.timeCostAvg = 0;
            this.timeCostSum = 0;
            this.timeCostCount = 0;
            this.clustersAll = new Map();
            this.clustersCur = new Map();
            this.useBigBuffer = useBigBuffer;
        }
        _addCluster(size, blockNum = 10) {
            const alignedSize = roundUp(size, this.byteAlign);
            const cluster = new UniformBufferCluster(alignedSize, blockNum, this);
            const clusters = this.clustersAll.get(alignedSize);
            if (clusters) {
                clusters.push(cluster);
                cluster.sn = clusters.length - 1;
            }
            else
                this.clustersAll.set(alignedSize, [cluster]);
            this.clustersCur.set(alignedSize, cluster);
            return cluster;
        }
        _removeHole() {
            if (this.useBigBuffer) {
                this.clustersAll.forEach(clusters => {
                    for (let i = clusters.length - 1; i > -1; i--)
                        clusters[i].removeHole();
                });
            }
        }
        startFrame() {
            this.uploadNum = 0;
            this.uploadByte = 0;
        }
        setRenderContext(renderContext) {
            this.renderContext = renderContext;
        }
        getBufferAlone(size, name) {
            const alignedSize = roundUp(size, this.byteAlign);
            this.statisGPUMemory(alignedSize);
            return this.createGPUBuffer(alignedSize, name);
        }
        removeCluster(size, sn) {
            const alignedSize = roundUp(size, this.byteAlign);
            if (sn === -1) {
                this.clustersAll.delete(alignedSize);
                this.clustersCur.delete(alignedSize);
                return;
            }
            const cluster = this.clustersCur.get(alignedSize);
            const clusters = this.clustersAll.get(alignedSize);
            if (clusters.length > sn) {
                clusters.splice(sn, 1);
                if (clusters.length === 0) {
                    this.clustersAll.delete(alignedSize);
                    this.clustersCur.delete(alignedSize);
                    return;
                }
                else {
                    for (let i = sn; i < clusters.length; i++)
                        clusters[i].sn--;
                }
            }
            else
                return;
            if (cluster.sn === sn) {
                if (clusters.length === 1)
                    this.clustersCur.set(alignedSize, clusters[0]);
                else {
                    let index = 0;
                    let usedNum = clusters[0].usedNum;
                    for (let i = 1; i < clusters.length; i++) {
                        if (clusters[i].usedNum < usedNum) {
                            index = i;
                            usedNum = clusters[i].usedNum;
                        }
                    }
                    this.clustersCur.set(alignedSize, clusters[index]);
                }
            }
        }
        getBlock(size, user) {
            const alignedSize = roundUp(size, this.byteAlign);
            let cluster = this.clustersCur.get(alignedSize);
            if (!cluster)
                return this._addCluster(alignedSize).getBlock(size, user);
            if (cluster.usedNum < this.clusterMaxBlock)
                return cluster.getBlock(size, user);
            cluster = null;
            const clusters = this.clustersAll.get(alignedSize);
            for (let i = clusters.length - 1; i > -1; i--) {
                if (clusters[i].usedNum < this.clusterMaxBlock) {
                    cluster = clusters[i];
                    this.clustersCur.set(alignedSize, cluster);
                    break;
                }
            }
            if (cluster)
                return cluster.getBlock(size, user);
            return this._addCluster(alignedSize).getBlock(size, user);
        }
        freeBlock(bb) {
            const cluster = bb.cluster;
            if (cluster) {
                if (cluster.freeBlock(bb)) {
                    if (cluster.usedNum === 0)
                        this.removeCluster(cluster.blockSize, cluster.sn);
                    return true;
                }
                return false;
            }
            return false;
        }
        upload() {
            if (this.useBigBuffer) {
                const t = performance.now();
                this.clustersAll.forEach(clusters => {
                    for (let i = clusters.length - 1; i > -1; i--) {
                        clusters[i].upload();
                        clusters[i].optimize();
                    }
                });
                this.timeCostSum += performance.now() - t;
                this.timeCostCount++;
                if (this.timeCostCount > 100) {
                    this.timeCostAvg = (this.timeCostSum / this.timeCostCount) * 1000 | 0;
                    this.timeCostSum = 0;
                    this.timeCostCount = 0;
                }
                this.removeHoleTimer++;
                if (this.removeHoleTimer > 1000) {
                    this.removeHoleTimer = 0;
                    this._removeHole();
                }
            }
        }
        clear() {
            this.clustersAll.forEach(clusters => {
                for (let i = clusters.length - 1; i > -1; i--)
                    clusters[i].clear();
            });
        }
        destroy() {
            if (!this.destroyed) {
                this.clear();
                this.clustersAll.clear();
                this.clustersCur.clear();
                this.destroyed = true;
                return true;
            }
            console.warn('UniformBufferManager: object alreay destroyed!');
            return false;
        }
        createGPUBuffer(size, name) {
        }
        writeBuffer(buffer, data, offset, size) {
        }
        statisGPUMemory(bytes) {
        }
        statisUpload(count, bytes) {
        }
    }

    class UniformBufferAlone {
        constructor(size, manager) {
            this.destroyed = false;
            this.data = new ArrayBuffer(size);
            this.buffer = manager.getBufferAlone(size);
            this.manager = manager;
            this.size = size;
            this.alignedSize = roundUp(size, manager.byteAlign);
        }
        upload() {
            const t = performance.now();
            this.manager.writeBuffer(this.buffer, this.data, 0, this.size);
            this.manager.timeCostSum += performance.now() - t;
            this.manager.timeCostCount++;
            if (this.manager.timeCostCount > 100) {
                this.manager.timeCostAvg = (this.manager.timeCostSum / this.manager.timeCostCount) * 1000 | 0;
                this.manager.timeCostSum = 0;
                this.manager.timeCostCount = 0;
            }
            this.manager.uploadNum++;
            this.manager.uploadByte += this.size;
            this.manager.statisUpload(1, this.size);
        }
        destroy() {
            var _a;
            if (!this.destroyed) {
                this.data = null;
                (_a = this.buffer.destroy) !== null && _a !== void 0 ? _a : this.buffer.destroy();
                this.manager.statisGPUMemory(-this.size);
                this.destroyed = true;
                return true;
            }
            console.warn('UniformBufferAlone: object alreay destroyed!');
            return false;
        }
    }

    class UniformBufferUser {
        constructor(name, size, manager, data) {
            this.destroyed = false;
            this.name = name;
            this.strId = '';
            this.items = new Map();
            this.itemNum = 0;
            this.data = data;
            this.size = size;
            this.manager = manager;
            this.needUpload = false;
            if (manager.useBigBuffer) {
                this.bufferBlock = manager.getBlock(size, this);
                this.offset = this.bufferBlock.offset;
            }
            else
                this.bufferAlone = new UniformBufferAlone(size, manager);
        }
        notifyGPUBufferChange() {
            const offset = this.bufferBlock.offset - this.offset;
            this.offset = this.bufferBlock.offset;
            this.items.forEach(item => {
                const tac = UniformBufferUser._typeArray(item.type);
                item.view = new tac(this.bufferBlock.cluster.data, item.view.byteOffset + offset, item.size / tac.BYTES_PER_ELEMENT);
            });
            this.clearGPUBufferBind();
            this.needUpload = true;
        }
        clearGPUBufferBind() { }
        addUniform(id, name, type, offset, align, size, elements, count) {
            if (this.items.has(id))
                return;
            this.items.set(id, this._getUniformItem(name, UniformBufferUser._typeArray(type), type, offset, align, size, elements, count));
            if (this.strId.length > 0)
                this.strId += '|';
            this.strId += id;
            this.itemNum++;
        }
        setUniformData(id, data) {
            const item = this.items.get(id);
            if (item) {
                this.needUpload = true;
                if (item.count == 1) {
                    switch (item.type) {
                        case 'int':
                        case 'float':
                            item.view[0] = data;
                            break;
                        case 'vec2':
                            item.view[0] = data.x;
                            item.view[1] = data.y;
                            break;
                        case 'vec3':
                            item.view[0] = data.x;
                            item.view[1] = data.y;
                            item.view[2] = data.z;
                            break;
                        case 'vec4':
                            item.view[0] = data.x;
                            item.view[1] = data.y;
                            item.view[2] = data.z;
                            item.view[3] = data.w;
                            break;
                        case 'mat3':
                            for (let i = 0; i < 3; i++) {
                                item.view[i * 4 + 0] = data.elements[i * 3 + 0];
                                item.view[i * 4 + 1] = data.elements[i * 3 + 1];
                                item.view[i * 4 + 2] = data.elements[i * 3 + 2];
                            }
                            break;
                        case 'mat4':
                            item.view.set(data.elements);
                            break;
                    }
                }
                else {
                    const arraySize = item.count * item.elements;
                    const alignElements = item.size / item.count / item.view.BYTES_PER_ELEMENT;
                    for (let i = 0, j = 0; i < arraySize; i += item.elements, j += alignElements)
                        item.view.set(data.subarray(i, i + item.elements), j);
                }
            }
        }
        setBool(id, data) {
            const item = this.items.get(id);
            if (item) {
                item.view[0] = data ? 1 : 0;
                this.needUpload = true;
            }
        }
        setBoolArray(id, data) {
            const item = this.items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++)
                    item.view[i] = data[i] ? 1 : 0;
                this.needUpload = true;
            }
        }
        setInt(id, data) {
            const item = this.items.get(id);
            if (item) {
                item.view[0] = data;
                this.needUpload = true;
            }
        }
        setIntArray(id, data) {
            const item = this.items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++)
                    item.view[i] = data[i];
                this.needUpload = true;
            }
        }
        setFloat(id, data) {
            const item = this.items.get(id);
            if (item) {
                item.view[0] = data;
                this.needUpload = true;
            }
        }
        setFloatArray(id, data) {
            const item = this.items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++)
                    item.view[i] = data[i];
                this.needUpload = true;
            }
        }
        setVector2(id, data) {
            const item = this.items.get(id);
            if (item) {
                item.view[0] = data.x;
                item.view[1] = data.y;
                this.needUpload = true;
            }
        }
        setVector2Array(id, data) {
            const item = this.items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++) {
                    item.view[i * 2 + 0] = data[i].x;
                    item.view[i * 2 + 1] = data[i].y;
                }
                this.needUpload = true;
            }
        }
        setVector3(id, data) {
            const item = this.items.get(id);
            if (item) {
                item.view[0] = data.x;
                item.view[1] = data.y;
                item.view[2] = data.z;
                this.needUpload = true;
            }
        }
        setVector3Array(id, data) {
            const item = this.items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++) {
                    item.view[i * 4 + 0] = data[i].x;
                    item.view[i * 4 + 1] = data[i].y;
                    item.view[i * 4 + 2] = data[i].z;
                }
                this.needUpload = true;
            }
        }
        setVector4(id, data) {
            const item = this.items.get(id);
            if (item) {
                item.view[0] = data.x;
                item.view[1] = data.y;
                item.view[2] = data.z;
                item.view[3] = data.w;
                this.needUpload = true;
            }
        }
        setVector4Array(id, data) {
            const item = this.items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++) {
                    item.view[i * 4 + 0] = data[i].x;
                    item.view[i * 4 + 1] = data[i].y;
                    item.view[i * 4 + 2] = data[i].z;
                    item.view[i * 4 + 3] = data[i].w;
                }
                this.needUpload = true;
            }
        }
        setMatrix3x3(id, data) {
            const item = this.items.get(id);
            if (item) {
                for (let i = 0; i < 3; i++) {
                    item.view[i * 4 + 0] = data.elements[i * 3 + 0];
                    item.view[i * 4 + 1] = data.elements[i * 3 + 1];
                    item.view[i * 4 + 2] = data.elements[i * 3 + 2];
                }
                this.needUpload = true;
            }
        }
        setMatrix3x3Array(id, data) {
            const item = this.items.get(id);
            if (item) {
                for (let j = 0, len = Math.min(item.count, data.length); j < len; j++) {
                    for (let i = 0; i < 3; i++) {
                        item.view[j * 16 + i * 4 + 0] = data[j].elements[i * 3 + 0];
                        item.view[j * 16 + i * 4 + 1] = data[j].elements[i * 3 + 1];
                        item.view[j * 16 + i * 4 + 2] = data[j].elements[i * 3 + 2];
                    }
                }
                this.needUpload = true;
            }
        }
        setMatrix4x4(id, data) {
            const item = this.items.get(id);
            if (item) {
                item.view.set(data.elements);
                this.needUpload = true;
            }
        }
        setMatrix4x4Array(id, data) {
            const item = this.items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++)
                    item.view.set(data[i].elements, i * 16);
                this.needUpload = true;
            }
        }
        setBuffer(id, data) {
            this.setUniformData(id, data);
        }
        getUniform(id) {
            return this.items.get(id);
        }
        hasUniform(id) {
            return this.items.has(id);
        }
        isMe(strId) {
            return this.strId === strId;
        }
        upload() {
            if (this.needUpload) {
                if (this.manager.useBigBuffer)
                    this.bufferBlock.needUpload();
                else
                    this.bufferAlone.upload();
                this.needUpload = false;
            }
        }
        clear() {
            if (this.manager.useBigBuffer)
                new Uint8Array(this.bufferBlock.cluster.data).fill(0, this.bufferBlock.offset, this.bufferBlock.offset + this.bufferBlock.size);
            else
                new Uint8Array(this.bufferAlone.data).fill(0);
            this.strId = '';
            this.items.clear();
            this.itemNum = 0;
            this.needUpload = false;
        }
        destroy() {
            if (!this.destroyed) {
                if (this.manager.useBigBuffer)
                    this.manager.freeBlock(this.bufferBlock);
                else
                    this.bufferAlone.destroy();
                this.destroyed = true;
                return true;
            }
            console.warn('UniformBufferUser: object alreay destroyed!');
            return false;
        }
        _getUniformItem(name, tac, type, offset, align, size, elements, count) {
            let view;
            if (this.manager.useBigBuffer)
                view = new tac(this.bufferBlock.cluster.data, this.bufferBlock.offset + offset, size / tac.BYTES_PER_ELEMENT);
            else
                view = new tac(this.bufferAlone.data, offset, size / tac.BYTES_PER_ELEMENT);
            return { name, view, type, align, size, elements, count };
        }
        static _typeArray(type) {
            switch (type) {
                case 'int':
                    return Int32Array;
                case 'float':
                case 'vec2':
                case 'vec3':
                case 'vec4':
                case 'mat3':
                case 'mat4':
                    return Float32Array;
                default:
                    return Float32Array;
            }
        }
    }

    class Sound extends EventDispatcher {
        load(url) {
        }
        play(startTime = 0, loops = 0) {
            return null;
        }
        get duration() {
            return 0;
        }
        dispose() {
        }
    }

    class Socket extends EventDispatcher {
        get input() {
            return this._input;
        }
        get output() {
            return this._output;
        }
        get connected() {
            return this._connected;
        }
        get endian() {
            return this._endian;
        }
        set endian(value) {
            this._endian = value;
            if (this._input != null)
                this._input.endian = value;
            if (this._output != null)
                this._output.endian = value;
        }
        constructor(host = null, port = 0, byteClass = null, protocols = null, isSecure = false) {
            super();
            this.disableInput = false;
            this.protocols = [];
            this._byteClass = byteClass ? byteClass : Byte;
            this.protocols = protocols;
            this.endian = Socket.BIG_ENDIAN;
            if (host && port > 0 && port < 65535)
                this.connect(host, port, isSecure);
        }
        connect(host, port, isSecure = false) {
            this.connectByUrl(`${isSecure ? "wss" : "ws"}://${host}:${port}`);
        }
        connectByUrl(url) {
            if (this._socket != null)
                this.close();
            this._socket && this.cleanSocket();
            if (!this.protocols || this.protocols.length == 0) {
                this._socket = new Browser.window.WebSocket(url);
            }
            else {
                this._socket = new Browser.window.WebSocket(url, this.protocols);
            }
            this._socket.binaryType = "arraybuffer";
            this._output = new this._byteClass();
            this._output.endian = this.endian;
            this._input = new this._byteClass();
            this._input.endian = this.endian;
            this._addInputPosition = 0;
            this._socket.onopen = (e) => {
                this._onOpen(e);
            };
            this._socket.onmessage = (msg) => {
                this._onMessage(msg);
            };
            this._socket.onclose = (e) => {
                this._onClose(e);
            };
            this._socket.onerror = (e) => {
                this._onError(e);
            };
        }
        cleanSocket() {
            this.close();
            this._connected = false;
            this._socket.onopen = null;
            this._socket.onmessage = null;
            this._socket.onclose = null;
            this._socket.onerror = null;
            this._socket = null;
        }
        close() {
            if (this._socket != null) {
                try {
                    this._socket.close();
                }
                catch (e) {
                }
            }
        }
        _onOpen(e) {
            this._connected = true;
            this.event(Event.OPEN, e);
        }
        _onMessage(msg) {
            if (!msg || !msg.data)
                return;
            var data = msg.data;
            if (this.disableInput && data) {
                this.event(Event.MESSAGE, data);
                return;
            }
            if (this._input.length > 0 && this._input.bytesAvailable < 1) {
                this._input.clear();
                this._addInputPosition = 0;
            }
            var pre = this._input.pos;
            !this._addInputPosition && (this._addInputPosition = 0);
            this._input.pos = this._addInputPosition;
            if (data) {
                if (typeof (data) == 'string') {
                    this._input.writeUTFBytes(data);
                }
                else {
                    this._input.writeArrayBuffer(data);
                }
                this._addInputPosition = this._input.pos;
                this._input.pos = pre;
            }
            this.event(Event.MESSAGE, data);
        }
        _onClose(e) {
            this._connected = false;
            this.event(Event.CLOSE, e);
        }
        _onError(e) {
            this.event(Event.ERROR, e);
        }
        send(data) {
            this._socket.send(data);
        }
        flush() {
            if (this._output && this._output.length > 0) {
                var evt;
                try {
                    this._socket && this._socket.send(this._output.__getBuffer().slice(0, this._output.length));
                }
                catch (e) {
                    evt = e;
                }
                this._output.endian = this.endian;
                this._output.clear();
                if (evt)
                    this.event(Event.ERROR, evt);
            }
        }
    }
    Socket.LITTLE_ENDIAN = "littleEndian";
    Socket.BIG_ENDIAN = "bigEndian";

    class BinHashUtils {
        static getHash(buffer, start, len, magic = 9191891) {
            var i;
            var rst = 0;
            for (i = 0; i < len; i++) {
                rst = (rst * 2 + buffer[start + i]) % magic;
            }
            return rst;
        }
        static isSame(buffer1, start1, len1, buffer2, start2, len2) {
            if (len1 != len2)
                return false;
            var i, len;
            len = len1;
            for (i = 0; i < len; i++) {
                if (buffer1[start1 + i] != buffer2[start2 + i])
                    return false;
            }
            return true;
        }
    }

    class JsonBinRead {
        static get instance() {
            return JsonBinRead._instance || (JsonBinRead._instance = new JsonBinRead());
        }
        static IsJsonbin(data) {
            if (data.byteLength < 5)
                return false;
            const value = (new Uint32Array(data, 0, 4))[0];
            return value == JsonBinRead.ISJSONBIN || value == JsonBinRead.ISJSONBIN2 || value == JsonBinRead.ISJSONBIN3;
        }
        static parse(value) {
            var int32 = new Int32Array(value, 0, 4);
            if (int32[0] !== JsonBinRead.ISJSONBIN && int32[0] !== JsonBinRead.ISJSONBIN2) {
                var b = new Byte();
                b.writeArrayBuffer(value);
                b.pos = 0;
                var str = b.readUTFBytes();
                return JSON.parse(str);
            }
            var r = new JsonBinRead();
            return r.read(value);
        }
        static parsePack(value) {
            var r = new JsonBinRead();
            var o = r.read(value);
            for (var key in o)
                Loader.cacheRes(key, o[key]);
            return o;
        }
        constructor() {
        }
        _readArray(data, pos, n, type, keyMap) {
            var array = [];
            array.length = n;
            var endPos;
            if (pos >= 0) {
                endPos = data.pos;
                data.pos = pos;
            }
            for (var i = 0; i < n; i++) {
                array[i] = this._readOne({}, data, null, data.readUint8(), keyMap);
            }
            if (pos >= 0) {
                data.pos = endPos;
            }
            return array;
        }
        _getLen(data) {
            let n = data.readUint8();
            return (n & 0x80) == 0 ? n : (data.readUint8() | ((n & ~0x80) << 8));
        }
        static _toLargeNumber(n1, n2) {
            let n2str = n2.toString(16);
            if (n2str.length < 7) {
                for (let i = n2str.length; i < 7; i++)
                    n2str = "0" + n2str;
            }
            return parseInt(n1.toString(16) + "" + n2str, 16);
        }
        static readInt8Array(byte, start, len) {
            var end = start + len;
            end = (end > byte._length) ? byte._length : end;
            var v = new Int8Array(byte._d_.buffer.slice(start, end));
            byte._pos_ = end;
            return v;
        }
        _readOne(parent, data, key, type, keyMap) {
            let n, value;
            switch (type) {
                case JsonBinRead.NULL:
                    value = null;
                    break;
                case JsonBinRead.NUM8:
                    value = data.readByte();
                    break;
                case JsonBinRead.NUM16:
                    value = data.readInt16();
                    break;
                case JsonBinRead.NUM32:
                    value = data.readInt32();
                    break;
                case JsonBinRead.NUM64:
                    value = JsonBinRead._toLargeNumber(data.readInt32(), data.readInt32());
                    break;
                case JsonBinRead.BOOLEAN:
                    value = data.readByte() ? true : false;
                    break;
                case JsonBinRead.DOUBLE:
                    value = data.readFloat32();
                    break;
                case JsonBinRead.NUM16_1000:
                    value = data.readInt16() / 1000;
                    break;
                case JsonBinRead.NUM32_1000:
                    value = data.readInt32() / 1000;
                    break;
                case JsonBinRead.STRING:
                    value = keyMap.keyArray[data.readUint16()][0];
                    break;
                case JsonBinRead.WORDTEXT:
                    n = data.readUint16();
                    value = keyMap.keyArray[n][3];
                    if (!value) {
                        value = keyMap.keyArray[n][3] = new WordText$1();
                        value.setText(keyMap.keyArray[n][0]);
                    }
                    break;
                case JsonBinRead.ARRAYEMPTY:
                    data.readUint8();
                    value = [];
                    break;
                case JsonBinRead.ARRAYNUM8:
                    value = [];
                    value.length = n = data.readUint8();
                    for (let i = 0; i < n; i++)
                        value[i] = data.readByte();
                    break;
                case JsonBinRead.ARRAYNUM16:
                    value = [];
                    value.length = n = data.readUint8();
                    for (let i = 0; i < n; i++)
                        value[i] = data.readInt16();
                    break;
                case JsonBinRead.ARRAYNUM32:
                    value = [];
                    value.length = n = data.readUint8();
                    for (let i = 0; i < n; i++)
                        value[i] = data.readInt32();
                    break;
                case JsonBinRead.ARRAYDOUBLE:
                    value = [];
                    value.length = n = data.readUint8();
                    for (let i = 0; i < n; i++)
                        value[i] = data.readFloat32();
                    break;
                case JsonBinRead.ARRAYBUFFER:
                    value = data.readArrayBuffer(data.readUint16());
                    break;
                case JsonBinRead.ARRAYBUFFER32:
                    value = data.readArrayBuffer(data.readUint32());
                    break;
                case JsonBinRead.INT8ARRAY:
                    n = this._getLen(data);
                    value = JsonBinRead.readInt8Array(data, data.pos, n);
                    break;
                case JsonBinRead.UINT8ARRAY:
                    n = this._getLen(data);
                    value = data.readUint8Array(data.pos, n);
                    break;
                case JsonBinRead.INT16ARRAY:
                    n = this._getLen(data);
                    value = data.readInt16Array(data.pos, n);
                    break;
                case JsonBinRead.FLOAT32ARRAY:
                    n = this._getLen(data);
                    value = data.readFloat32Array(data.pos, n);
                    break;
                default:
                    return this._readOne_other(parent, data, key, type, keyMap);
            }
            parent && key && (parent[key] = value);
            return value;
        }
        _readOne_other(parent, data, key, type, keyMap) {
            let cur = parent;
            let value;
            let n, i;
            let pos;
            switch (type) {
                case JsonBinRead.ARRAY8:
                case JsonBinRead.ARRAY16:
                case JsonBinRead.ARRAY32:
                    switch (type) {
                        case JsonBinRead.ARRAY8:
                            n = data.readUint8();
                            break;
                        case JsonBinRead.ARRAY16:
                            n = data.readInt16();
                            break;
                        case JsonBinRead.ARRAY32:
                            n = data.readUint32();
                            break;
                    }
                    var array = value = [];
                    array.length = n;
                    for (i = 0; i < n; i++) {
                        type = data.readUint8();
                        array[i] = this._readOne(null, data, null, type, keyMap);
                    }
                    break;
                case JsonBinRead.ARRAYREFSOURCE8:
                case JsonBinRead.ARRAYREFSOURCE16:
                    n = type === JsonBinRead.ARRAYREFSOURCE8 ? data.readUint8() : data.readInt16();
                    pos = data.pos - this._dataStartOfs;
                    value = this._readArray(data, -1, n, type, keyMap);
                    this._objectRef[pos] = { array: value, pos: pos };
                    break;
                case JsonBinRead.ARRAYREF:
                case JsonBinRead.ARRAYREF32:
                    i = data.readByte();
                    pos = type == JsonBinRead.ARRAYREF ? data.readUint16() : data.readUint32();
                    let objectRef = this._objectRef[pos];
                    if (!objectRef) {
                        throw "load ref err";
                    }
                    if (i == JsonBinRead.COMPRESS_NEW) {
                        value = this._readArray(data, pos + this._dataStartOfs, objectRef.array.length, type, keyMap);
                    }
                    else
                        value = objectRef.array;
                    break;
                case JsonBinRead.OBJECT:
                case JsonBinRead.OBJECTTHISCLASS:
                    if (key != null || !parent) {
                        if (type == JsonBinRead.OBJECT) {
                            cur = {};
                        }
                        else {
                            n = data.readUint16();
                            cur = this._createObjWithClass(keyMap.keyArray[n][0]);
                            if (!cur)
                                throw "jsonbin read err,no this class:" + keyMap.keyArray[n][0];
                        }
                        key && parent && (parent[key] = cur);
                    }
                    let keyDef;
                    while (true) {
                        n = data.readUint16();
                        if (n == JsonBinRead.OBJECTEND)
                            break;
                        keyDef = keyMap.keyArray[n];
                        this._readOne(cur, data, keyDef[0], keyDef[1], keyMap);
                    }
                    value = cur;
                    cur = parent;
                    break;
            }
            (key != null) && (cur[key] = value);
            return value;
        }
        read(data, createObjWithClass = null) {
            this._createObjWithClass = createObjWithClass;
            let time = Browser.now();
            let bData = new Byte();
            let strMap;
            let binMark;
            bData.writeArrayBuffer(data);
            bData.pos = 0;
            this._objectRef = {};
            binMark = bData.readInt32();
            switch (binMark) {
                case JsonBinRead.ISJSONBIN:
                    strMap = bData.readUTFString();
                    break;
                case JsonBinRead.ISJSONBIN2:
                case JsonBinRead.ISJSONBIN3:
                    strMap = bData.readUTFString32();
                    break;
                default:
                    bData.pos = 0;
                    return null;
            }
            var keyMap = new ReadKeyMap();
            keyMap.strs = strMap.split(JsonBinRead.SPLITCHAR);
            keyMap.keyArray.length = keyMap.strs.length / 2;
            for (var i = 0, n = keyMap.strs.length; i < n; i += 2) {
                keyMap.keyArray[i / 2] = [keyMap.strs[i], parseInt(keyMap.strs[i + 1])];
            }
            let time2 = Browser.now();
            this._dataStartOfs = bData.pos;
            var r = {};
            this._readOne(r, bData, null, JsonBinRead.OBJECT, keyMap);
            if ((Browser.now() - time) > 10)
                console.debug("jsonbinread delay:", (Browser.now() - time) + "/" + (time2 - time), data.byteLength);
            return binMark == JsonBinRead.ISJSONBIN3 ? r.top : r;
        }
    }
    JsonBinRead.ISJSONBIN = 0xFFFFFF;
    JsonBinRead.ISJSONBIN2 = 0xFFFFFE;
    JsonBinRead.ISJSONBIN3 = 0xFFFFFD;
    JsonBinRead.SPLITCHAR = String.fromCharCode(3);
    JsonBinRead.COMPRESS_NEW = 1;
    JsonBinRead.COMPRESS_REF = 2;
    JsonBinRead.COMPRESS_REFMODIFY = 3;
    JsonBinRead.NUM8 = 0;
    JsonBinRead.NUM16 = 1;
    JsonBinRead.NUM32 = 2;
    JsonBinRead.BOOLEAN = 3;
    JsonBinRead.DOUBLE = 4;
    JsonBinRead.STRING = 5;
    JsonBinRead.ARRAY8 = 6;
    JsonBinRead.ARRAY16 = 7;
    JsonBinRead.ARRAYEMPTY = 8;
    JsonBinRead.ARRAYNUM8 = 9;
    JsonBinRead.ARRAYNUM16 = 10;
    JsonBinRead.ARRAYNUM32 = 11;
    JsonBinRead.ARRAYDOUBLE = 12;
    JsonBinRead.ARRAYSTRING = 13;
    JsonBinRead.NULL = 14;
    JsonBinRead.OBJECT = 15;
    JsonBinRead.NUM16_1000 = 16;
    JsonBinRead.NUM32_1000 = 17;
    JsonBinRead.WORDTEXT = 18;
    JsonBinRead.ARRAYBUFFER = 19;
    JsonBinRead.ARRAYREF = 20;
    JsonBinRead.ARRAYREFSOURCE8 = 21;
    JsonBinRead.ARRAYREFSOURCE16 = 22;
    JsonBinRead.ARRAYBUFFER32 = 23;
    JsonBinRead.ARRAYREF32 = 24;
    JsonBinRead.ARRAY32 = 25;
    JsonBinRead.OBJECTTHISCLASS = 26;
    JsonBinRead.NUM64 = 27;
    JsonBinRead.INT8ARRAY = 28;
    JsonBinRead.UINT8ARRAY = 29;
    JsonBinRead.INT16ARRAY = 30;
    JsonBinRead.FLOAT32ARRAY = 31;
    JsonBinRead.OBJECTEND = 0x7FFF;
    class ReadKeyMap {
        constructor() {
            this.keys = {};
            this.strs = ["BEGIN", 0];
            this.keyArray = [];
            this.keyIndex = 1;
        }
    }

    class JsonBinWrite {
        static get instance() {
            return JsonBinWrite._instance || (JsonBinWrite._instance = new JsonBinWrite());
        }
        constructor() {
            this.objectRef = {};
            this.deep = 0;
        }
        _saveKey(key, valueType, keyMap, out) {
            this.deep++;
            var keysv = key + "/&&__*?/" + valueType;
            var keyNum = keyMap.keys[keysv];
            if (!keyNum) {
                keyNum = keyMap.keys[keysv] = keyMap.keyIndex;
                keyMap.strs.push(key, valueType);
                keyMap.keyIndex++;
            }
            out.writeUint16(keyNum);
            this.deep--;
        }
        _getValueArrayType(value) {
            switch (typeof (value)) {
                case "number":
                    if (Math.floor(value) !== value)
                        return JsonBinRead.ARRAYDOUBLE;
                    var valueabs = Math.abs(value);
                    if (valueabs < 128)
                        return JsonBinRead.ARRAYNUM8;
                    if (valueabs < 0x7FFF)
                        return JsonBinRead.ARRAYNUM16;
                    return JsonBinRead.ARRAYNUM32;
                case "string":
                    return JsonBinRead.OBJECT;
                case "boolean":
                    return JsonBinRead.BOOLEAN;
            }
            return JsonBinRead.OBJECT;
        }
        _writeStrOrWordText(keyMap, key, value, out, isWordText) {
            var type = isWordText ? JsonBinRead.WORDTEXT : JsonBinRead.STRING;
            (key != null) ? (this._saveKey(key, type, keyMap, out)) : (out.writeUint8(type));
            var keyNum = keyMap.keys[value];
            if (!keyNum) {
                keyNum = keyMap.keys[value] = keyMap.keyIndex;
                keyMap.strs.push(value, 0);
                keyMap.keyIndex++;
            }
            out.writeUint16(keyNum);
        }
        _writeString(keyMap, value, out) {
            var keyNum = keyMap.keys[value];
            if (!keyNum) {
                keyNum = keyMap.keys[value] = keyMap.keyIndex;
                keyMap.strs.push(value, 0);
                keyMap.keyIndex++;
            }
            out.writeUint16(keyNum);
        }
        _getObjectTypeof(value) {
            if (value instanceof ArrayBuffer)
                return "ArrayBuffer";
            if (value instanceof Uint8Array)
                return "Uint8Array";
            if (value instanceof Int8Array)
                return "Int8Array";
            if (value instanceof Int16Array)
                return "Int16Array";
            if (value instanceof Float32Array)
                return "Float32Array";
            if ((value instanceof WordText) || JsonBinWrite.isWordText(value))
                return "WordText";
            return "object";
        }
        static isWordText(o) {
            return o && o._text && (o._$_$ISWORDTYEXT || o.lastGCCnt != null);
        }
        _writeLen(out, len) {
            if (len < 0x80)
                out.writeUint8(len);
            else if (len < 0x8000) {
                out.writeUint8((len >> 8) | 0x80);
                out.writeUint8(len & 0xFF);
            }
            else
                throw "jsonbin save len must<0x8000" + " " + len;
        }
        _writeBigNumber(out, value) {
            let numstr = value.toString(16);
            let n1 = parseInt(numstr.substring(0, numstr.length - 7), 16);
            let n2 = parseInt(numstr.substring(numstr.length - 7), 16);
            out.writeInt32(n1);
            out.writeInt32(n2);
            if (JsonBinRead._toLargeNumber(n1, n2) != value)
                throw "save big number err:" + value;
        }
        _writeOne(out, keyMap, key, value, parent) {
            if (value == undefined) {
                return false;
            }
            let type = typeof (value);
            if (type == "object" && value) {
                if (value.$__$disbaleJsonBinSv) {
                    if (value.$__$disbaleJsonBinSv == JsonBinWrite.NOSAVETHISOBJ_DELETE) ;
                    return false;
                }
                type = this._getObjectTypeof(value);
            }
            switch (type) {
                case "number":
                    if (Math.floor(value) !== value) {
                        var value1000 = value * 1000;
                        if ((value1000 | 0) === value1000) {
                            if (Math.abs(value) < 32) {
                                (key != null) ? this._saveKey(key, JsonBinRead.NUM16_1000, keyMap, out) : out.writeUint8(JsonBinRead.NUM16_1000);
                                out.writeInt16(value1000);
                                return true;
                            }
                            if (Math.abs(value) < 2147483) {
                                (key != null) ? this._saveKey(key, JsonBinRead.NUM32_1000, keyMap, out) : out.writeUint8(JsonBinRead.NUM32_1000);
                                out.writeInt32(value1000);
                                return true;
                            }
                        }
                        (key != null) ? this._saveKey(key, JsonBinRead.DOUBLE, keyMap, out) : out.writeUint8(JsonBinRead.DOUBLE);
                        out.writeFloat32(value);
                        return true;
                    }
                    var valueabs = Math.abs(value);
                    if (valueabs < 128) {
                        (key != null) ? this._saveKey(key, JsonBinRead.NUM8, keyMap, out) : out.writeUint8(JsonBinRead.NUM8);
                        out.writeByte(value);
                        return true;
                    }
                    if (valueabs < 0x7FFF) {
                        (key != null) ? this._saveKey(key, JsonBinRead.NUM16, keyMap, out) : out.writeUint8(JsonBinRead.NUM16);
                        out.writeInt16(value);
                        return true;
                    }
                    if (valueabs < 0x7FFFFFFF) {
                        (key != null) ? this._saveKey(key, JsonBinRead.NUM32, keyMap, out) : out.writeUint8(JsonBinRead.NUM32);
                        out.writeInt32(value);
                        return true;
                    }
                    (key != null) ? this._saveKey(key, JsonBinRead.NUM64, keyMap, out) : out.writeUint8(JsonBinRead.NUM64);
                    this._writeBigNumber(out, value);
                    return true;
                case "string":
                    this._writeStrOrWordText(keyMap, key, value, out, false);
                    return true;
                case "boolean":
                    (key != null) ? this._saveKey(key, JsonBinRead.BOOLEAN, keyMap, out) : out.writeUint8(JsonBinRead.BOOLEAN);
                    out.writeByte(value ? 1 : 0);
                    return true;
                case 'ArrayBuffer':
                    (key != null) ? this._saveKey(key, JsonBinRead.ARRAYBUFFER32, keyMap, out) : out.writeUint8(JsonBinRead.ARRAYBUFFER32);
                    out.writeUint32(value.byteLength);
                    out.writeArrayBuffer(value);
                    return true;
                case 'Uint8Array':
                    (key != null) ? this._saveKey(key, JsonBinRead.UINT8ARRAY, keyMap, out) : out.writeUint8(JsonBinRead.UINT8ARRAY);
                    this._writeLen(out, value.byteLength);
                    out.writeArrayBuffer(value.buffer);
                    return true;
                case 'Int8Array':
                    (key != null) ? this._saveKey(key, JsonBinRead.INT8ARRAY, keyMap, out) : out.writeUint8(JsonBinRead.INT8ARRAY);
                    this._writeLen(out, value.byteLength);
                    out.writeArrayBuffer(value.buffer);
                    return true;
                case 'Int16Array':
                    (key != null) ? this._saveKey(key, JsonBinRead.INT16ARRAY, keyMap, out) : out.writeUint8(JsonBinRead.INT16ARRAY);
                    this._writeLen(out, value.byteLength);
                    out.writeArrayBuffer(value.buffer);
                    return true;
                case 'Float32Array':
                    (key != null) ? this._saveKey(key, JsonBinRead.FLOAT32ARRAY, keyMap, out) : out.writeUint8(JsonBinRead.FLOAT32ARRAY);
                    this._writeLen(out, value.byteLength);
                    out.writeArrayBuffer(value.buffer);
                    return true;
                case 'WordText':
                    this._writeStrOrWordText(keyMap, key, value._text, out, true);
                    return true;
                case "object":
                    break;
                default:
                    throw "jsonbin no this type:" + type;
            }
            if (!value) {
                (key != null) ? this._saveKey(key, JsonBinRead.NULL, keyMap, out) : out.writeUint8(JsonBinRead.NULL);
                return true;
            }
            if (!(value instanceof Array)) {
                if (this._classEnable_ && value.__CLASS__) {
                    (key != null) ? this._saveKey(key, JsonBinRead.OBJECTTHISCLASS, keyMap, out) : out.writeUint8(JsonBinRead.OBJECTTHISCLASS);
                }
                else
                    (key != null) ? this._saveKey(key, JsonBinRead.OBJECT, keyMap, out) : out.writeUint8(JsonBinRead.OBJECT);
                this._writeObject(out, keyMap, value);
                out.writeUint16(JsonBinRead.OBJECTEND);
                return true;
            }
            return this._saveArray(parent, out, keyMap, key, value);
        }
        _saveArray(parent, out, keyMap, key, value) {
            var j, n = value.length;
            if (n === 0) {
                (key != null) ? this._saveKey(key, JsonBinRead.ARRAYEMPTY, keyMap, out) : out.writeUint8(JsonBinRead.ARRAYEMPTY);
                out.writeByte(0);
                return true;
            }
            var startType;
            if (n > 1 && n < 250 && ((startType = this._getValueArrayType(value[0])) != JsonBinRead.OBJECT)) {
                for (j = 1; j < n; j++) {
                    if (startType !== this._getValueArrayType(value[j])) {
                        startType = JsonBinRead.OBJECT;
                        break;
                    }
                }
                if (startType != JsonBinRead.OBJECT && startType != JsonBinRead.BOOLEAN) {
                    (key != null) ? this._saveKey(key, startType, keyMap, out) : out.writeUint8(startType);
                    out.writeUint8(value.length);
                    switch (startType) {
                        case JsonBinRead.ARRAYNUM8:
                            for (j = 0; j < n; j++)
                                out.writeByte(value[j]);
                            break;
                        case JsonBinRead.ARRAYNUM16:
                            for (j = 0; j < n; j++)
                                out.writeInt16(value[j]);
                            break;
                        case JsonBinRead.ARRAYNUM32:
                            for (j = 0; j < n; j++)
                                out.writeInt32(value[j]);
                            break;
                        case JsonBinRead.ARRAYDOUBLE:
                            for (j = 0; j < n; j++)
                                out.writeFloat32(value[j]);
                            break;
                    }
                    return true;
                }
            }
            var typeArray;
            if (n < 250) {
                typeArray = JsonBinRead.ARRAY8;
            }
            else if (n < 32700) {
                typeArray = JsonBinRead.ARRAY16;
            }
            else {
                typeArray = JsonBinRead.ARRAY32;
            }
            var posHead = out.pos;
            (key != null) ? this._saveKey(key, typeArray, keyMap, out) : out.writeUint8(typeArray);
            var pos = out.pos, s = 0;
            switch (typeArray) {
                case JsonBinRead.ARRAY8:
                    out.writeUint8(n);
                    break;
                case JsonBinRead.ARRAY16:
                    out.writeInt16(n);
                    break;
                case JsonBinRead.ARRAY32:
                    out.writeUint32(n);
                    break;
            }
            var posData = out.pos;
            for (j = 0; j < n; j++) {
                if (this._writeOne(out, keyMap, null, value[j], parent))
                    s++;
            }
            if (s != n) {
                var tmp = out.pos;
                out.pos = pos;
                typeArray == JsonBinRead.ARRAY8 ? out.writeUint8(s) : out.writeInt16(s);
                out.pos = tmp;
            }
            var compress;
            if (key && parent && (compress = parent[JsonBinWrite.COMPRESS + key])) {
                this._useCompress(out, keyMap, key, value, posHead, posData, compress, typeArray);
            }
            return true;
        }
        _useCompress(out, keyMap, key, value, posHead, dataPos, compress, typeArray) {
            var dLen = out.pos - dataPos;
            var hashCode = BinHashUtils.getHash(out._u8d_, dataPos, dLen);
            var same;
            var src;
            var i, n;
            if (this.objectRef[hashCode]) {
                var datas = this.objectRef[hashCode];
                n = datas.length;
                for (i = 0; i < n; i++) {
                    src = datas[i];
                    if (src.value == value) {
                        same = src;
                        break;
                    }
                }
                if (!same) {
                    for (i = 0; i < n; i++) {
                        src = datas[i];
                        if (BinHashUtils.isSame(out._u8d_, src.pos, src.len, out._u8d_, dataPos, dLen)) {
                            same = src;
                            break;
                        }
                    }
                }
            }
            else
                this.objectRef[hashCode] = [];
            if (!same) {
                this.objectRef[hashCode].push({ hashCode: hashCode, pos: dataPos, len: dLen, value: value });
                out.pos = posHead;
                this._saveKey(key, typeArray == JsonBinRead.ARRAY8 ? JsonBinRead.ARRAYREFSOURCE8 : JsonBinRead.ARRAYREFSOURCE16, keyMap, out);
                out.pos = dataPos + dLen;
            }
            else {
                out.pos = posHead;
                this._saveKey(key, JsonBinRead.ARRAYREF32, keyMap, out);
                out.writeByte(compress);
                out.writeUint32(same.pos);
            }
        }
        _writeObject(out, keyMap, o) {
            this._classEnable_ && o.__CLASS__ && this._writeString(keyMap, o.__CLASS__, out);
            for (var key in o) {
                if (key && key.length > JsonBinWrite.NOSAVE_KEY_LEN && key.substr(0, JsonBinWrite.NOSAVE_KEY_LEN) == JsonBinWrite.NOSAVEKEY) {
                    continue;
                }
                (this._classEnable_ && key == "__CLASS__") || this._writeOne(out, keyMap, key, o[key], o);
            }
        }
        write(o, __CLASS__ = false) {
            this.deep = 0;
            this._classEnable_ = __CLASS__;
            var keyMap = new SaveKeyMap();
            this.objectRef = {};
            var out = new Byte();
            this._writeObject(out, keyMap, { top: o });
            out.writeUint16(JsonBinRead.OBJECTEND);
            var r = new Byte();
            r.writeInt32(JsonBinRead.ISJSONBIN3);
            r.writeUTFString32(keyMap.strs.join(JsonBinRead.SPLITCHAR));
            r.writeArrayBuffer(out.buffer);
            return r.buffer;
        }
    }
    JsonBinWrite.COMPRESS = "_$TeMpkEy$_CoMpReSs";
    JsonBinWrite.NOSAVEKEY = "_$TeMpkEyNoSv$_";
    JsonBinWrite.NOSAVETHISOBJ = "$__$disbaleJsonBinSv";
    JsonBinWrite.NOSAVE_KEY_LEN = 15;
    JsonBinWrite.NOSAVETHISOBJ_DELETE = 2;
    JsonBinWrite.NOSAVETHISOBJ_TRUE = 1;
    class SaveKeyMap {
        constructor() {
            this.keys = {};
            this.strs = ["BEGIN", 0];
            this.keyArray = [];
            this.keyIndex = 1;
        }
    }

    class WebGLCacheAsNormalCanvas {
        constructor(ctx, sp) {
            this.submitStartPos = 0;
            this.submitEndPos = 0;
            this.touches = [];
            this.submits = [];
            this.sprite = null;
            this.meshlist = [];
            this.cachedClipInfo = new Matrix();
            this.oldTx = 0;
            this.oldTy = 0;
            this.invMat = new Matrix();
            this.context = ctx;
            this.sprite = sp;
            ctx._globalClipMatrix.copyTo(this.cachedClipInfo);
        }
        startRec() {
        }
        endRec() {
        }
        isTextNeedRestore() {
            var textNeedRestore = false;
            var charRIs = this.touches;
            if (charRIs) {
                for (var ci = 0; ci < charRIs.length; ci++) {
                    if (charRIs[ci].deleted) {
                        textNeedRestore = true;
                        break;
                    }
                }
            }
            return textNeedRestore;
        }
        flushsubmit() {
            SubmitBase.RENDERBASE;
            this.submits.forEach((subm) => {
                if (subm == SubmitBase.RENDERBASE)
                    return;
            });
        }
        releaseMem() {
        }
    }
    WebGLCacheAsNormalCanvas.matI = new Matrix();

    class ArabicReshaper {
        characterMapContains(c) {
            for (var i = 0; i < charsMap.length; ++i) {
                if (charsMap[i][0] === c) {
                    return true;
                }
            }
            return false;
        }
        getCharRep(c) {
            for (var i = 0; i < charsMap.length; ++i) {
                if (charsMap[i][0] === c) {
                    return charsMap[i];
                }
            }
            return false;
        }
        getCombCharRep(c1, c2) {
            for (var i = 0; i < combCharsMap.length; ++i) {
                if (combCharsMap[i][0][0] === c1 && combCharsMap[i][0][1] === c2) {
                    return combCharsMap[i];
                }
            }
            return false;
        }
        isTransparent(c) {
            for (var i = 0; i < transChars.length; ++i) {
                if (transChars[i] === c) {
                    return true;
                }
            }
            return false;
        }
        getOriginalCharsFromCode(code) {
            var j;
            for (j = 0; j < charsMap.length; ++j) {
                if (charsMap[j].indexOf(code) > -1) {
                    return String.fromCharCode(charsMap[j][0]);
                }
            }
            for (j = 0; j < combCharsMap.length; ++j) {
                if (combCharsMap[j].indexOf(code) > -1) {
                    return String.fromCharCode(combCharsMap[j][0][0]) +
                        String.fromCharCode(combCharsMap[j][0][1]);
                }
            }
            return String.fromCharCode(code);
        }
        convertArabic(normal) {
            var crep, combcrep, shaped = '';
            for (var i = 0; i < normal.length; ++i) {
                var current = normal.charCodeAt(i);
                if (this.characterMapContains(current)) {
                    var prev = null, next = null, prevID = i - 1, nextID = i + 1;
                    for (; prevID >= 0; --prevID) {
                        if (!this.isTransparent(normal.charCodeAt(prevID))) {
                            break;
                        }
                    }
                    prev = (prevID >= 0) ? normal.charCodeAt(prevID) : null;
                    crep = prev ? this.getCharRep(prev) : false;
                    if (!crep || crep[2] == null && crep[3] == null) {
                        prev = null;
                    }
                    for (; nextID < normal.length; ++nextID) {
                        if (!this.isTransparent(normal.charCodeAt(nextID))) {
                            break;
                        }
                    }
                    next = (nextID < normal.length) ? normal.charCodeAt(nextID) : null;
                    crep = next ? this.getCharRep(next) : false;
                    if (!crep || crep[3] == null && crep[4] == null) {
                        next = null;
                    }
                    if (current === 0x0644 && next != null &&
                        (next === 0x0622 || next === 0x0623 || next === 0x0625 || next === 0x0627)) {
                        combcrep = this.getCombCharRep(current, next);
                        if (prev != null) {
                            shaped += String.fromCharCode(combcrep[4]);
                        }
                        else {
                            shaped += String.fromCharCode(combcrep[1]);
                        }
                        ++i;
                        continue;
                    }
                    crep = this.getCharRep(current);
                    if (prev != null && next != null && crep[3] != null) {
                        shaped += String.fromCharCode(crep[3]);
                        continue;
                    }
                    else if (prev != null && crep[4] != null) {
                        shaped += String.fromCharCode(crep[4]);
                        continue;
                    }
                    else if (next != null && crep[2] != null) {
                        shaped += String.fromCharCode(crep[2]);
                        continue;
                    }
                    else {
                        shaped += String.fromCharCode(crep[1]);
                    }
                }
                else {
                    shaped += String.fromCharCode(current);
                }
            }
            return shaped;
        }
        convertArabicBack(apfb) {
            var toReturn = '', selectedChar;
            var i;
            for (i = 0; i < apfb.length; ++i) {
                selectedChar = apfb.charCodeAt(i);
                toReturn += this.getOriginalCharsFromCode(selectedChar);
            }
            return toReturn;
        }
    }
    const charsMap = [[0x0621, 0xFE80, null, null, null],
        [0x0622, 0xFE81, null, null, 0xFE82],
        [0x0623, 0xFE83, null, null, 0xFE84],
        [0x0624, 0xFE85, null, null, 0xFE86],
        [0x0625, 0xFE87, null, null, 0xFE88],
        [0x0626, 0xFE89, 0xFE8B, 0xFE8C, 0xFE8A],
        [0x0627, 0xFE8D, null, null, 0xFE8E],
        [0x0628, 0xFE8F, 0xFE91, 0xFE92, 0xFE90],
        [0x0629, 0xFE93, null, null, 0xFE94],
        [0x062A, 0xFE95, 0xFE97, 0xFE98, 0xFE96],
        [0x062B, 0xFE99, 0xFE9B, 0xFE9C, 0xFE9A],
        [0x062C, 0xFE9D, 0xFE9F, 0xFEA0, 0xFE9E],
        [0x062D, 0xFEA1, 0xFEA3, 0xFEA4, 0xFEA2],
        [0x062E, 0xFEA5, 0xFEA7, 0xFEA8, 0xFEA6],
        [0x062F, 0xFEA9, null, null, 0xFEAA],
        [0x0630, 0xFEAB, null, null, 0xFEAC],
        [0x0631, 0xFEAD, null, null, 0xFEAE],
        [0x0632, 0xFEAF, null, null, 0xFEB0],
        [0x0633, 0xFEB1, 0xFEB3, 0xFEB4, 0xFEB2],
        [0x0634, 0xFEB5, 0xFEB7, 0xFEB8, 0xFEB6],
        [0x0635, 0xFEB9, 0xFEBB, 0xFEBC, 0xFEBA],
        [0x0636, 0xFEBD, 0xFEBF, 0xFEC0, 0xFEBE],
        [0x0637, 0xFEC1, 0xFEC3, 0xFEC4, 0xFEC2],
        [0x0638, 0xFEC5, 0xFEC7, 0xFEC8, 0xFEC6],
        [0x0639, 0xFEC9, 0xFECB, 0xFECC, 0xFECA],
        [0x063A, 0xFECD, 0xFECF, 0xFED0, 0xFECE],
        [0x0640, 0x0640, 0x0640, 0x0640, 0x0640],
        [0x0641, 0xFED1, 0xFED3, 0xFED4, 0xFED2],
        [0x0642, 0xFED5, 0xFED7, 0xFED8, 0xFED6],
        [0x0643, 0xFED9, 0xFEDB, 0xFEDC, 0xFEDA],
        [0x0644, 0xFEDD, 0xFEDF, 0xFEE0, 0xFEDE],
        [0x0645, 0xFEE1, 0xFEE3, 0xFEE4, 0xFEE2],
        [0x0646, 0xFEE5, 0xFEE7, 0xFEE8, 0xFEE6],
        [0x0647, 0xFEE9, 0xFEEB, 0xFEEC, 0xFEEA],
        [0x0648, 0xFEED, null, null, 0xFEEE],
        [0x0649, 0xFEEF, null, null, 0xFEF0],
        [0x064A, 0xFEF1, 0xFEF3, 0xFEF4, 0xFEF2],
        [0x067E, 0xFB56, 0xFB58, 0xFB59, 0xFB57],
        [0x06CC, 0xFBFC, 0xFBFE, 0xFBFF, 0xFBFD],
        [0x0686, 0xFB7A, 0xFB7C, 0xFB7D, 0xFB7B],
        [0x06A9, 0xFB8E, 0xFB90, 0xFB91, 0xFB8F],
        [0x06AF, 0xFB92, 0xFB94, 0xFB95, 0xFB93],
        [0x0698, 0xFB8A, null, null, 0xFB8B]];
    const combCharsMap = [[[0x0644, 0x0622], 0xFEF5, null, null, 0xFEF6],
        [[0x0644, 0x0623], 0xFEF7, null, null, 0xFEF8],
        [[0x0644, 0x0625], 0xFEF9, null, null, 0xFEFA],
        [[0x0644, 0x0627], 0xFEFB, null, null, 0xFEFC]];
    const transChars = [0x0610,
        0x0612,
        0x0613,
        0x0614,
        0x0615,
        0x064B,
        0x064C,
        0x064D,
        0x064E,
        0x064F,
        0x0650,
        0x0651,
        0x0652,
        0x0653,
        0x0654,
        0x0655,
        0x0656,
        0x0657,
        0x0658,
        0x0670,
        0x06D6,
        0x06D7,
        0x06D8,
        0x06D9,
        0x06DA,
        0x06DB,
        0x06DC,
        0x06DF,
        0x06E0,
        0x06E1,
        0x06E2,
        0x06E3,
        0x06E4,
        0x06E7,
        0x06E8,
        0x06EA,
        0x06EB,
        0x06EC,
        0x06ED];

    class BufferState {
        constructor() {
            this._deviceBufferState = LayaGL.renderDeviceFactory.createBufferState();
        }
        applyState(vertexBuffers, indexBuffer) {
            this._vertexBuffers = vertexBuffers;
            this._bindedIndexBuffer = indexBuffer;
            if (!this._deviceBufferState)
                return;
            if (vertexBuffers.length == 1) {
                BufferState.vertexBufferArray.length = 1;
                BufferState.vertexBufferArray[0] = vertexBuffers[0]._deviceBuffer;
            }
            else {
                BufferState.vertexBufferArray.length = 0;
                vertexBuffers.forEach(element => {
                    BufferState.vertexBufferArray.push(element._deviceBuffer);
                });
            }
            this._deviceBufferState.applyState(BufferState.vertexBufferArray, indexBuffer ? indexBuffer._deviceBuffer : null);
        }
        destroy() {
            if (!this._deviceBufferState)
                return;
            this._deviceBufferState.destroy();
            this._deviceBufferState = null;
        }
    }
    BufferState.vertexBufferArray = [];

    class MatirxArray {
        static ArrayMul(a, b, o) {
            if (!a) {
                MatirxArray.copyArray(b, o);
                return;
            }
            if (!b) {
                MatirxArray.copyArray(a, o);
                return;
            }
            var ai0, ai1, ai2, ai3;
            for (var i = 0; i < 4; i++) {
                ai0 = a[i];
                ai1 = a[i + 4];
                ai2 = a[i + 8];
                ai3 = a[i + 12];
                o[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];
                o[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];
                o[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];
                o[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
            }
        }
        static copyArray(f, t) {
            if (!f)
                return;
            if (!t)
                return;
            for (var i = 0; i < f.length; i++) {
                t[i] = f[i];
            }
        }
    }

    exports.AlphaCmd = AlphaCmd;
    exports.Animation = Animation;
    exports.Animation2DCondition = Animation2DCondition;
    exports.Animation2DEvent = Animation2DEvent;
    exports.Animation2DParm = Animation2DParm;
    exports.AnimationBase = AnimationBase;
    exports.AnimationClip2D = AnimationClip2D;
    exports.AnimationClip2DParse01 = AnimationClip2DParse01;
    exports.Animator2D = Animator2D;
    exports.AnimatorController2D = AnimatorController2D;
    exports.AnimatorControllerLayer2D = AnimatorControllerLayer2D;
    exports.AnimatorControllerParse = AnimatorControllerParse;
    exports.AnimatorPlayState2D = AnimatorPlayState2D;
    exports.AnimatorState2D = AnimatorState2D;
    exports.AnimatorState2DScript = AnimatorState2DScript;
    exports.AnimatorStateBoolCondition = AnimatorStateBoolCondition;
    exports.AnimatorStateCondition = AnimatorStateCondition;
    exports.AnimatorStateNumberCondition = AnimatorStateNumberCondition;
    exports.AnimatorStateTriggerCondition = AnimatorStateTriggerCondition;
    exports.AnimatorTransition2D = AnimatorTransition2D;
    exports.ArabicReshaper = ArabicReshaper;
    exports.AssetDb = AssetDb;
    exports.AtlasGrid = AtlasGrid;
    exports.AtlasInfoManager = AtlasInfoManager;
    exports.AtlasResource = AtlasResource;
    exports.AudioSound = AudioSound;
    exports.AudioSoundChannel = AudioSoundChannel;
    exports.Base64Tool = Base64Tool;
    exports.BasePoly = BasePoly;
    exports.BaseRenderNode2D = BaseRenderNode2D;
    exports.BaseTexture = BaseTexture;
    exports.Batch2DInfo = Batch2DInfo;
    exports.BatchProgress = BatchProgress;
    exports.Bezier = Bezier;
    exports.BinHashUtils = BinHashUtils;
    exports.BitmapFont = BitmapFont;
    exports.BlendComponent = BlendComponent;
    exports.BlendMode = BlendMode;
    exports.BlendState = BlendState;
    exports.BlurFilter = BlurFilter;
    exports.BoundsStyle = BoundsStyle;
    exports.Browser = Browser;
    exports.Buffer = Buffer;
    exports.BufferState = BufferState;
    exports.ButtonEffect = ButtonEffect;
    exports.Byte = Byte;
    exports.CacheManger = CacheManger;
    exports.CachePage = CachePage;
    exports.CacheStyle = CacheStyle;
    exports.Cache_Info = Cache_Info;
    exports.CallLater = CallLater;
    exports.CharRenderInfo = CharRenderInfo;
    exports.CharRender_Canvas = CharRender_Canvas;
    exports.CharSubmitCache = CharSubmitCache;
    exports.ClassUtils = ClassUtils;
    exports.ClipRectCmd = ClipRectCmd;
    exports.Color = Color;
    exports.ColorFilter = ColorFilter;
    exports.ColorUtils = ColorUtils;
    exports.CommandEncoder = CommandEncoder;
    exports.CommandUniformMap = CommandUniformMap;
    exports.Component = Component;
    exports.ComponentDriver = ComponentDriver;
    exports.Config = Config;
    exports.Config3D = Config3D;
    exports.Const = Const;
    exports.Context = Context;
    exports.DDSTextureInfo = DDSTextureInfo;
    exports.DefferTouchResContext = DefferTouchResContext;
    exports.Delegate = Delegate;
    exports.DepthState = DepthState;
    exports.Downloader = Downloader;
    exports.Dragging = Dragging;
    exports.Draw9GridTextureCmd = Draw9GridTextureCmd;
    exports.DrawCircleCmd = DrawCircleCmd;
    exports.DrawCurvesCmd = DrawCurvesCmd;
    exports.DrawEllipseCmd = DrawEllipseCmd;
    exports.DrawGeoCmd = DrawGeoCmd;
    exports.DrawGeosCmd = DrawGeosCmd;
    exports.DrawImageCmd = DrawImageCmd;
    exports.DrawLineCmd = DrawLineCmd;
    exports.DrawLinesCmd = DrawLinesCmd;
    exports.DrawPathCmd = DrawPathCmd;
    exports.DrawPieCmd = DrawPieCmd;
    exports.DrawPolyCmd = DrawPolyCmd;
    exports.DrawRectCmd = DrawRectCmd;
    exports.DrawRoundRectCmd = DrawRoundRectCmd;
    exports.DrawStyle = DrawStyle;
    exports.DrawTextureCmd = DrawTextureCmd;
    exports.DrawTexturesCmd = DrawTexturesCmd;
    exports.DrawTrianglesCmd = DrawTrianglesCmd;
    exports.Earcut = Earcut;
    exports.EarcutNode = EarcutNode;
    exports.Ease = Ease;
    exports.EffectAnimation = EffectAnimation;
    exports.EffectBase = EffectBase;
    exports.Event = Event;
    exports.EventDispatcher = EventDispatcher;
    exports.FadeIn = FadeIn;
    exports.FadeOut = FadeOut;
    exports.FastSinglelist = FastSinglelist;
    exports.FillTextCmd = FillTextCmd;
    exports.FillTextureCmd = FillTextureCmd;
    exports.Filter = Filter;
    exports.FontInfo = FontInfo;
    exports.FrameAnimation = FrameAnimation;
    exports.GLSLCodeGenerator = GLSLCodeGenerator;
    exports.GlowFilter = GlowFilter;
    exports.GrahamScan = GrahamScan;
    exports.GraphicAnimation = GraphicAnimation;
    exports.Graphics = Graphics;
    exports.GraphicsBounds = GraphicsBounds;
    exports.HDRTextureInfo = HDRTextureInfo;
    exports.HTMLCanvas = HTMLCanvas;
    exports.HalfFloatUtils = HalfFloatUtils;
    exports.Handler = Handler;
    exports.HideFlags = HideFlags;
    exports.HierarchyLoader = HierarchyLoader;
    exports.HierarchyParser = HierarchyParser;
    exports.HierarchyResource = HierarchyResource;
    exports.HitArea = HitArea;
    exports.HtmlElement = HtmlElement;
    exports.HtmlImage = HtmlImage;
    exports.HtmlLink = HtmlLink;
    exports.HtmlParseOptions = HtmlParseOptions;
    exports.HtmlParser = HtmlParser;
    exports.HttpRequest = HttpRequest;
    exports.ICharRender = ICharRender;
    exports.ILaya = ILaya;
    exports.ImgUtils = ImgUtils;
    exports.IncludeFile = IncludeFile;
    exports.IndexBuffer = IndexBuffer;
    exports.Input = Input;
    exports.InputManager = InputManager;
    exports.JsonBinRead = JsonBinRead;
    exports.JsonBinWrite = JsonBinWrite;
    exports.KTXTextureInfo = KTXTextureInfo;
    exports.KeyLocation = KeyLocation;
    exports.Keyboard = Keyboard;
    exports.Keyframe2D = Keyframe2D;
    exports.KeyframeNode2D = KeyframeNode2D;
    exports.KeyframeNodeList2D = KeyframeNodeList2D;
    exports.Laya = Laya;
    exports.LayaEnv = LayaEnv;
    exports.LayaGL = LayaGL;
    exports.LayaGLQuickRunner = LayaGLQuickRunner;
    exports.Loader = Loader;
    exports.LocalStorage = LocalStorage;
    exports.Log = Log;
    exports.Material = Material;
    exports.MaterialLoader = MaterialLoader;
    exports.MaterialParser = MaterialParser;
    exports.MathUtil = MathUtil;
    exports.MathUtils3D = MathUtils3D;
    exports.MatirxArray = MatirxArray;
    exports.Matrix = Matrix;
    exports.Matrix3x3 = Matrix3x3;
    exports.Matrix4x4 = Matrix4x4;
    exports.MeasureFont = MeasureFont;
    exports.Mesh2D = Mesh2D;
    exports.MeshQuadTexture = MeshQuadTexture;
    exports.MeshTexture = MeshTexture;
    exports.MeshVG = MeshVG;
    exports.Mouse = Mouse;
    exports.Node = Node;
    exports.NodeFlags = NodeFlags;
    exports.NotImplementedError = NotImplementedError;
    exports.NotReadableError = NotReadableError;
    exports.NullLoader = NullLoader;
    exports.OutOfRangeError = OutOfRangeError;
    exports.PERF_BEGIN = PERF_BEGIN;
    exports.PERF_END = PERF_END;
    exports.PERF_FRAMECLEAR = PERF_FRAMECLEAR;
    exports.ParseJSON = ParseJSON;
    exports.Path = Path;
    exports.PerfData = PerfData;
    exports.PerfHUD = PerfHUD;
    exports.PerfTools = PerfTools;
    exports.PerformanceDefine = PerformanceDefine;
    exports.PlayerConfig = PlayerConfig;
    exports.Point = Point;
    exports.Pool = Pool;
    exports.PoolCache = PoolCache;
    exports.Prefab = Prefab;
    exports.PrefabImpl = PrefabImpl;
    exports.PrimitiveSV = PrimitiveSV;
    exports.Quaternion = Quaternion;
    exports.QuickTestTool = QuickTestTool;
    exports.Rectangle = Rectangle;
    exports.Render = Render;
    exports.Render2D = Render2D;
    exports.Render2DSimple = Render2DSimple;
    exports.RenderInfo = RenderInfo;
    exports.RenderManager2D = RenderManager2D;
    exports.RenderObject2D = RenderObject2D;
    exports.RenderSprite = RenderSprite;
    exports.RenderState = RenderState;
    exports.RenderState2D = RenderState2D;
    exports.RenderStateContext = RenderStateContext;
    exports.RenderTexture = RenderTexture;
    exports.RenderTexture2D = RenderTexture2D;
    exports.RenderTextureCube = RenderTextureCube;
    exports.RenderTextureLoader = RenderTextureLoader;
    exports.RenderToCache = RenderToCache;
    exports.Resource = Resource;
    exports.RestoreCmd = RestoreCmd;
    exports.RotateCmd = RotateCmd;
    exports.RunDriver = RunDriver;
    exports.SaveBase = SaveBase;
    exports.SaveClipRect = SaveClipRect;
    exports.SaveCmd = SaveCmd;
    exports.SaveMark = SaveMark;
    exports.SaveTransform = SaveTransform;
    exports.SaveTranslate = SaveTranslate;
    exports.ScaleCmd = ScaleCmd;
    exports.Scene = Scene;
    exports.Script = Script;
    exports.SerializeUtil = SerializeUtil;
    exports.Shader2D = Shader2D;
    exports.Shader3D = Shader3D;
    exports.ShaderCompile = ShaderCompile;
    exports.ShaderCompileDefineBase = ShaderCompileDefineBase;
    exports.ShaderData = ShaderData;
    exports.ShaderDataDefaultValue = ShaderDataDefaultValue;
    exports.ShaderDefine = ShaderDefine;
    exports.ShaderDefines2D = ShaderDefines2D;
    exports.ShaderNode = ShaderNode;
    exports.ShaderParser = ShaderParser;
    exports.ShaderPass = ShaderPass;
    exports.ShaderProcessInfo = ShaderProcessInfo;
    exports.ShaderVariable = ShaderVariable;
    exports.ShaderVariant = ShaderVariant;
    exports.ShaderVariantCollection = ShaderVariantCollection;
    exports.SingletonList = SingletonList;
    exports.Socket = Socket;
    exports.Sound = Sound;
    exports.SoundChannel = SoundChannel;
    exports.SoundManager = SoundManager;
    exports.SoundNode = SoundNode;
    exports.Sprite = Sprite;
    exports.Sprite2DGeometry = Sprite2DGeometry;
    exports.SpriteCache = SpriteCache;
    exports.SpriteConst = SpriteConst;
    exports.SpriteStyle = SpriteStyle;
    exports.SpriteUtils = SpriteUtils;
    exports.Stage = Stage;
    exports.Stat = Stat;
    exports.StencilState = StencilState;
    exports.StringKey = StringKey;
    exports.SubShader = SubShader;
    exports.SubUniformBufferData = SubUniformBufferData;
    exports.SubmitBase = SubmitBase;
    exports.SubmitKey = SubmitKey;
    exports.System = System;
    exports.Text = Text;
    exports.TextAtlas = TextAtlas;
    exports.TextRender = TextRender;
    exports.TextResource = TextResource;
    exports.TextStyle = TextStyle;
    exports.TextTexture = TextTexture;
    exports.Texture = Texture;
    exports.Texture2D = Texture2D;
    exports.Texture2DArray = Texture2DArray;
    exports.Texture2DLoader = Texture2DLoader;
    exports.Texture3D = Texture3D;
    exports.TextureCube = TextureCube;
    exports.TextureLoader = TextureLoader;
    exports.TextureSV = TextureSV;
    exports.TimeLine = TimeLine;
    exports.Timer = Timer;
    exports.TransformCmd = TransformCmd;
    exports.TranslateCmd = TranslateCmd;
    exports.Tween = Tween;
    exports.TypedArrayClasses = TypedArrayClasses;
    exports.UBBParser = UBBParser;
    exports.URL = URL;
    exports.UniformBufferAlone = UniformBufferAlone;
    exports.UniformBufferBase = UniformBufferBase;
    exports.UniformBufferBlock = UniformBufferBlock;
    exports.UniformBufferCluster = UniformBufferCluster;
    exports.UniformBufferManager = UniformBufferManager;
    exports.UniformBufferObject = UniformBufferObject;
    exports.UniformBufferUser = UniformBufferUser;
    exports.UnifromBufferData = UnifromBufferData;
    exports.Utils = Utils;
    exports.Value2D = Value2D;
    exports.Value2DManager = Value2DManager;
    exports.Vector2 = Vector2;
    exports.Vector3 = Vector3;
    exports.Vector4 = Vector4;
    exports.VectorGraphManager = VectorGraphManager;
    exports.VertexAttributeLayout = VertexAttributeLayout;
    exports.VertexBuffer = VertexBuffer;
    exports.VertexDeclaration = VertexDeclaration;
    exports.VertexElement = VertexElement;
    exports.VertexElementFormat = VertexElementFormat;
    exports.VertexMesh = VertexMesh;
    exports.VertexMesh2D = VertexMesh2D;
    exports.VertexStateContext = VertexStateContext;
    exports.VideoNode = VideoNode;
    exports.VideoTexture = VideoTexture;
    exports.VideoTextureLoader = VideoTextureLoader;
    exports.Viewport = Viewport;
    exports.WasmAdapter = WasmAdapter;
    exports.WeakObject = WeakObject;
    exports.WebAudioSound = WebAudioSound;
    exports.WebAudioSoundChannel = WebAudioSoundChannel;
    exports.WebGL = WebGL;
    exports.WebGLCacheAsNormalCanvas = WebGLCacheAsNormalCanvas;
    exports.WebGLRTMgr = WebGLRTMgr;
    exports.Widget = Widget;
    exports.WordText = WordText$1;
    exports.WorkerLoader = WorkerLoader;
    exports.XML = XML;
    exports.XMLIterator = XMLIterator;
    exports.XMLUtils = XMLUtils;
    exports.addAfterInitCallback = addAfterInitCallback;
    exports.addBeforeInitCallback = addBeforeInitCallback;
    exports.addInitCallback = addInitCallback;
    exports.alertGlobalError = alertGlobalError;
    exports.allowMultiple = allowMultiple;
    exports.classInfo = classInfo;
    exports.enableDebugPanel = enableDebugPanel;
    exports.init = init;
    exports.property = property;
    exports.regClass = regClass;
    exports.regLoader = regLoader;
    exports.roundDown = roundDown;
    exports.roundUp = roundUp;
    exports.runInEditor = runInEditor;

    return exports;

})({});
//# sourceMappingURL=laya.core.js.map
